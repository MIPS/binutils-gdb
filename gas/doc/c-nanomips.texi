@c Copyright (C) 2018 Free Software Foundation, Inc.
@c Contributed by MIPS Tech LLC.
@c Written by Faraz Shahbazker <faraz.shahbazker@mips.com>
@c This is part of the GAS manual.
@c For copying conditions, see the file as.texinfo.

@macro doleft{TEXT}
@flushleft \TEXT\
@end flushleft
@end macro

@ifset GENERIC
@page
@node nanoMIPS-Dependent
@chapter nanoMIPS Dependent Features
@end ifset
@ifclear GENERIC
@node Machine Dependencies
@chapter nanoMIPS Dependent Features
@end ifclear

@cindex nanoMIPS processor

@menu
* nanoMIPS Options::            Assembler Options
* nanoMIPS Directives::         Assembler Directives
* nanoMIPS Reloc Operators::    Explicit Relocation Operators
* nanoMIPS Macros::             High-level Assembly Macros
* nanoMIPS Aliases::            1:1 Instruction Aliases
* nanoMIPS Small Data::         Small Data Access
* nanoMIPS Relocations::        Using relocation operators for different
                                addressing modes
* nanoMIPS Instruction Selection:: Controlling Instruction Selection
* nanoMIPS Transformations:: Controlling Linker Relaxation
* nanoMIPS Syntax::             Syntactical Considerations
@end menu

@node nanoMIPS Options
@section Assembler Options

The nanoMIPS configurations of @sc{gnu} @code{@value{AS}} support these
special options:

@table @code
@cindex -G option (nanoMIPS)
@item -G @var{num}
Set the ``small data'' limit to @var{n} bytes.  The default limit is 8 bytes.
@xref{nanoMIPS Small Data, , Controlling the use of small data accesses}.

@cindex @code{-EB} option (nanoMIPS)
@cindex @code{-EL} option (nanoMIPS)
@cindex nanoMIPS big-endian output
@cindex nanoMIPS little-endian output
@cindex big-endian output, nanoMIPS
@cindex little-endian output, nanoMIPS
@item -EB
@itemx -EL
Any nanoMIPS configuration of @code{@value{AS}} can select big-endian or
little-endian output at run time (unlike the other @sc{gnu} development
tools, which must be configured for one or the other).  Use @samp{-EB}
to select big-endian output, and @samp{-EL} for little-endian.

@item -march=@var{arch}
Generate code for a particular nanoMIPS @var{arch}, which can be the
name of a generic nanoMIPS @var{ISA} or the name of a particular
@var{CPU}.  Valid @var{ISA} value are:

@quotation
32r6,
32r6s,
64r6
@end quotation

Valid @var{CPU} value are:

@quotation
i7200,
nms1
@end quotation

@item -mtune=@var{cpu}
Schedule and tune for a particular nanoMIPS CPU.  Valid @var{cpu} values are
identical to @samp{-march=@var{cpu}}.

@item -m32
Generate code for the p32 ABI.

@item -m64
Generate code for the p64 ABI.

@item -mcmodel=@var{mmodel}
Generate code for a particular C Memory Model.  The following memory models
are supported: @code{auto}, @code{medium}, @code{large}

@item -mpic
@itemx -mno-pic
Generate medium model SVR4-style PIC.  This option tells the assembler
to generate SVR4-style position-independent macro expansions.  It also
tells the assembler to mark the output file as PIC.
@samp{-mno-pic} turns off this option.

@item -mPIC
@itemx -mno-PIC
Generate large model SVR4-style PIC.  This option tells the assembler
to generate SVR4-style position-independent macro expansions.  It also
tells the assembler to mark the output file as PIC.
@samp{-mno-PIC} turns off this option.

@item -mpid
@itemx -mno-pid
Generate position independent data.  This option tells the assembler to
generate data sections that can be repositioned independent of code placement.
It also tells the assembler to mark the output file as PID.
@samp{-mno-pid} turns off this option.

@item -mpcrel
@itemx -mno-pcrel
Generate PC-relative expansions.  This option tells the assembler to
avoid the use of absolute addresses for symbols even when those
addresses may be known at link time.  It also tells the assembler to
mark the output file as purely PC-relative.
@samp{-mno-pcrel} turns off this option.

@item --linkrelax
Enable link-time relaxation features.  The assembler will generate
additional relocations to allow the linker to expand/relax object
code and preserve correctness.

@item -minsn32
@itemx -mno-insn32
Only use 32-bit instruction encodings.  This option inhibits the use
of 16-bit and 48-bit instructions.  This is equivalent to putting
@code{.module insn32} at the start of the assembly file.
@samp{-mno-insn32} turns off this option.  This is equivalent to
putting @code{.module noinsn32} at the start of the assembly file.  By
default @samp{-mno-insn32} is selected, allowing all instructions to
be used.

@item -mcrc
@itemx -mno-crc
Generate code for the Cyclic Redundancy Check Application Specific
Extension.  This tells the assembler to accept CRC instructions.
@samp{-mno-crc} turns off this option.

@item -mdsp
@itemx -mno-dsp
Generate code for the DSP Application Specific Extension.  This tells
the assembler to accept DSP instructions.  Since the lowest Release
version of DSP ASE supported by nanoMIPS is Release 3, this option is
equivalent to @samp{-mdspr3}.
@samp{-mno-dsp} turns off this option.  This option is equivalent to
@samp{-mno-dspr3}.

@item -mdspr3
@itemx -mno-dspr3
Generate code for the DSP Release 3 Application Specific Extension.
This tells the assembler to accept DSP Release 3 instructions.
@samp{-mno-dspr3} turns off this option.

@item -meva
@itemx -mno-eva
Generate code for the Enhanced Virtual Addressing Application Specific
Extension.  This tells the assembler to accept EVA instructions.
@samp{-mno-eva} turns off this option.

@item -mginv
@itemx -mno-ginv
Generate code for the Global cache INValidate Application Specific Extension.
This tells the assembler to accept GINV instructions.
@samp{-mno-ginv} turns off this option.

@item -mmcu
@itemx -mno-mcu
Generate code for the MCU Application Specific Extension.
This tells the assembler to accept MCU instructions.
@samp{-mno-mcu} turns off this option.

@item -mmt
@itemx -mno-mt
Generate code for the MT Application Specific Extension.
This tells the assembler to accept MT instructions.
@samp{-mno-mt} turns off this option.

@item -mtlb
@itemx -mno-tlb
Generate code for the Translation Lookaside Buffer control extension.
This tells the assembler to accept TLB control instructions.
@samp{-mno-tlb} turns off this option.

@item -mvirt
@itemx -mno-virt
Generate code for the Virtualization Application Specific Extension.
This tells the assembler to accept Virtualization instructions.
@samp{-mno-virt} turns off this option.

@item -msoft-float
@itemx -mhard-float
Disable or enable floating-point instructions.  Note that by default
floating-point instructions are always allowed even with CPU targets
that don't have support for these instructions.

@item -msingle-float
@itemx -mdouble-float
Disable or enable double-precision floating-point operations.  Note
that by default double-precision floating-point operations are always
allowed even with CPU targets that don't have support for these
operations.

@item --construct-floats
@itemx --no-construct-floats
The @code{--no-construct-floats} option disables the construction of
floating point constants in code by loading the values from memory
instead.

By default @code{--construct-floats} is selected, allowing construction
of these floating point constants.

@item -mbalc-stubs
@itemx -mno-balc-stubs
Consolidate multiple out-of-range call instructions to a function to
16-bit calls to a stub with transfers control to the function.  The
@samp{-mbalc-stubs} option improves code compression at the cost
of performance, since each transformed call requires two control
transfers.

This optimization is disabled by default.

@item -mlegacyregs
Allow the use of legacy MIPS style numeric register formats in
nanoMIPS assembly.

@item --trap
@itemx --no-break
@c FIXME!  (1) reflect these options (next item too) in option summaries;

@item --break
@itemx --no-trap
Generate code to take a break exception rather than a trap exception when an
error is detected.  This is the default.

@item -mminimize-relocs
@itemx -mno-minimize-relocs
Finalize PC-relative relocations that are link-time invariant at the time
of assembly. The @samp{-mminimize-relocs} reduces the size of the generated
object code by removing some relocations and hence the time needed to link
with relaxations.

This option is enabled by default.
@end table

@node nanoMIPS Directives
@section Assembler Directives

@menu
* nanoMIPS Controls:: Directives to control assembler behaviour & state
* nanoMIPS ISA:: Directives to override the ISA
* nanoMIPS CodeGen Concepts:: Directives to control memory model and addressing
* nanoMIPS CodeGen Specifics:: Directives to control code generation
* nanoMIPS DataGen:: Directives for data sections
* nanoMIPS Floating-Point:: Directives to override floating-point options
* nanoMIPS ASE Overrides:: Directives for generation of ASE instructions
* nanoMIPS Compatibility:: Directives for compatibility with MIPS assembly
@end menu


@node nanoMIPS Controls
@subsection Directives to control assembler behaviour & state
@table @code
@item @code{.set}

@cindex nanoMIPS option control
The @code{.set} directive allows changing various options that control
behaviour at any point within an assembly file.  The syntax is identical
to the @code{.set} directive used to assign values to symbols.  The
nanoMIPS assembler supports a number of built-in special symbols, which
when set to certain values change the behaviour of the assembler from
that point onwards.  The change in the behaviour remains in effect till
the next @code{.set} directive which affects that particular behaviour.

@item @code{.module}

@cindex nanoMIPS module control
@kindex @code{.module}
The @code{.module} directive allows command line options to be set directly
from assembly.  The format of the directive matches the @code{.set}
directive but only those options which are relevant to a whole module are
supported.  The effect of a @code{.module} directive is the same as the
corresponding command line option.  Where @code{.set} directives support
returning to a default then the @code{.module} directives do not as they
define the defaults.

Module-level directives must appear first in assembly, before any
instructions.

@item @code{.set push}
@itemx @code{.set pop}

@cindex nanoMIPS option stack
@kindex @code{.set push}
@kindex @code{.set pop}
The directives @code{.set push} and @code{.set pop} may be used to save
and restore the current settings for all the options which are
controlled by @code{.set}.  The @code{.set push} directive saves the
current settings on what can be considered a virtual assembler settings
``stack''.  The @code{.set pop} directive pops the ``stack'' and restores
the assembler state to what it was before the most recent @code{.set push}.

These directives can be useful inside an macro which must change an
option but does not want to change the state of the code which invoked
the macro.
@end table

@node nanoMIPS ISA
@subsection Directives to override the ISA
@table @code
@cindex nanoMIPS CPU override
@item .set arch=@var{isa}
@kindex .set arch=@var{isa}
@itemx .set arch=@var{cpu}
@item .module arch=@var{isa}
@kindex .module arch=@var{isa}
@itemx .module arch=@var{cpu}
The @code{.set arch=@var{isa}} directive changes the effective CPU
target and allows the assembler to use instructions specific to a
particular ISA or CPU.  All ISA and CPUs supported by the
@samp{-march} command line option are also selectable by this
directive.  The original value is restored by @code{.set
arch=default}.

Valid @var{isa} value are:
@quotation
32r6,
32r6s,
64r6
@end quotation

Valid @var{cpu} value are:
@quotation
i7200,
nms1
@end quotation
@end table

@node nanoMIPS CodeGen Concepts
@subsection Directives to control memory model and addressing
These directives indirectly control how built-in macros are expanded.
Some of them also set or clear corresponding flags in the ELF header.

@table @code
@item .set mcmodel=auto
@itemx .set mcmodel=medium
@itemx .set mcmodel=large
@itemx .module mcmodel=auto
@itemx .module mcmodel=medium
@itemx .module mcmodel=large
@cindex Control code/data memory models
@kindex .set mcmodel=auto
@kindex .set mcmodel=medium
@kindex .set mcmodel=large
These directives specify the memory model that the assembler uses for
generating macro expansions.  The directive @code{.set mcmodel=auto}
defers most decisions about the range of the code/data layout to
link-time relaxation.  It requires linker relaxation to be enabled and
a capable linker.  The directive @code{.set mcmodel=medium} assumes
that the GP-relative region (which includes the GOT in PIC) must not
exceed 2MiB and the total code size for a final link must not exceed
32MiB.  The directive @code{.set mcmodel=large} implies no limits.
@c FIXME: not true for 64-bits, perhaps specify a 2GB limit.

@item .set pic[012]
@itemx .module pic[012]
@kindex .set pic0
@kindex .set pic1
@kindex .set pic2
@kindex .module pic0
@kindex .module pic1
@kindex .module pic2
The @code{.set pic1} directive enables position independent code(PIC)
generation for built-in macros, using the medium memory model.  The
@code{.set pic2} directive enables PIC generation, using the large
memory model.  The @code{.set pic0} directive disables PIC generation.
If PIC is enabled, the corresponding flag in the ELF header is also set.
Position independent code generation is disabled by default.

@item .set pid
@itemx .set nopid
@itemx .module pid
@itemx .module nopid
@kindex .set pid
@kindex .set nopid
@kindex .module pid
@kindex .module nopid
The @code{.set pid} directive enables the position independent
expansion of data addresses for built-in macros.  It also sets the PID
flag in the ELF header.  The @code{.set nopid} directive disables such
expansions.

An object with the PID flag is guaranteed to not contain any absolute
or PC-relative references to data.  All data references are through the
$gp register.  Data sections can be re-positioned independent of code
sections by changing the value of @var{_gp}.  This is disabled by
default.

@item .set pcrel
@itemx .set nopcrel
@itemx .module pcrel
@itemx .module nopcrel
@kindex .set pcrel
@kindex .set nopcrel
@kindex .module pcrel
@kindex .module nopcrel
The @code{.set pcrel} directive enables the PC-relative expansion of
address calculation for built-in macros.  It also sets the PC-relative
flag in the ELF header.  The @code{.set pcrel} directive disables
PC-relative expansions.  An object with the PC-relative flag is
guaranteed to not contain any absolute address calculation.  This
is disabled by default.

@item .linkrelax
@kindex .linkrelax
The @code{.linkrelax} directive enable linker relaxations for an
assembly unit.  It also sets the LINKRELAX flag in the ELF header.
Linker relaxation is disabled by default.
@end table


@node nanoMIPS CodeGen Specifics
@subsection Directives to control code generation
@table @code

@item .set insn32
@itemx .set noinsn32
@cindex nanoMIPS 32-bit instruction generation override
@kindex @code{.set insn32}
@kindex @code{.set noinsn32}
The directive @code{.set insn32} makes the assembler use only 32-bit
instruction encodings when generating code for the nanoMIPS processor.
This directive inhibits the use of any 16-bit or 48-bit instructions
from that point on in the assembly.  The @code{.set noinsn32} directive
allows 16-bit and 48-bit instructions to be accepted.

@item .set reorder
@itemx .set noreorder
@cindex Compatibility with MIPS instruction re-ordering
@kindex @code{.set reorder}
@kindex @code{.set noreorder}
The traditional MIPS assembler uses re-ordering of instructions to fill
delay slots in delayed branch instructions.  If reordering is enabled,
the assembler can move an instruction above a delayed branch
instructions in to the delay slot of the instruction.  If it is disabled,
the assembler must insert a nop instruction in the delay slot, to
satisfy pipeline constraints.  Where the assembler is not free to adjust
the user-specified order of instructions, a NOP is inserted in the
delay slot instead.

The nanoMIPS architecture does not have delayed instructions.  The branch
instructions are termed as compact (as opposed to delayed) branch
instructions.  The assembler does provide aliases from delayed to compact
branch mnemonics for portability, however it cannot simply gloss over
semantic differences between the two.  The nanoMIPS assembler will
attempt to convert a delayed branch to a compact branch.  With
re-ordering enabled, this is simply interpreting one instruction
mnemonic (bal) as another (balc).  With reordering disabled, the
conversion is only possible if the instruction in the delay slot is a
NOP instruction, since the NOP can be trivially dropped without changing
the effect of an assembly fragment.


The following table compares the behaviour of MIPS and nanoMIPS for
commonly encountered input patterns:

@multitable @columnfractions 0.2 0.2 0.2 0.2 0.2
@headitem
Input assembly
@tab
Generated MIPS object
@tab
Remarks
@tab
Generated nanoMIPS object
@tab
Remarks
@item
@item
@smallformat
@verbatim
.set reorder
move $a0,$s0
bal $ra,foo
@end verbatim
@end smallformat
@tab
@smallformat
@verbatim
bal $ra,foo
move $a0,$s0
@end verbatim
@end smallformat
@tab
Instructions re-ordered to fill delay slot.  Move happens before control
transfer due to delayed branch semantics.
@tab
@smallformat
@verbatim
move $a0,$s0
balc $ra,foo
@end verbatim
@end smallformat
@tab
Delayed branch converted to compact branch.
@item
@smallformat
@verbatim
.set reorder
move $a0,$s0
beq $a0,$a1,foo
@end verbatim
@end smallformat
@tab
@smallformat
@verbatim
move $a0,$s0
beq $a0,$a1,foo
nop
@end verbatim
@end smallformat
@tab
Re-ordering inhibited by dependency.  NOP inserted automatically to fill
delay slot.
@tab
@smallformat
@verbatim
move $a0,$s0
beqc $a0,$a1,foo
@end verbatim
@end smallformat
@tab
Delayed branch converted to compact branch.
@item
@smallformat
@verbatim
.set noreorder
move $a0,$s0
bal $ra, foo
nop
@end verbatim
@end smallformat
@tab
@smallformat
@verbatim
move $a0,$s0
bal $ra, foo
nop
@end verbatim
@end smallformat
@tab
Explicit NOP in delay slot
@tab
@smallformat
@verbatim
move $a0,$s0
balc $ra,foo
@end verbatim
@end smallformat
@tab
Delayed branch converted to compact branch,  NOP removed.
@item
@smallformat
@verbatim
.set noreorder
bal $ra, foo
move $a0,$s0
@end verbatim
@end smallformat
@tab
@smallformat
@verbatim
bal $ra, foo
move $a0,$s0
@end verbatim
@end smallformat
@tab
Explicit instruction in delay slot.
@tab
-
@tab
Signal error.  Cannot convert to compact branch.
@item
@smallformat
@verbatim
.set noreorder
move $a0,$s0
bal $ra, foo
@end verbatim
@end smallformat
@tab
@smallformat
@verbatim
move $a0,$s0
bal $ra, foo
<xx>
@end verbatim
@end smallformat
@tab
Unpredictable or illegal instruction in delay slot
@tab
@smallformat
@verbatim
move $a0,$s0
balc $ra,foo
@end verbatim
@end smallformat
@tab
Delayed branch converted to compact branch,  NOP removed.
@end multitable

Finding a useful operations to perform in delay slots is important to
get the best performance from the execution pipeline on MIPS
architecture.  Traditionally, MIPS assembly programmers have preferred to
control the utilization of delay slots directly, rather than rely on the
assembler.  A lot of handwritten MIPS assembly follows the pattern in row
4 above.  Here reordering is disabled and the instruction in the delay
slot is not a NOP.  The nanoMIPS assembler will fail to convert the
delayed branch to a compact branch and will signal an error.

Reversing the order of the branch and the subsequent instruction is
sufficient for the nanoMIPS assembler, as in row 5 above.  However the
output will behave unpredictably when assembled for MIPS, because
whatever instruction or data happens to be in the delay slot position in
the output will get executed before the branch.  The safest and most
reliable alternative is row 1.  It delegates maximum control to the
assembler and generates the most efficient code for both MIPS and
nanoMIPS.  Note that re-ordering is enabled by default on both MIPS and
nanoMIPS.  If it is not disabled any where preceding a branch fragment,
it need not be explicitly re-enabled for each branch.


@item @code{.set linkrelax}
@itemx @code{.set nolinkrelax}
@cindex Directives to control linker relaxation over a region
@kindex @code{.set linkrelax}
@kindex @code{.set nolinkrelax}
The directive @code{.set linkrelax} emits a place-holder to indicate
that linker relaxations are enabled in the following region.  When
relaxation is enabled, the assembler will emit additional relocations
to direct the linker.  The @code{.set nolinkrelax} directive emits
a place-holder to indicate that linker relaxations are disabled in the
following region.

@item @code{.set legacyregs}
@itemx @code{.set nolegacyregs}
@cindex nanoMIPS legacy register names
@kindex @code{.set legacyregs}
@kindex @code{.set nolegacyregs}
The directive @code{.set legacyregs} allows the use of MIPS-compatible
numeric register formats.  The names and usage conventions of general
purpose registers for the nanoMIPS ABI is different from the MIPS
ABI.  The nanoMIPS assembler rejects numeric formats by default, to
force the user to re-think register usage when porting MIPS code.  The
@code{.set nolegacyregs} directive disables these register
identifiers.

@item @code{.set macro}
@itemx @code{.set nomacro}
@kindex @code{.set macro}
@kindex @code{.set nomacro}
Some times it is undesirable to have one assembly instruction expand
to several machine instructions.  The directive @code{.set nomacro}
tells the assembler to prohibit such expansions.  @code{.set macro}
restores the default behavior.  Note that this behaviour is a departure
from the MIPS assembler which only warns about generation of macros
after @code{.set nomacro}.

@item @code{.set at=@var{reg}}
@cindex @code{at} register, nanoMIPS
@kindex @code{.set at=@var{reg}}
Some macro instructions need a temporary register to store intermediate
results.  This register is usually @code{$r1}, also known as @code{$at},
but it can be changed to any core register @var{reg} using
@code{.set at=@var{reg}}.  Note that @code{$at} always refers
to @code{$r1} regardless of which register is being used as the
temporary register.

@item @code{.set at}
@itemx @code{.set noat}
@kindex @code{.set at}
@kindex @code{.set noat}
Implicit uses of the temporary register in macros could interfere with
explicit uses in the assembly code.  The assembler therefore warns
whenever it sees an explicit use of the temporary register.  The directive
@code{.set noat} silences this warning while @code{.set at} restores
the default behavior.  It is safe to use @code{.set noat} while
@code{.set nomacro} is in effect since single-instruction macros
never need a temporary register.

@item .cpsetup
@cindex nanoMIPS GP-setup
@kindex @code{cpsetup}

This directive maps to the GP-setup sequence for position independent
code.

@example
lapc.b $gp, _gp
@end example

@end table

@node nanoMIPS DataGen
@subsection Directives for data sections
@table @code

@item @code{.bss}
@cindex Zero-initialized data
@kindex @code{.bss}
The @code{.bss} directive starts the declaration of a zero-initialized
data section.  This can also be achieved using the @code{.section}
directive.  It is provided for compatibility with MIPS.

@item @code{.sbss}
@cindex Zero-initialized data
@kindex @code{.sbss}
The @code{.sbss} directive starts the declaration of a zero-initialized
small data section.  This can also be achieved using the @code{.section}
directive.  It is provided for compatibility with MIPS.

@item @code{.rdata}
@cindex Read-only data
@kindex @code{.rdata}
The @code{.rdata} directive starts the declaration of a read-only data
section.  This can also be achieved using the @code{.section}
directive.  It is provided for compatibility with MIPS.

@item @code{.sdata}
@cindex Small data
@kindex @code{.sdata}
The @code{.sdata} directive starts the declaration of an initialized
small data section.  This can also be achieved using the @code{.section}
directive.  It is provided for compatibility with MIPS.

@item @code{.sbyte}
@cindex Signed byte expressions
@kindex @code{.sbyte}
@code{.sbyte} expects zero or more expressions, separated by commas.
Each expression is assembled into the next byte, similar to @code{.byte}
psuedo-op.  The GNU assembler interprets all expressions are unsigned by
default.  If the expression for @code{.sbyte} consists of a
label-difference, the assembler will emit necessary relocation to
interpreted the result as a signed 8-bit value.

@item @code{.shword}
@cindex Signed half-word expressions
@kindex @code{.shword}
@code{.shword} expects zero or more expressions, separated by commas.
Each expression is assembled into the next half-word, similar to
@code{.hword} psuedo-op.  If the expression consists of a
label-difference, the assembler will emit necessary relocation to
interpreted the result as a signed 16-bit value.

@item @code{.ehword}
@cindex Exception handler address
@kindex @code{.ehword} expects a symbol.  sThe directive allocates a
word-sized memory region and emits a PC-relative relocation to
calculate the address of that symbol.
@end table

@node nanoMIPS Floating-Point
@subsection Directives to override floating-point options

@table @code
@item .gnu_attribute 4,[0123]
The directives @code{.gnu_attribute 4,} selects one of the supported
FP ABIs.  @xref{Supported FP ABIs}.

@item .set softfloat
@itemx .set hardfloat
@itemx .module softfloat
@itemx .module hardfloat
@kindex @code{.set softfloat}
@kindex @code{.set hardfloat}
@kindex @code{.module softfloat}
@kindex @code{.module hardfloat}
The directives @code{.set softfloat} and @code{.set hardfloat} provide
finer control of disabling and enabling float-point instructions.
These directives always override the default (that hard-float
instructions are accepted) or the command-line options
(@samp{-msoft-float} and @samp{-mhard-float}).

@item .set singlefloat
@itemx .set doublefloat
@itemx .module singlefloat
@itemx .module doublefloat
@kindex @code{.set singlefloat}
@kindex @code{.set doublefloat}
@kindex @code{.module singlefloat}
@kindex @code{.module doublefloat}
The directives @code{.set singlefloat} and @code{.set doublefloat}
provide finer control of disabling and enabling double-precision
float-point operations.  These directives always override the default
(that double-precision operations are accepted) or the command-line
options (@samp{-msingle-float} and @samp{-mdouble-float}).

@end table

@anchor{Supported FP ABIs} @subsubsection Supported FP ABIs
The supported floating-point ABI variants are:

@table @code
@item 0 - No floating-point
This variant is used to indicate that floating-point is not used within
the module at all and therefore has no impact on the ABI.  This is the
default.

@item 1 - Double-precision
This variant indicates that double-precision support is used.  This means
that 64-bit wide floating-point registers are required.

@item 2 - Single-precision
This variant indicates that single-precision support is used.  Double
precision operations will be supported via soft-float routines.

@item 3 - Soft-float
This variant indicates that although floating-point support is used all
operations are emulated in software.  This means the ABI is modified to
pass all floating-point data in general-purpose registers.

@end table

@node nanoMIPS ASE Overrides
@subsection Directives for generation of ASE instructions

@table @code

@item .set crc
@itemx .set nocrc
@itemx .module crc
@itemx .module nocrc
@cindex nanoMIPS CRC instruction generation override
@kindex @code{.set crc}
@kindex @code{.set nocrc}
@kindex @code{.module crc}
@kindex @code{.module nocrc}
The directive @code{.set crc} makes the assembler accept instructions
from the Cyclic Redundancy Check Application Specific Extension from that
point on in the assembly.  The @code{.set nocrc} directive prevents
CRC instructions from being accepted.

@item .set dspr3
@itemx .set nodspr3
@itemx .module dspr3
@itemx .module nodspr3
@cindex nanoMIPS DSP Release 3 instruction generation override
@kindex @code{.set dspr3}
@kindex @code{.set nodspr3}
@kindex @code{.module dspr3}
@kindex @code{.module nodspr3}
The directive @code{.set dspr3} makes the assembler accept instructions
from the DSP Release 3 Application Specific Extension from that point
on in the assembly.  This directive implies @code{.set dsp}.  The
@code{.set nodspr3} directive prevents DSP Release 3 instructions from
being accepted.

@item .set dsp
@itemx .set nodsp
@itemx .module dsp
@itemx .module nodsp
@kindex @code{.set dsp}
@kindex @code{.set nodsp}
@kindex @code{.module dsp}
@kindex @code{.module nodsp}
The only DSP ASE supported by nanoMIPS is Release 3.  The directive
@code{.set dsp} is equivalent to @code{.set dspr3}.

@item .set eva
@itemx .set noeva
@itemx .module eva
@itemx .module noeva
@cindex nanoMIPS Enhanced Virtual Address (EVA) instruction generation override
@kindex @code{.set eva}
@kindex @code{.set noeva}
@kindex @code{.module eva}
@kindex @code{.module noeva}
The directive @code{.set eva} makes the assembler accept instructions
from the Enhanded Virtual Addressing extension from that point on in the
assembly.  The @code{.set noeva} directive prevents EVA instructions
from being accepted.

@item .set ginv
@itemx .set noginv
@itemx .module ginv
@itemx .module noginv
@cindex nanoMIPS GINV instruction generation override
@kindex @code{.set ginv}
@kindex @code{.set noginv}
@kindex @code{.module ginv}
@kindex @code{.module noginv}
The directive @code{.set ginv} makes the assembler accept instructions
from the Global cache INValidate Application Specific Extension from that
point on in the assembly.  The @code{.set noginv} directive prevents
GINV instructions from being accepted.

@item .set mcu
@itemx .set nomcu
@itemx .module mcu
@itemx .module nomcu
@cindex nanoMIPS MCU instruction generation override
@kindex @code{.set mcu}
@kindex @code{.set nomcu}
@kindex @code{.module mcu}
@kindex @code{.module nomcu}
The directive @code{.set mcu} makes the assembler accept instructions
from the MCU Application Specific Extension from that point on
in the assembly.  The @code{.set nomcu} directive prevents MCU
instructions from being accepted.

@item .set mt
@itemx .set nomt
@itemx .module mt
@itemx .module nomt
@cindex nanoMIPS MT instruction generation override
@kindex @code{.set mt}
@kindex @code{.set nomt}
@kindex @code{.module mt}
@kindex @code{.module nomt}
The directive @code{.set mt} makes the assembler accept instructions
from the Multi Threading Application Specific Extension from that point
on in the assembly.  The @code{.set nomt} directive prevents MT
instructions from being accepted.

@item .set tlb
@itemx .set notlb
@itemx .module tlb
@itemx .module notlb
@cindex TLB control instruction generation override
@kindex @code{.set tlb}
@kindex @code{.set notlb}
@kindex @code{.module tlb}
@kindex @code{.module notlb}
The directive @code{.set tlb} makes the assembler accept instructions
from the Translation Lookaside Buffer control Extension from that point
on in the assembly.  The @code{.set notlb} directive prevents TLB
control instructions from being accepted.

@item .set virt
@itemx .set novirt
@itemx .module virt
@itemx .module novirt
@cindex Virtualization instruction generation override
@kindex @code{.set virt}
@kindex @code{.set novirt}
@kindex @code{.module virt}
@kindex @code{.module novirt}
The directive @code{.set virt} makes the assembler accept instructions
from the Virtualization Application Specific Extension from that point
on in the assembly.  The @code{.set novirt} directive prevents Virtualization
instructions from being accepted.

@end table

@node nanoMIPS Compatibility
@subsection Directives for compatibility with MIPS assembly

These assembler directives are accepted without any verification or
effect, for compatibility with MIPS.
@table @code
@item .cpadd
@item .cpload
@item .cplocal
@item .crestore
@item .cpreturn
@item .set nomips16
@item .set noMIPS-16
@item .set nomicromips
@item .set move
@item @code{.set nomove}
@item .set volatile
@item .set novolatile
@item .set nobopt
@item .set noforbidden-slots
@item .set oddspreg
@end table


@node nanoMIPS Reloc Operators
@section Explicit Relocation Operators
@table @code
@item %lo

Unsigned 12-bit low-part of 32-bit value.
@example
%lo(@var{X}) = @var{X} & 0xfff
@end example
@item %hi

Signed 20-bit high-part of 32-bit value.
@example
%hi(@var{X}) = @var{X} & 0xfffff000
@end example
@item %gprel

GP-relative displacement, size depends on type of operation and data layout.
@item %gprel_hi
Signed 20-bit high part of a GP-relative displacement.
@item %gprel_lo
Unsigned 12-bit low part of a GP-relative displacement.
@item %got_disp
19-bit (scaled) GOT displacement for address calculation or data access.
@item %got_call
19-bit (scaled) GOT displacement to load address for a function call.
@item %got_pcrel_hi
Signed 20-bit high part of GOT displacement from next PC.
@item %got_pcrel_lo
Unsigned 12-bit low part of GOT displacement.
@item %got_pcrel32
Full 32-bit signed GOT displacement from next PC.
@item %got_page
Marks the first level of indirection for GOT-relative data access
(either a load or a store).  This is relaxed out by the linker.
@item %got_ofst
Marks the second level of indirection for GOT-relative data access
(either a load or a store).
@item %pcrel_hi
Signed 20-bit high part of PC-relative displacement.
@item %pcrel_lo
Unsigned 12-bit low part of PC-relative displacement.  Map to @code{%lo}.

@item %tlsgd
GP-relative displacement to global dynamic TLS slot, size depends on
type of operation.

@item %tlsld

GP-relative displacement to local dynamic TLS slot, size depends on type
of operation.

@item %dtprel

Unsigned offset to a thread-local dynamic variable from current thread
pointer, size depends on type of operation.

@item %tprel

Unsigned offset to a thread-local static variable from current thread
pointer, size depends on type of operation.

@item %gottprel

19-bit (scaled) GOT displacement to a TLS slot.

@item %gottprel_pc32

Full 32-bit signed GOT displacement to a TLS slot from next PC.

@item %gp_rel

Provided for compatibility with MIPS.  Map to @code{%gprel}.

@item %call16

Provided for compatibility with MIPS.  Map to @code{%got_call}.

@item %got

Provided for compatibility with MIPS.  Map to @code{%got_disp}.
@end table

@include c-nanomips-macros.texi

@include c-nanomips-aliases.texi

@node nanoMIPS Small Data
@section Small Data Access

@cindex small data, nanoMIPS
@cindex @code{gp} register, nanoMIPS
It often takes multiple instructions to load data from a symbol.
For example, when @samp{addr} is a 32-bit symbol, the non-PIC expansion
of @samp{lw $a0,addr} is usually:

@example
lui     $a0,%hi(addr)
lw      $a0,%lo(addr)($a0)
@end example

The sequence is longer when @samp{addr} is a 64-bit symbol.

In order to cut down on this overhead, nanoMIPS architecture allows the
programmer to set aside a 2 megabyte ``small data'' area and guarantees
that all data of size @var{n} and smaller will be placed in that area.
The limit @var{n} is passed to both the assembler and the linker using
the command-line option @option{-G @var{n}}, @pxref{nanoMIPS Options,,
Assembler options}.  Note that the same value of @var{n} must be used
when linking and when assembling all input files to the link; any
inconsistency could cause a relocation overflow error.

The size of an object in the @code{.bss} section is set by the
@code{.comm} or @code{.lcomm} directive that defines it.  The size of
an external object may be set with the @code{.extern} directive.  For
example, @samp{.extern sym,4} declares that the object at @code{sym}
is 4 bytes in length, while leaving @code{sym} otherwise undefined.

When no @option{-G} option is given, the default limit is 8 bytes.
The option @option{-G 0} prevents any data from being automatically
classified as small.

It is also possible to mark specific objects as small by putting them in
the special sections @code{.sdata}, @code{.ssdata}, @code{.sbss} and
@code{.ssbss}, which are ``small'' counterparts of @code{.data} and
@code{.bss} respectively for different types of data.  The toolchain
will treat such data as small regardless of the @option{-G} setting.

On startup, systems that support a small data area are expected to
initialize register @code{$r28}, also known as @code{$gp}, in such a
way that small data can be accessed using a 21-bit offset from that
register for word/double-word types. The offset restriction is 18-bits
in the case of sub-word and floating point types.  For example, when
@samp{addr} is small data, the @samp{lw $a0,addr} instruction above is
equivalent to:

@example
lw  $a0,%gprel(addr)($gp)
@end example

Small data is also supported for SVR4-style PIC.

@node nanoMIPS Relocations
@section Using relocation operators for different addressing modes

@menu
* Optimized GP-relative access::
* General GP-relative access::
* 32-bit absolute addressing and immediate construction::
* PC-relative addressing::
* Indirect addressing for small PIC model::
* Indirect addressing for large PIC model::
@end menu

@node Optimized GP-relative access
@subsection Optimized GP-relative access

The nanoMIPS architecture allows various fundamental data types, up to
16 bytes in size, to be accessed directly relative to the designated
Global Pointer ($gp) register.  GP-relative access allows for data
load/store and address calculations to be performed in a single 16 or
32-bit instruction, using an offset from the $gp register.  The range
of the offset and hence the size of the reachable GP-relative region,
also called the small data region, varies with the type, size and
alignment of the data object being accessed.  These limits form the
basis of the medium memory model.


@multitable @columnfractions .4 .6
@headitem Data type @tab GP-relative offset range
@item aligned word	@tab 19-bit scaled ( 2MiB)
@item aligned dword	@tab 18-bit scaled (2MiB)
@item aligned half-word	@tab 17-bit scaled (512KiB)
@item aligned float	@tab 16-bit scaled (512KiB)
@item [word] aligned double	@tab 16-bit scaled (512KiB)
@item unaligned word	@tab 18-bit (512KiB)
@item unaligned dword	@tab 18-bit (512KiB)
@item unaligned half-word	@tab 18-bit (512KiB)
@item byte	@tab 18-bit (512KiB)
@end multitable

The object file contains relocations which the linker attempts to
resolve when doing the data layout.  Even with the medium memory model,
there is no guarantee that all GP-relative accesses will be
optimized.  If the linker can not find a data layout that allows all
GP-relative accesses to be optimized, it will either

@itemize
@item
Expand some accesses to use multiple instructions: this indicates that
although the total amount of small data is less than 2MB, the offset
range requirements for all types/alignment cannot be satisfied.  The
linker can rewrite some accesses to use multiple
instructions.  However, if expansion is inhibited or not implemented,
the link will fail.
@item
Fail to link: this indicates that the total amount of small data is
greater than 2MB.  The solution is to recompile using either the
large or the automatic memory model.
@end itemize

Thus, the linker has final control of whether optimized GP-relative
access is viable.  Assembler directives can be used to disallow
expansions at either module-level or per-access.
@xref{nanoMIPS Transformations, ,Controlling Linker Relaxation}.
Assembly language syntax for requesting GP-relative access consists
of 2 elements:
@subsubsection Explicitly requested GP-relative access

The user can explicitly request GP-relative access with the %gprel
relocation operator.  This operator can only be used for load/store
instructions with $gp as the base register or address calculation with
$gp as a source operand.  The assembler will match the operation and
select the an appropriate relocation for each access.  Examples:
@example
    lw $a0, %gprel(foo)($gp)
    l.s $f0, %gprel(bar)($gp)
    addiu $a0, $gp, %gprel(foo)
@end example

By itself, this does not guarantee that foo will end up within the
small data region.  If the layout is such that it happens to be within
range, the link will succeed.  Otherwise the linker may fail or expand
the operation to multiple instructions, as explained above.
@subsubsection Implicit GP-relative access through canonical named sections

Small data sections are typically named `.sbss'/`.ssbss'
(zero-initialized) or `.sdata'/`.ssdata'.  The linker places these
sections close to $gp and complains if they are outside the GP-relative
range.  If access to an object within a small data sections is made by
assembler macros, where the addressing mode is unspecified, the
assembler will choose a GP-relative expansion.

@example
    lw $a0, foo
    @expansion{} lw $a0, %gprel(foo) ($gp)

    la $a0, bar
    @expansion{} addiu $a0, $gp, %gprel(foo)
@end example
Declaration of data in small data sections can be achieved by naming
sections using the @code{.section} directive or by
@code{comm/lcomm/extern} declarations, provided the declared size of the
object is less than the small data limit specified by @code{-Gnum}.

Compiler generated code uses a combination of data declaration in named
small data sections and explicitly requested GP-relative access in
instructions in order to guarantee GP-relative access.

@node General GP-relative access
@subsection General GP-relative access

If optimized access is not an objective, the full 32-bit address space
is reachable by GP-relative addressing.  This corresponds to the large
memory model.  For address calculation with full nanoMIPS ISA, use the
48-bit instruction

@example
    addiu.b32 $a0, %gprel(foo), $gp
@end example

With only 32-bit instructions or when restricted to the nanoMIPS
subset, use the following sequence:

@example
    lui $a0, %gprel_hi (foo)
    ori $a0, $a0, %gprel_lo(foo)
    addu $a0, $a0, $gp
@end example

For loads/stores use the following sequence:

@example
    lui $a0, %gprel_hi (foo)
    addu $a0, $a0, $gp
    lw $a0, %gprel_lo(foo) ($a0)
@end example

With a linker capable of doing expansions, the preferred approach is
to use the automatic memory model with optimized GP-relative
sequences.  The linker will convert select accesses to non-optimized
sequences where necessary.


@node 32-bit absolute addressing and immediate construction
@subsection 32-bit absolute addressing and immediate construction

The nanoMIPS assembler provides macros which automatically find the
best way to materialize an address of immediate value in a
register.  The macros are called li and la for constants and addresses
respectively.  This section demonstrates explicit coding methods for
predictable code size and addressing modes.

Address calculation for full nanoMIPS ISA with 48-bit instructions can
trivially be done with

@example
    li $a0, foo
@end example

With only 32-bit instructions or when restricted to the nanoMIPS
subset, use the following combination:

@example
    lui $a0, %hi(foo)
    ori $a0, %lo(foo)
@end example

Immediate construction for full nanoMIPS ISA can be trivially done with:

@example
    li $a0, @var{imm}
@end example

Here, depending on the immediate value, the assembler will pick a
16-bit, 32-bit or 48-bit instruction.

For immediate construction using only 32-bit instructions, or when
restricted to the nanoMIPS subset, the preferred option is:

@example
    lui $a0, %hi(@var{imm})
    ori $a0, %lo(@var{imm})
@end example

This sequence breaks the immediate value in to a 20-bit high part and
a 12-bit unsigned low part.  However, the traditional (16-bit high +
16-bit signed-low) form, typical to MIPS, is also supported:

@example
    lui $a0, @code{imm_hi16}
    addiu $a0,  @code{imm_lo16}
@end example

Here,
@display
@code{imm_lo16} = (short) @code{imm} and @code{imm_hi16} = ((@code{imm} - @code{imm_lo16}) >> 16)
@end display
These interpretations borrow from the definition of %hi & %lo on
MIPS, so that MIPS code can continue to work correctly on
nanoMIPS.  Note the use of ADDIU instruction for the signed low-part.

@node PC-relative addressing
@subsection PC-relative addressing

Address calculation within a +-1MB region of current PC can be done
with a single 32-bit instruction:

@example
    lapc.h $a0, foo
@end example

For full nanoMIPS ISA, the example below selects a 48-bit instruction
which can reach any address within 32-bits (+-2GB) of the PC.

@example
    lapc.b $a0, foo
@end example

For address calculation using only 32-bit instructions, or when
restricted to the nanoMIPS subset, use:

@example
    aluipc $a0, %pcrel_hi (foo)
    ori $a0, $a0, %lo(foo)
@end example

The ALUIPC instruction generates a 4k-aligned address, unlike
MIPS.  This can be considered as the address of the 4k page that
contains the address foo.  The subsequent ORI introduces the offset
within that 4k page and is not really PC-relative.  The user can insert
any number of instructions between the high & low part calculations
above, without having to adjust the addend for the low part.  Owing to
these differences, the typical MIPS PC-relative address calculation
fragment below will NOT work correctly on nanoMIPS:

@example
    aluipc $a0, %pcrel_hi (foo) ; not 4k-aligned
    ori $a0, $a0, %pcrel_lo(foo+4) ; addend reflects difference in
                                   ; PC of high and low steps
@end example

PC-relative address calculation typically needs more power than the
corresponding absolute address calculation.  The latter should be
preferred for low-power applications, whenever possible.

@node Indirect addressing for small PIC model
@subsection Indirect addressing for small PIC model (-fpic)

The linker places the GOT section in the small data area.  GOT entries
can be directly accessed as:

@example
    lw $a0, %got_disp (foo) ($gp)
@end example

This mechanism is agnostic to symbol visibility or preemption.  A
capable linker will relax or expand the sequence to optimized the
access.  The linker may also place small data directly in the
GP-relative region, so even when the GOT section is less than 2MiB, it
may be too big to satisfy medium memory model constraints.

@node Indirect addressing for large PIC model
@subsection Indirect addressing for large PIC model (-fPIC)

When the GOT spills out of the GP-relative range, 32-bit displacements
are required.  Calculating displacements relative to the PC instead of
GP is preferred, since it gives shorter load sequences.  For the full
nanoMIPS ISA, this can be done with a single 48-bit instruction:

@example
    lwpc $a0, %got_pcrel32 (foo)
@end example

For address calculation using only 32-bit instructions, or when
restricted to the nanoMIPS subset, use:

@example
    aluipc $a0, %got_pcrel_hi (foo)
    lw $a0, %got_lo (foo) ($a0)
@end example

As with GP-relative access, the preferred approach is to use small PIC
sequences and let the linker convert select accesses to large PIC
sequences where necessary.


@node nanoMIPS Instruction Selection
@section Controlling Instruction Selection

@subsection Syntax for instruction selection

The nanoMIPS ISA can use the same primary mnemonic to denote multiple
target instructions.  This happens when the ISA has encodings of an
instruction with different instruction sizes, or of same instruction
size but with different operand types.  The assembler syntax allows 2
ways for the user to specify the target instruction for such a
mnemonic:

@enumerate
@item
Size-suffixes (16/32/48) can be used to force the instruction size.  If
there is no instruction of the specified size of if the operands do
not match for that size, the instruction will be rejected.  It is
guaranteed that neither the assembler nor the linker will expand an
explicitly sized instruction in to multiple instructions.  The linker
may still translate this instruction to another, more efficient
instruction of the same size.

@example
    balc16 foo     # 16-bit call, fails if foo is outside
                   # 11-bit signed range
    li32 $a0, 100  # force 32-bit instruction even though
                   # 16-bit encoding is possible
    addiu48 $a0, $a1, 1000  # force 48-bit instruction even
                      # though 32-bit encoding is possible
@end example

By default, the assembler will always select the smallest sized
instruction for the given operands.  Size suffixes are useful when
constructing branch tables, to ensure that all blocks within the table
have the same size.

@item
Format suffixes from the architecture reference manual can also be
used to select a specific encoding.  Suffixes are enclosed in square
brackets, matching the convention used in the architecture
reference.  If the operands do not match the format suffix, the
instruction will be rejected.  It is guaranteed that neither the
assembler nor the linker will expand an explicitly selected
instruction in to multiple instructions or translate it in to any
other instruction.

@example
    addiu[gp.w] $a0, $gp, %gprel(foo) # word-aligned GP-relative
                                      # address calculation
    lw[s9] $a0, 128($a1)  # load word with signed 9-bit offset even
                          # when unsigned 12-bit is possible
    addu[4x4] $s2, $s3, $s2  # select  4-bit register encoding
@end example

The ability to specify format suffixes serves little practical
purpose, since the tools will try to find the most efficient encoding
for an operation.  It is provided as an aid for development and
testing.  For example, the @code{[4x4]} suffix in the case above forces the
assembler to check whether the operands satisfy the requested
encoding.
@end enumerate

@subsection Syntax for relaxable instruction selection

Both of the above methods for instruction selection have the side-effect
of restricting linker relaxation in some way.  For variants of addiu[gp]
and lapc, the assembler provides additional 1:1 aliases which select a
variant, while still allowing the linker to relax it without any
restrictions.

@example
    addiu.w $a0, $gp, %gprel(foo)  # alias to addiu[gp.w]
    addiu.b $a0, $gp, %gprel(foo)  # alias to addiu[gp.b]
    addiu.b32 $a0, $gp, %gprel(foo)  # alias to addiu[gp48]
    lapc.h $a0, foo  # alias to lapc[32]
    lapc.b $a0, foo  # alias to lapc[48]
@end example

All of the above forms can be relaxed by the linker, either by replacing
one instruction with another of a different size, or by replacing one
instruction with a sequence of instructions, as necessary.

@subsection Options to control instruction disassembly

The assembler provides multiple instruction formats and mnemonics to
target the same instruction encoding by means of 1:1 aliases.  There
are 2 disassembler options that control how instructions may be
disassembled:

@table @code
@item -Mno-aliases
Disassembles all variants of an instruction to its most generic
representation

@item -Mshow-arch-insn
Prints the format suffix for each instruction in square brackets
according to the architecture reference manual.  This only affects the
disassembly of those instructions that have format suffixes.
@end table

@node nanoMIPS Transformations
@section Controlling Linker Relaxation

nanoMIPS ABI provides support for linker relaxations and
expansions.  Relaxation means that the linker can remove a group of
instructions (typically, 1 or 2) or translate them in to more
efficient sequences.  Expansion is the translation of an instruction
which would be out-of-range due to code or data layout, in to a
sequence capable of expressing the necessary extended range.  The
assembler provides directives and command-line options to control
linker transformations.

@menu
* nanoMIPS relax modules:: Module level control
* nanoMIPS relax fragments:: Controlling relaxation of code fragments
* nanoMIPS relax special:: Special handling of assembly constructs
@end menu

@node nanoMIPS relax modules
@subsection Module level control

Linker relaxations is disabled by default in the assembler.  It can be
enabled for an assembly unit using the command-line option
@option{--linkrelax} The assembly directive @code{.linkrelax'} also
has the same effect.  It must be specified before any instruction in
the assembly file.

@node nanoMIPS relax fragments
@subsection Controlling relaxation of code fragments

@subsubsection Control by blocks

The directive @code{.set nolinkrelax} can be used to inhibit relaxation
within an assembly file, until a corresponding @code{.set linkrelax}
directive is encountered.  This is only effective when linker
relaxation is enabled for the assembly unit.  This can be used for
low-level code which employs fixed PC-relative offsets or for vectored
tables where each code element must be of the same fixed size.  These
directives cause the assembler to emit relocations to mark the point
where relaxation is to be enabled or disabled.


For example, the following fragment disables linker relaxation only
for the setup and call to foo:

@example
    .set nolinkrelax
    beq $a0, $a1, 8
    move $a0, $t8
    sw $a4, 0($t8)
    balc foo
    .set linkrelax
@end example

The following fragment disables linker relaxation for the function foo:
@example
        .text
        .set nolinkrelax
        .type    foo,@@function
    foo:
        ...
        jr $ra
        .set linkrelax
@end example

@subsubsection One instruction at a time

Each instruction can be marked to say that no relaxation or
transformation is to be performed on this instruction.  This is done
the creating an explicit @samp{R_NANOMIPS_FIXED} relocation for
it.  This is automatically extended to cases where the user requests an
instruction with a specific encoding.  For example, both fragments
below have the same effect, which is to disallow any kind of
transformation by the linker, even as the PC-relative relocation gets
fixed up correctly.

@example
        .reloc    1f, R_NANOMIPS_FIXED
    1:    lapc $a0, foo
@end example

@example
    lapc[32] $a0, foo
@end example
@subsubsection By instruction size

It is possible to let the linker perform translations while keeping
the instruction size fixed.  The assembler does this automatically when
an instruction has a size-suffix.  This is useful for creating branch
tables or vector tables, where each element is required to have the
same size, specified at assembly time.  For example,
@example
    vtable:
        bc32 foo
        bc32 bar
        bc32 baz
@end example
@node nanoMIPS relax special
@subsection Special handling of assembly constructs

Certain assembly constructs need special handling by way of marker
relocations to allow linker translations to happen correctly.  The
objective is to capture all the information necessary to preserve
correctness, that is available at assembly time but not available at
link time.

@subsubsection Alignment Directives

Alignment directives have the effect of padding the location counter
to a specific boundary.  The GNU assembler also accepts a fill pattern
to be used for the padding and the maximum amount of padding to be
inserted.  When the linker expands or relaxes instructions, any
alignment point following those instructions is liable to move.  If the
alignment point moves backwards, some of the padding inserted by the
assembler can be removed.  If it move forward, more padding, possibly
of a user-specified pattern needs to be inserted.  In this case, the
total amount of padding, including what is inserted by the assembler
and the linker, must not exceed the user-specified maximum
padding.  The assembler will emit an @samp{R_NANOMIPS_ALIGN} relocation
for each alignment point and an @samp{R_NANOMIPS_FILL} relocation
where user-specified padding is required.  The exact details of the
alignment and padding relocations are covered in the nanoMIPS P32 psABI
supplement.

@subsubsection Save/restore markers

The nanoMIPS ABI allows SAVE & RESTORE instructions to be relaxed from
32-bit to 16-bit encodings as a consequence of GP-setup
optimization.  These instructions are not relocated, so the linker
needs additional markers to be emitted in order to find these
instructions.  These markers are needed only when generating position
independent code, if the assembler selects a 32-bit encoding for a
SAVE or RESTORE operation and saves $gp.  These markers are emitted
automatically by the assembler when relaxations are enabled.

@subsubsection Label-difference expressions

Label difference expressions are used to create jump tables and
calculate code offsets.  If any code between 2 labels undergoes
relaxation or expansion, the difference between the labels can
change.  On the other hand, if there is no relocation or relaxable code
between 2 labels, then their difference can be considered as constant,
or fixed at assembly.  A label difference that can change due to
relaxation must be represented by relocations so that it may be
re-calculated after relaxation.  The assembler takes care of deciding
if label difference relocations are needed and emitting them, so the
user can use label differences in assembly code even in the presence
of linker relaxation.

@node nanoMIPS Syntax
@section Syntactical Considerations
@menu
* nanoMIPS-Chars::                Special Characters
@end menu

@node nanoMIPS-Chars
@subsection Special Characters

@cindex line comment character, nanoMIPS
@cindex nanoMIPS line comment character
The presence of a @samp{#} on a line indicates the start of a comment
that extends to the end of the current line.

If a @samp{#} appears as the first character of a line, the whole line
is treated as a comment, but in this case the line can also be a
logical line number directive (@pxref{Comments}) or a
preprocessor control command (@pxref{Preprocessing}).

@cindex line separator, nanoMIPS
@cindex statement separator, nanoMIPS
@cindex nanoMIPS line separator
The @samp{;} character can be used to separate statements on the same
line.
