@c Copyright (C) 2017 Free Software Foundation, Inc.
@c This is part of the GAS manual.
@c For copying conditions, see the file as.texinfo.
@ifset GENERIC
@page
@node nanoMIPS-Dependent
@chapter nanoMIPS Dependent Features
@end ifset
@ifclear GENERIC
@node Machine Dependencies
@chapter nanoMIPS Dependent Features
@end ifclear

@cindex nanoMIPS processor

@menu
* nanoMIPS Options::            Assembler options
* nanoMIPS Macros:: 	        High-level assembly macros
* nanoMIPS Symbol Sizes::	Directives to override the size of symbols
* nanoMIPS Small Data:: 	Controlling the use of small data accesses
* nanoMIPS ISA::    	        Directives to override the ISA level
* nanoMIPS assembly options::   Directives to control code generation
* nanoMIPS insn::		Directive to mark data as an instruction
* nanoMIPS FP ABIs::	        Marking which FP ABI is in use
* nanoMIPS Option Stack::	Directives to save and restore options
* nanoMIPS ASE Instruction Generation Overrides:: Directives to control
			        generation of nanoMIPS ASE instructions
* nanoMIPS Floating-Point::     Directives to override floating-point options
* nanoMIPS Linker Relaxation::  Directives to control linker relaxations
* nanoMIPS Syntax::             nanoMIPS specific syntactical considerations
* nanoMIPS Relocations::        Using relocation operators for different
                                addressing modes
@end menu

@node nanoMIPS Options
@section Assembler options

The nanoMIPS configurations of @sc{gnu} @code{@value{AS}} support these
special options:

@table @code
@cindex @code{-G} option (nanoMIPS)
@item -G @var{num}
Set the ``small data'' limit to @var{n} bytes.  The default limit is 8 bytes.
@xref{nanoMIPS Small Data,, Controlling the use of small data accesses}.

@cindex @code{-EB} option (nanoMIPS)
@cindex @code{-EL} option (nanoMIPS)
@cindex nanoMIPS big-endian output
@cindex nanoMIPS little-endian output
@cindex big-endian output, nanoMIPS
@cindex little-endian output, nanoMIPS
@item -EB
@itemx -EL
Any nanoMIPS configuration of @code{@value{AS}} can select big-endian or
little-endian output at run time (unlike the other @sc{gnu} development
tools, which must be configured for one or the other).  Use @samp{-EB}
to select big-endian output, and @samp{-EL} for little-endian.

@item -mpic
@itemx -mno-pic
Generate medium-model SVR4-style PIC.  This option tells the assembler
to generate SVR4-style position-independent macro expansions.  It also
tells the assembler to mark the output file as PIC.
@samp{-mno-pic} turns off this option.

@item -mdsp
@itemx -mno-dsp
Generate code for the DSP Application Specific Extension. This tells
the assembler to accept DSP instructions. Since the lowest Release
version of DSP ASE supported by nanoMIPS is Release 3, this option is
equivalent to @samp{-mdspr3}.
@samp{-mno-dsp} turns off this option. This option is equivalent to
@samp{-mno-dspr3}.

@item -mdspr3
@itemx -mno-dspr3
Generate code for the DSP Release 3 Application Specific Extension.
This tells the assembler to accept DSP Release 3 instructions.
@samp{-mno-dspr3} turns off this option.

@item -mmt
@itemx -mno-mt
Generate code for the MT Application Specific Extension.
This tells the assembler to accept MT instructions.
@samp{-mno-mt} turns off this option.

@item -mmcu
@itemx -mno-mcu
Generate code for the MCU Application Specific Extension.
This tells the assembler to accept MCU instructions.
@samp{-mno-mcu} turns off this option.

@item -mmsa
@itemx -mno-msa
Generate code for the nanoMIPS SIMD Architecture Extension.
This tells the assembler to accept MSA instructions.
@samp{-mno-msa} turns off this option.

@item -mxpa
@itemx -mno-xpa
Generate code for the nanoMIPS eXtended Physical Address (XPA) Extension.
This tells the assembler to accept XPA instructions.
@samp{-mno-xpa} turns off this option.

@item -mvirt
@itemx -mno-virt
Generate code for the Virtualization Application Specific Extension.
This tells the assembler to accept Virtualization instructions.
@samp{-mno-virt} turns off this option.

@item -mginv
@itemx -mno-ginv
Generate code for the Global cache INValidate Application Specific Extension.
This tells the assembler to accept GINV instructions.
@samp{-mno-ginv} turns off this option.

@item -mtlb
@itemx -mno-tlb
Generate code for the Translation Lookaside Buffer control extension.
This tells the assembler to accept TLB control instructions.
@samp{-mno-tlb} turns off this option.

@item -minsn32
@itemx -mno-insn32
Only use 32-bit instruction encodings when generating code for the
microMIPS processor.  This option inhibits the use of any 16-bit
instructions.  This is equivalent to putting @code{.module insn32} at
the start of the assembly file.  @samp{-mno-insn32} turns off this
option.  This is equivalent to putting @code{.module noinsn32} at the
start of the assembly file.  By default @samp{-mno-insn32} is
selected, allowing all instructions to be used.

@item -march=@var{arch}
Generate code for a particular nanoMIPS @var{arch}, which can be the name of a generic nanoMIPS @var{ISA} or the name of a particular @var{CPU}. Valid @var{ISA} value are: 

@quotation
32r6,
32r6s,
64r6
@end quotation

Valid @var{CPU} value are:

@quotation
i7200,
m7000
@end quotation

@item -m32
Generate code for the p32 ABI.

@item -m64
Generate code for the p64 ABI.

@item -mtune=@var{cpu}
Schedule and tune for a particular nanoMIPS CPU.  Valid @var{cpu} values are
identical to @samp{-march=@var{cpu}}.

@item -msym32
@itemx -mno-sym32
@cindex -msym32
@cindex -mno-sym32
Equivalent to adding @code{.set sym32} or @code{.set nosym32} to
the beginning of the assembler input.  @xref{nanoMIPS Symbol Sizes}.

@cindex @code{-nocpp} ignored (nanoMIPS)
@item -nocpp
This option is ignored.  It is accepted for command-line compatibility with
other assemblers, which use it to turn off C style preprocessing.  With
@sc{gnu} @code{@value{AS}}, there is no need for @samp{-nocpp}, because the
@sc{gnu} assembler itself never runs the C preprocessor.

@item -msoft-float
@itemx -mhard-float
Disable or enable floating-point instructions.  Note that by default
floating-point instructions are always allowed even with CPU targets
that don't have support for these instructions.

@item -msingle-float
@itemx -mdouble-float
Disable or enable double-precision floating-point operations.  Note
that by default double-precision floating-point operations are always
allowed even with CPU targets that don't have support for these
operations.

@item --construct-floats
@itemx --no-construct-floats
The @code{--no-construct-floats} option disables the construction of
double width floating point constants by loading the two halves of the
value into the two single width floating point registers that make up
the double width register.  This feature is useful if the processor
support the FR bit in its status  register, and this bit is known (by
the programmer) to be set.  This bit prevents the aliasing of the double
width register by the single width registers.

By default @code{--construct-floats} is selected, allowing construction
of these floating point constants.

@item --relax-branch
@itemx --no-relax-branch
The @samp{--relax-branch} option enables the relaxation of out-of-range
branches.  Any branches whose target cannot be reached directly are
converted to a small instruction sequence including an inverse-condition
branch to the physically next instruction, and a jump to the original
target is inserted between the two instructions.  In PIC code the jump
will involve further instructions for address calculation.

The @code{BC1ANY2F}, @code{BC1ANY2T}, @code{BC1ANY4F}, @code{BC1ANY4T},
@code{BPOSGE32} and @code{BPOSGE64} instructions are excluded from
relaxation, because they have no complementing counterparts.  They could
be relaxed with the use of a longer sequence involving another branch,
however this has not been implemented and if their target turns out of
reach, they produce an error even if branch relaxation is enabled.

Also no nanoMIPS16 branches are ever relaxed.

By default @samp{--no-relax-branch} is selected, causing any out-of-range
branches to produce an error.

@item --trap
@itemx --no-break
@c FIXME!  (1) reflect these options (next item too) in option summaries;
@c         (2) stop teasing, say _which_ instructions expanded _how_.
@code{@value{AS}} automatically macro expands certain division and
multiplication instructions to check for overflow and division by zero.  This
option causes @code{@value{AS}} to generate code to take a trap exception
rather than a break exception when an error is detected.  The trap instructions
are only supported at Instruction Set Architecture level 2 and higher.

@item --break
@itemx --no-trap
Generate code to take a break exception rather than a trap exception when an
error is detected.  This is the default.

@item -mbalc-stubs
@itemx -mno-balc-stubs
Consolidate multiple out-of-range call instructions to a function to
16-bit calls to a stub with transfers control to the function. The
@samp{-mbalc-stubs} option improves code compression at the cost
of performance, since each transformed call requires two control
transfers.

This optimization is disabled by default.

@item -mlegacyregs
Allow the use of legacy MIPS style numeric register formats in
nanoMIPS assembly.

@item --linkrelax
Enable link-time relaxation features. The assembler will generate
additional reloctions to allow the linker to expand/relax object
code and fix-up for correctness. FIXME: Ref to .set options.
@end table

@node nanoMIPS Macros
@section High-level assembly macros

MIPS assemblers have traditionally provided a wider range of
instructions than the MIPS architecture itself.  These extra
instructions are usually referred to as ``macro'' instructions
@footnote{The term ``macro'' is somewhat overloaded here, since
these macros have no relation to those defined by @code{.macro},
@pxref{Macro,, @code{.macro}}.}. nanoMIPS assembler continues
support for many traditionally supported instructions.

Some nanoMIPS macro instructions extend an underlying architectural
instruction while others are entirely new.  An example of the former
type is @code{and}, which allows the third operand to be either a
register or an arbitrary immediate value.  Examples of the latter type
include @code{bgt}, which branches to the third operand when the
first operand is greater than the second operand.

One of the most common extensions provided by macros is to expand
memory offsets to the full address range (32 or 64 bits) and to allow
symbolic offsets such as @samp{my_data + 4} to be used in place of
integer constants.  For example, the architectural instruction
@code{lbu} allows only an unsigned 12-bit offset, whereas the macro
@code{lbu} allows code such as @samp{lbu $4,array+32769}.
The implementation of these symbolic offsets depends on several factors,
such as whether the assembler is generating SVR4-style PIC (selected by
@option{-mpic}, @pxref{nanoMIPS Options,, Assembler options}), the size of symbols
(@pxref{nanoMIPS Symbol Sizes,, Directives to override the size of symbols}),
and the small data limit (@pxref{nanoMIPS Small Data,, Controlling the use
of small data accesses}).

@kindex @code{.set macro}
@kindex @code{.set nomacro}
It is undesirable to have one assembly instruction expand
to several machine instructions.  The directive @code{.set nomacro}
tells the assembler to prohibit such expansions.  @code{.set macro}
restores the default behavior. Note that this behaviour is a departure
from the MIPS assembler which only warns about generation of macros
after @code{.set nomacro}.

@cindex @code{at} register, nanoMIPS
@kindex @code{.set at=@var{reg}}
Some macro instructions need a temporary register to store intermediate
results.  This register is usually @code{$1}, also known as @code{$at},
but it can be changed to any core register @var{reg} using
@code{.set at=@var{reg}}.  Note that @code{$at} always refers
to @code{$1} regardless of which register is being used as the
temporary register.

@kindex @code{.set at}
@kindex @code{.set noat}
Implicit uses of the temporary register in macros could interfere with
explicit uses in the assembly code.  The assembler therefore warns
whenever it sees an explicit use of the temporary register.  The directive
@code{.set noat} silences this warning while @code{.set at} restores
the default behavior.  It is safe to use @code{.set noat} while
@code{.set nomacro} is in effect since single-instruction macros
never need a temporary register.

Note that while the @sc{gnu} assembler provides these macros for
compatibility, it does not make any attempt to optimize them with the
surrounding code.

@node nanoMIPS Symbol Sizes
@section Directives to override the size of symbols

@kindex @code{.set sym32}
@kindex @code{.set nosym32}
The P64 ABI allows symbols to have any 64-bit value.  Although this
provides a great deal of flexibility, it means that some macros have
longer expansions than their 32-bit counterparts.  For example,
the non-PIC expansion of @samp{dla $4,sym} is usually:

@smallexample
dlui    $4,%hi32(sym)
daddiu  $4,$4,%lo32(sym)
@end smallexample

whereas the 32-bit expansion is simply:

@smallexample
li  $4,$4,sym
@end smallexample

P64 code is sometimes constructed in such a way that all symbolic
constants are known to have 32-bit values, and in such cases, it's
preferable to use the 32-bit expansion instead of the 64-bit
expansion.

You can use the @code{.set sym32} directive to tell the assembler
that, from this point on, all expressions of the form
@samp{@var{symbol}} or @samp{@var{symbol} + @var{offset}}
have 32-bit values.  For example:

@smallexample
.set sym32
dla     $4,sym
lw      $4,sym+16
sw      $4,sym+0x8000
@end smallexample

will cause the assembler to treat @samp{sym}, @code{sym+16} and
@code{sym+0x8000} as 32-bit values.  The handling of non-symbolic
addresses is not affected.

The directive @code{.set nosym32} ends a @code{.set sym32} block and
reverts to the normal behavior.  It is also possible to change the
symbol size using the command-line options @option{-msym32} and
@option{-mno-sym32}.

These options and directives are always accepted, but at present,
they have no effect for anything other than P64.

@node nanoMIPS Small Data
@section Controlling the use of small data accesses

@cindex small data, nanoMIPS
@cindex @code{gp} register, nanoMIPS
It often takes several instructions to load the address of a symbol.
For example, when @samp{addr} is a 32-bit symbol, the non-PIC expansion
of @samp{dla $4,addr} is usually:

@smallexample
lui     $4,%hi(addr)
daddiu  $4,$4,%lo(addr)
@end smallexample

The sequence is much longer when @samp{addr} is a 64-bit symbol.
@xref{nanoMIPS Symbol Sizes,, Directives to override the size of symbols}.

In order to cut down on this overhead, most embedded nanoMIPS systems
set aside a 64-kilobyte ``small data'' area and guarantee that all
data of size @var{n} and smaller will be placed in that area.
The limit @var{n} is passed to both the assembler and the linker
using the command-line option @option{-G @var{n}}, @pxref{nanoMIPS Options,,
Assembler options}.  Note that the same value of @var{n} must be used
when linking and when assembling all input files to the link; any
inconsistency could cause a relocation overflow error.

The size of an object in the @code{.bss} section is set by the
@code{.comm} or @code{.lcomm} directive that defines it.  The size of
an external object may be set with the @code{.extern} directive.  For
example, @samp{.extern sym,4} declares that the object at @code{sym}
is 4 bytes in length, while leaving @code{sym} otherwise undefined.

When no @option{-G} option is given, the default limit is 8 bytes.
The option @option{-G 0} prevents any data from being automatically
classified as small.

It is also possible to mark specific objects as small by putting them
in the special sections @code{.sdata} and @code{.sbss}, which are
``small'' counterparts of @code{.data} and @code{.bss} respectively.
The toolchain will treat such data as small regardless of the
@option{-G} setting.

On startup, systems that support a small data area are expected to
initialize register @code{$28}, also known as @code{$gp}, in such a
way that small data can be accessed using a 16-bit offset from that
register.  For example, when @samp{addr} is small data,
the @samp{dla $4,addr} instruction above is equivalent to:

@smallexample
daddiu  $4,$28,%gp_rel(addr)
@end smallexample

Small data is not supported for SVR4-style PIC.

@node nanoMIPS ISA
@section Directives to override the ISA level

@cindex nanoMIPS CPU override
@kindex @code{.set arch=@var{cpu}}
The @code{.set arch=@var{cpu}} directive provides even finer control.
It changes the effective CPU target and allows the assembler to use
instructions specific to a particular CPU.  All CPUs supported by the
@samp{-march} command line option are also selectable by this directive.
The original value is restored by @code{.set arch=default}.

@node nanoMIPS assembly options
@section Directives to control code generation

@cindex nanoMIPS directives to override command line options
@kindex @code{.module}
The @code{.module} directive allows command line options to be set directly
from assembly.  The format of the directive matches the @code{.set}
directive but only those options which are relevant to a whole module are
supported.  The effect of a @code{.module} directive is the same as the
corresponding command line option.  Where @code{.set} directives support
returning to a default then the @code{.module} directives do not as they
define the defaults.

Module-level directives must appear first in assembly, before any
instructions.

@cindex nanoMIPS 32-bit microMIPS instruction generation override
@kindex @code{.set insn32}
@kindex @code{.set noinsn32}
The directive @code{.set insn32} makes the assembler only use 32-bit
instruction encodings when generating code for the microMIPS processor.
This directive inhibits the use of any 16-bit instructions from that
point on in the assembly.  The @code{.set noinsn32} directive allows
16-bit instructions to be accepted.

@cindex Control code/data memory models
@kindex @code{.set mcmodel=auto}
@kindex @code{.set mcmodel=small}
@kindex @code{.set mcmodel=large}
These directives specify the memory model that the assembler may
assume for generating macros. The directive @code{.set mcmodel=auto}
defers most decisions about the range of the code/data layout to
link-time relaxation. It requires linker relaxation to be enabled and
a capable linker. The directive @code{.set mcmodel=small} assumes that
the GP-relative region (which includes the GOT) must not exceed 2MiB
and the total code size for a final link must not exceed 32MiB. The
directive @code{.set mcmodel=large} implies no limits<FIXME not true for
64-bits, perhaps specify a 2GB limit>.

@node nanoMIPS insn
@section Directive to mark data as an instruction

@kindex @code{.insn}
The @code{.insn} directive tells @code{@value{AS}} that the following
data is actually instructions.  This makes a difference in nanoMIPS 16 and
microMIPS modes: when loading the address of a label which precedes
instructions, @code{@value{AS}} automatically adds 1 to the value, so
that jumping to the loaded address will do the right thing.

@kindex @code{.global}
The @code{.global} and @code{.globl} directives supported by
@code{@value{AS}} will by default mark the symbol as pointing to a
region of data not code.  This means that, for example, any
instructions following such a symbol will not be disassembled by
@code{objdump} as it will regard them as data.  To change this
behavior an optional section name can be placed after the symbol name
in the @code{.global} directive.  If this section exists and is known
to be a code section, then the symbol will be marked as pointing at
code not data.  Ie the syntax for the directive is:

  @code{.global @var{symbol}[ @var{section}][, @var{symbol}[ @var{section}]] ...},

Here is a short example:

@example
        .global foo .text, bar, baz .data
foo:
        nop
bar:
        .word 0x0
baz:
        .word 0x1

@end example

@node nanoMIPS FP ABIs
@section Directives to control the FP ABI
@menu
* nanoMIPS FP ABI Variants::               Supported FP ABIs
* nanoMIPS FP ABI Compatibility::          Linking different FP ABI variants
@end menu

@node nanoMIPS FP ABI Variants
@subsection Supported FP ABIs
The supported floating-point ABI variants are:

@table @code
@item 0 - No floating-point
This variant is used to indicate that floating-point is not used within
the module at all and therefore has no impact on the ABI.  This is the
default.

@item 1 - Double-precision
This variant indicates that double-precision support is used.  For 64-bit
ABIs this means that 64-bit wide floating-point registers are required.
For 32-bit ABIs this means that 32-bit wide floating-point registers are
required and double-precision operations use pairs of registers.

@item 2 - Single-precision
This variant indicates that single-precision support is used.  Double
precision operations will be supported via soft-float routines.

@item 3 - Soft-float
This variant indicates that although floating-point support is used all
operations are emulated in software.  This means the ABI is modified to
pass all floating-point data in general-purpose registers.

@end table

@node nanoMIPS FP ABI Compatibility
@subsection Linking different FP ABI variants
<FIXME>

@node nanoMIPS Option Stack
@section Directives to save and restore options

@cindex nanoMIPS option stack
@kindex @code{.set push}
@kindex @code{.set pop}
The directives @code{.set push} and @code{.set pop} may be used to save
and restore the current settings for all the options which are
controlled by @code{.set}.  The @code{.set push} directive saves the
current settings on a stack.  The @code{.set pop} directive pops the
stack and restores the settings.

These directives can be useful inside an macro which must change an
option such as the ISA level or instruction reordering but does not want
to change the state of the code which invoked the macro.

Traditional nanoMIPS assemblers do not support these directives.

@node nanoMIPS ASE Instruction Generation Overrides
@section Directives to control generation of nanoMIPS ASE instructions

@cindex nanoMIPS DSP Release 1 instruction generation override
@kindex @code{.set dsp}
@kindex @code{.set nodsp}
The directive @code{.set dsp} makes the assembler accept instructions
from the DSP Release 1 Application Specific Extension from that point
on in the assembly.  The @code{.set nodsp} directive prevents DSP
Release 1 instructions from being accepted.

@cindex nanoMIPS DSP Release 2 instruction generation override
@kindex @code{.set dspr2}
@kindex @code{.set nodspr2}
The directive @code{.set dspr2} makes the assembler accept instructions
from the DSP Release 2 Application Specific Extension from that point
on in the assembly.  This directive implies @code{.set dsp}.  The
@code{.set nodspr2} directive prevents DSP Release 2 instructions from
being accepted.

@cindex nanoMIPS MT instruction generation override
@kindex @code{.set mt}
@kindex @code{.set nomt}
The directive @code{.set mt} makes the assembler accept instructions
from the MT Application Specific Extension from that point on
in the assembly.  The @code{.set nomt} directive prevents MT
instructions from being accepted.

@cindex nanoMIPS MCU instruction generation override
@kindex @code{.set mcu}
@kindex @code{.set nomcu}
The directive @code{.set mcu} makes the assembler accept instructions
from the MCU Application Specific Extension from that point on
in the assembly.  The @code{.set nomcu} directive prevents MCU
instructions from being accepted.

@cindex nanoMIPS SIMD Architecture instruction generation override
@kindex @code{.set msa}
@kindex @code{.set nomsa}
The directive @code{.set msa} makes the assembler accept instructions
from the nanoMIPS SIMD Architecture Extension from that point on
in the assembly.  The @code{.set nomsa} directive prevents MSA
instructions from being accepted.

@cindex Virtualization instruction generation override
@kindex @code{.set virt}
@kindex @code{.set novirt}
The directive @code{.set virt} makes the assembler accept instructions
from the Virtualization Application Specific Extension from that point
on in the assembly.  The @code{.set novirt} directive prevents Virtualization
instructions from being accepted.

@cindex nanoMIPS eXtended Physical Address (XPA) instruction generation override
@kindex @code{.set xpa}
@kindex @code{.set noxpa}
The directive @code{.set xpa} makes the assembler accept instructions
from the XPA Extension from that point on in the assembly.  The 
@code{.set noxpa} directive prevents XPA instructions from being accepted.

@cindex XBurst MXU instruction generation override
@kindex @code{.set mxu}
@kindex @code{.set nomxu}
The directive @code{.set mxu} makes the assembler accept instructions
from the MXU Extension from that point on in the assembly.  The
@code{.set nomxu} directive prevents MXU instructions from being accepted.

@cindex TLB control instruction generation override
@kindex @code{.set tlb}
@kindex @code{.set notlb}
The directive @code{.set tlb} makes the assembler accept instructions
from the TLB control Extension from that point on in the assembly.
The @code{.set notlb} directive prevents TLB control instructions from
being accepted.

@node nanoMIPS Floating-Point
@section Directives to override floating-point options

@cindex Disable floating-point instructions
@kindex @code{.set softfloat}
@kindex @code{.set hardfloat}
The directives @code{.set softfloat} and @code{.set hardfloat} provide
finer control of disabling and enabling float-point instructions.
These directives always override the default (that hard-float
instructions are accepted) or the command-line options
(@samp{-msoft-float} and @samp{-mhard-float}).

@cindex Disable single-precision floating-point operations
@kindex @code{.set singlefloat}
@kindex @code{.set doublefloat}
The directives @code{.set singlefloat} and @code{.set doublefloat}
provide finer control of disabling and enabling double-precision
float-point operations.  These directives always override the default
(that double-precision operations are accepted) or the command-line
options (@samp{-msingle-float} and @samp{-mdouble-float}).

@node nanoMIPS Linker Relaxation
@section Directives to control linker relaxation over a region

@kindex @code{.set linkrelax}
@kindex @code{.set nolinkrelax}
The directive @code{.set linkrelax} emits a place-holder to indicate
that linker relaxations are enabled in the following region.  When
relaxation is enabled, the assembler will emit additional relocations
to direct the linker. The @code{.set nolinkrelax} directive emits 
a place-holder to indicate that linker relaxations are disabled in the
following region.

@node nanoMIPS Syntax
@section Syntactical considerations for the nanoMIPS assembler
@menu
* nanoMIPS-Chars::                Special Characters
@end menu

@node nanoMIPS-Chars
@subsection Special Characters

@cindex line comment character, nanoMIPS
@cindex nanoMIPS line comment character
The presence of a @samp{#} on a line indicates the start of a comment
that extends to the end of the current line.

If a @samp{#} appears as the first character of a line, the whole line
is treated as a comment, but in this case the line can also be a
logical line number directive (@pxref{Comments}) or a
preprocessor control command (@pxref{Preprocessing}).

@cindex line separator, nanoMIPS
@cindex statement separator, nanoMIPS
@cindex nanoMIPS line separator
The @samp{;} character can be used to separate statements on the same
line.

@node nanoMIPS Relocations
@section Using relocation operators for different addressing modes

@menu
* Optimized GP-relative access::
* General GP-relative access::
* 32-bit absolute addressing and immediate construction::
* 64-bit absolute addressing and immediate construction::
* PC-relative addressing::
* Indirect addressing for small PIC model::
* Indirect addressing for large PIC model::
@end menu

@node Optimized GP-relative access
@subsection Optimized GP-relative access

The nanoMIPS architecture allows various fundamental data types, up to 16 bytes in size, to be accessed directly relative to the designated Global Pointer ($gp) register. GP-relative access allows for data load/store and address calculations to be performed in a single 16 or 32-bit instruction, using an offset from the $gp register. The range of the offset and hence the size of the reachable GP-relative region, also called the small data region, varies with the type, size and alignment of the data object being accessed. These limits form the basis of the medium memory model.


@multitable @columnfractions .4 .6
@headitem Data type @tab GP-relative offset range
@item aligned word	@tab 19-bit scaled ( 2MiB)
@item aligned dword	@tab 18-bit scaled (2MiB)
@item aligned half-word	@tab 17-bit scaled (512KiB)
@item aligned float	@tab 16-bit scaled (512KiB)
@item [word] aligned double	@tab 16-bit scaled (512KiB)
@item unaligned word	@tab 18-bit (512KiB)
@item unaligned dword	@tab 18-bit (512KiB)
@item unaligned half-word	@tab 18-bit (512KiB)
@item byte	@tab 18-bit (512KiB)
@end multitable

The object file contains relocations which the linker attempts to resolve when doing the data layout. Even with the medium memory model, there is no guarantee that all GP-relative accesses will be optimized. If the linker can not find a data layout that allows all GP-relative accesses to be optimized, it will either

    Expand some accesses to use multiple instructions: this indicates that although the total amount of small data is less than 2MB, the offset range requirements for all types/alignment cannot be satisfied. The linker can rewrite some accesses to use multiple instructions. However, if expansion is inhibited or not implemented, the link will fail.
    Fail to link: this indicates that the total amount of small data is greater than 2MB. The solution is to recompile with using either the large or the automatic memory model.

Thus, the linker has final control of whether optimized GP-relative access is viable. Assembler directives can be used to disallow expansions at either module-level or per-access. See section <FIXME: link to Controlling link-time transformations> for details. Assembly language syntax for requesting GP-relative access consists of 2 elements:
Explicitly requested GP-relative access

The user can explicitly request GP-relative access with the %gprel relocation operator. This operator can only be used for load/store instructions with $gp as the base register or address calculation with $gp as a source operand. The assembler will match the operation and select the an appropriate relocation for each access. Examples:

    lw $a0, %gprel(foo)($gp)

    l.s $f0, %gprel(bar)($gp)

    addiu $a0, %gprel(foo)($gp)

By itself, this does not guarantee that foo will end up within the small data region. If the layout is such that it happens to be within range, the link will succeed. Otherwise the linker may fail or expand the operation to multiple instructions, as explained above.
Implicit GP-relative access through canonical named sections

Small data sections are typically named `.sbss' (zero-initialized) or `.sdata'. The linker places these sections close to $gp and complains if they are outside the GP-relative range. If access to an object within a small data sections is made by assembler macros, where the addressing mode is unspecified, the assembler will choose a GP-relative expansion.

    lw $a0, foo

    => lw $a0, %gprel(foo) ($gp)

    la $a0, bar

    => addiu $a0, %gprel(foo) ($gp)

Declaration of data in small data sections can be by naming sections using the .section directive or by comm/lcomm/extern declarations, provided the declared size of the object is less than the small data limit specified by -Gnum.

The compiler uses a combination of data declaration in named small data sections and explicitly requested GP-relative access in instructions in order to guarantee GP-relative access.

@node General GP-relative access
@subsection General GP-relative access

If optimized access is not an objective, the full 32-bit address space is reachable by GP-relative addressing. This corresponds to the large memory model. For address calculation with full nanoMIPS ISA, use the 48-bit instruction

    addiu $a0, %gprel32(foo), $gp

With only 32-bit instructions or when restricted to the nanoMIPS subset, use the following sequence:

    lui $a0, %gprel_hi (foo)

    ori $a0, $a0, %gprel_lo(foo)

    addu $a0, $a0, $gp

For loads/stores use the following sequence:

    lui $a0, %gprel_hi (foo)

    addu $a0, $a0, $gp

    lw $a0, %gprel_lo(foo) ($a0)

With a linker capable of doing expansions, the preferred approach is to use the automatic memory model with optimized GP-relative sequences. The linker will convert select accesses to non-optimized sequences where necessary.


@node 32-bit absolute addressing and immediate construction
@subsection 32-bit absolute addressing and immediate construction

The nanoMIPS assembler provides macros which automatically find the best way to materialize an address of immediate value in a register. The macros are called li and la for constants and addresses respectively. This section demonstrates explicit coding methods for predictable code size and addressing modes.

Address calculation for full nanoMIPS ISA with 48-bit instructions can trivially be done with

    li $a0, foo

With only 32-bit instructions or when restricted to the nanoMIPS subset, use the following combination:

    lui $a0, %hi(foo)

    ori $a0, %lo(foo)

Immediate construction for full nanoMIPS ISA can be trivially done with:

    li $a0, <imm>

Here, depending on the immediate value, the assembler will pick a 16-bit, 32-bit or 48-bit instruction.

For immediate construction using only 32-bit instructions, or when restricted to the nanoMIPS subset, the preferred option is:

    lui $a0, %hi(imm)

    ori $a0, %lo(imm)

This sequence breaks the immediate value in to a 20-bit high part and a 12-bit unsigned low part. However, the traditional (16-bit high + 16-bit signed-low) form, typical to MIPS, is also supported:

    lui $a0, imm_hi16

    addiu $a0,  imm_lo16

Here, imm_lo16 = (short) imm and imm_hi16 = ((imm - imm_lo16) >> 16). These interpretations borrow from the definition of %hi & %lo on MIPS, so that MIPS code can continue to work correctly on nanoMIPS. Note the use of ADDIU instruction for the signed low-part.

@node 64-bit absolute addressing and immediate construction
@subsection 64-bit absolute addressing and immediate construction

64-bit address calculation requires two 48-bit instructions as follows:

    dlui $a0, %hi32 (foo)

    daddiu $a0, $a0, %lo(foo)

To load 64-bit immediate value, just replace the symbol with a literal in the above sequence:

    dlui $a0, %hi32 (imm)

    daddiu $a0, $a0, %lo32(imm)

Note that hi32 and lo32 do not directly correspond to the higher and lower 32-bits of the immediate value. The addition step requires a signed 32-bit value. The break up is defined as:

    %lo32(x) = (int) x

    %hi32(x) = (x - %lo32(x)) >> 32

@node PC-relative addressing
@subsection PC-relative addressing

Address calculation within a + 1MB region of current PC can be done with a single 32-bit instruction:

    lapc $a0, foo

For full nanoMIPS ISA, the above selects a 48-bit instruction which can reach any address within 32-bits (+ 2GB) of the PC.

For address calculation using only 32-bit instructions, or when restricted to the nanoMIPS subset, use:

    aluipc $a0, %pcrel_hi (foo)

    ori $a0, $a0, %lo(foo)

The ALUIPC instruction generates a 4k-aligned address, unlike MIPS. This can be considered as the address of the 4k page that contains the address foo. The subsequent ORI introduces the offset within that 4k page and is not really PC-relative. The user can insert any number of instructions between the high & low part calculations above, without having to adjust the addend for the low part. Owing to these differences, the typical MIPS PC-relative address calculation fragment below will NOT work correctly on nanoMIPS:

    aluipc $a0, %pcrel_hi (foo) ; not 4k-aligned

    ori $a0, $a0, %pcrel_lo(foo+4) ; addend reflects difference in PC of the high and low calculation

PC-relative address calculation typically needs more power than the corresponding absolute address calculation. The latter should be preferred for low-power applications, whenever possible.

@node Indirect addressing for small PIC model
@subsection Indirect addressing for small PIC model (-fpic)

The linker places the GOT section in the small data area. GOT entries can be directly accessed as:

    lw $a0, %got_disp (foo) ($gp)

This mechanism is agnostic to symbol visibility or preemption. A capable linker will relax or expand the sequence to optimized the access. The linker may also place small data directly in the GP-relative region, so even when the GOT section is less than 2MiB, it may be too big to satisfy medium memory model constraints.

@node Indirect addressing for large PIC model
@subsection Indirect addressing for large PIC model (-fPIC)

When the GOT spills out of the GP-relative range, 32-bit displacements are required. Calculating displacements relative to the PC instead of GP is preferred, since it gives shorter load sequences. For the full nanoMIPS ISA, this can be done with a single 48-bit instruction:

    lwpc $a0, %got_pcrel32 (foo)

For address calculation using only 32-bit instructions, or when restricted to the nanoMIPS subset, use:

    aluipc $a0, %got_pcrel_hi (foo)

    lw $a0, %got_lo (foo) ($a0)

As with GP-relative access,  the preferred approach is to use small PIC sequences and let the linker convert select accesses to large PIC sequences where necessary.
