//TODO: forbidden slots instruction type needs checking

:%s::::R6COND:int r6cond
{
  int cond = r6cond >> 1;
  if (r6cond & 0x1)
  {
    switch (cond)
    {
      case FP_CMP_AF: return "SAF";
      case FP_CMP_UN: return "SUN";
      case FP_CMP_OR: return "SOR";
      case FP_CMP_EQ: return "SEQ";
      case FP_CMP_UNE: return "SUNE";
      case FP_CMP_UEQ: return "SUEQ";
      case FP_CMP_NE: return "SNE";
      case FP_CMP_LT: return "SLT";
      case FP_CMP_ULT: return "SULT";
      case FP_CMP_LE: return "SLE";
      case FP_CMP_ULE: return "SULE";
      default: return "?";
    }
  }
  else
  {
    switch (cond)
    {
      case FP_CMP_AF: return "AF";
      case FP_CMP_UN: return "UN";
      case FP_CMP_OR: return "OR";
      case FP_CMP_EQ: return "EQ";
      case FP_CMP_UNE: return "UNE";
      case FP_CMP_UEQ: return "UEQ";
      case FP_CMP_NE: return "NE";
      case FP_CMP_LT: return "LT";
      case FP_CMP_ULT: return "ULT";
      case FP_CMP_LE: return "LE";
      case FP_CMP_ULE: return "ULE";
      default: return "?";
    }
  }
}

:%s::::R6CONDFMT:int r6fmt
{
  switch (r6fmt)
  {
    case 0x4: return "s";
    case 0x5: return "d";
    default: return "?";
  }
}

010001,0000,1.FMT,5.FT,5.FS,5.FD,011000:POOLX:32,f::FMADD.fmt
"fmadd.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0); 
  TRACE_ALU_INPUT3 (FGR[FD], FGR[FS], FGR[FT]);
  StoreFPR (FD, fmt, FusedMultiplyAdd (ValueFPR (FS, fmt),
                                       ValueFPR (FT, fmt),
				       ValueFPR (FD, fmt), fmt));
  TRACE_ALU_RESULT (FGR[FD]);
}

010001,0000,1.FMT,5.FT,5.FS,5.FD,011001:POOLX:32,f::FMSUB.fmt
"fmsub.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0); 
  TRACE_ALU_INPUT3 (FGR[FD], FGR[FS], FGR[FT]);
  StoreFPR (FD, fmt, FusedMultiplySub (ValueFPR (FS, fmt),
                                       ValueFPR (FT, fmt),
				       ValueFPR (FD, fmt), fmt));
  TRACE_ALU_RESULT (FGR[FD]);
}

010001,10,3.R6CONDFMT!0!1!2!3!6!7,5.FT,5.FS,5.FD,6.R6COND!16!23!24!32!33:POOL32X:32,f::CMP.cond.fmt
"cmp.%s<R6COND>.%s<R6CONDFMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  int fmt = R6CONDFMT;
  check_fpu (SD_);
  switch(R6CONDFMT)
  {
    case 0x4: fmt = fmt_single; break;
    case 0x5: fmt = fmt_double; break;
    default:  fmt = fmt_single; break;
  }
  TRACE_ALU_INPUT3 (FGR[FD], FGR[FS], FGR[FT]);
  StoreFPR(FD, fmt, R6Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, R6COND));
  TRACE_ALU_RESULT (FGR[FD]);
}

010001,01,1.NEQ,01,5.FT,16.OFFSET:POOL32X:32,f::BC1xxZ
"bc1eqz f<FT>, <OFFSET>":NEQ==0
"bc1nez f<FT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT(FGR[FT]);
  if ((FGR[FT] == 0 && !NEQ) || (FGR[FT] != 0 && NEQ))
  {
    address_word dest = NIA + (EXTEND16 (OFFSET) << 2);
    TRACE_BRANCH_RESULT (dest);
    DELAY_SLOT (dest);
  }
  else
  {
    TRACE_BRANCH_RESULT (0);
    NULLIFY_NEXT_INSTRUCTION ();
  }
}

010001,5.FMT!9!13,5.FT,5.FS,5.FD,010000:POOL32X:32,f::SEL.fmt
"sel.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  check_fpu (SD_);
  check_fmt_p (SD_, FMT, instruction_0);
  if (ValueFPR(FD, FMT) == (signed)0)
    StoreFPR (FD, FMT, ValueFPR (FT, FMT));
  else
    StoreFPR (FD, FMT, ValueFPR (FS, FMT));

}

010001,0000,1.FMT,5.RT,5.FS,5.FD,010100:POOL32X:32,f::SELZ.fmt
"selz.%s<FMT> f<FD>, f<FS>, r<RT>"
*mips32r6:
*mips64r6:
{
  check_fpu (SD_);
  check_fmt_p (SD_, FMT, instruction_0);
  if (GPR[RT] == 0)
    StoreFPR (FD, FMT, ValueFPR (FS, FMT));
  else
    StoreFPR (FD, FMT, 0);
}

010001,0000,1.FMT,5.RT,5.FS,5.FD,010111:POOL32X:32,f::SELN.fmt
"seln.%s<FMT> f<FD>, f<FS>, r<RT>"
*mips32r6:
*mips64r6:
{
  check_fpu (SD_);
  check_fmt_p (SD_, FMT, instruction_0);
  if (GPR[RT] != 0)
    StoreFPR (FD, FMT, ValueFPR (FS, FMT));
  else
    StoreFPR (FD, FMT, 0);
}

000000,5.RS,5.RT,5.RD,00000,110101:POOL32X:32::SELZ
"selz r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  if (GPR[RT] == 0)
    GPR[RD] = 0;
  else
    GPR[RD] = GPR[RS];
}

000000,5.RS,5.RT,5.RD,00000,110111:POOL32X:32::SELN
"seln r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  if (GPR[RT] != 0)
    GPR[RD] = GPR[RS];
  else
    GPR[RD] = 0;
}

000000,5.RS,5.RT,5.RD,00010,011000:POOL32X:32::MUL
"mul r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  signed64 prod;
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  prod = ((signed64)(signed32) GPR[RS])
	  * ((signed64)(signed32) GPR[RT]);
  GPR[RD] = EXTEND32 (VL4_8 (prod));
  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00011,011000:POOL32X:32::MUH
"muh r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  signed64 prod;
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  prod = ((signed64)(signed32) GPR[RS])
	  * ((signed64)(signed32) GPR[RT]);
  GPR[RD] = EXTEND32 (VH4_8 (prod));
  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00010,011001:POOL32X:32::MULU
"mulu r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  unsigned64 prod;
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  prod = ((unsigned64)(unsigned32) GPR[RS])
	  * ((unsigned64)(unsigned32) GPR[RT]);
  GPR[RD] = EXTEND32 (VL4_8 (prod));
  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00011,011001:POOL32X:32::MUHU
"muhu r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  unsigned64 prod;
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  prod = ((unsigned64)(unsigned32) GPR[RS])
          * ((unsigned64)(unsigned32) GPR[RT]);
  GPR[RD] = EXTEND32 (VH4_8 (prod));
  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00010,011010:POOL32X:32::DIV
"div r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  signed32 n = GPR[RS];
  signed32 d = GPR[RT];
  TRACE_ALU_INPUT2 (n,d);
  if (d == 0)
    GPR[RD] = EXTEND32 (0x80000000);
  else if (n == SIGNED32 (0x80000000) && d == -1)
    GPR[RD] = EXTEND32 (0x80000000);
  else
    GPR[RD] = EXTEND32 (n / d);

  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00011,011010:POOL32X:32::MOD
"mod r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  signed32 n = GPR[RS];
  signed32 d = GPR[RT];
  TRACE_ALU_INPUT2 (n,d);
  if (d == 0 || (n == SIGNED32 (0x80000000) && d == -1))
    GPR[RD] = EXTEND32 (0);
  else
    GPR[RD] = EXTEND32 (n % d);

  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00010,011011:POOL32X:32::DIVU
"divu r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  unsigned32 n = GPR[RS];
  unsigned32 d = GPR[RT];
  TRACE_ALU_INPUT2 (n,d);
  if (d == 0)
    GPR[RD] = EXTEND32 (0x80000000);
  else
    GPR[RD] = EXTEND32 (n / d);

  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00011,011011:POOL32X:32::MODU
"modu r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  unsigned32 n = GPR[RS];
  unsigned32 d = GPR[RT];
  TRACE_ALU_INPUT2 (n,d);
  if (d == 0)
    GPR[RD] = EXTEND32 (0);
  else
    GPR[RD] = EXTEND32 (n % d);

  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00010,011100:POOL32X:64::DMUL
"dmul r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  unsigned64 lo;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[RS];
  unsigned64 op2 = GPR[RT];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (op1, op2);
  /* make signed multiply unsigned */
  sign = 0;
  if ((signed64) op1 < 0)
  {
    op1 = - op1;
    ++sign;
  }
  if ((signed64) op2 < 0)
  {
    op2 = - op2;
    ++sign;
  }
  /* multiply out the sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
      + (unsigned64) VL4_8 (m10)
      + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  /* fix the sign */
  if (sign & 1)
    lo = -lo;

  GPR[RD] = lo;
  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00011,011100:POOL32X:64::DMUH
"dmuh r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[RS];
  unsigned64 op2 = GPR[RT];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (op1, op2);
  /* make signed multiply unsigned */
  sign = 0;
  if ((signed64) op1 < 0)
  {
    op1 = - op1;
    ++sign;
  }
  if ((signed64) op2 < 0)
  {
    op2 = - op2;
    ++sign;
  }
  /* multiply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
      + (unsigned64) VL4_8 (m10)
      + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
      + (unsigned64) VH4_8 (mid)
      + (unsigned64) VH4_8 (m01)
      + (unsigned64) VH4_8 (m10));
  /* fix the sign */
  if (sign & 1)
  {
    lo = -lo;
    if (lo == 0)
      hi = -hi;
    else
      hi = -hi - 1;
  }

  GPR[RD] = hi;
  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00010,011101:POOL32X:64::DMULU
"dmulu r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  unsigned64 lo;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 mid;
  unsigned64 op1 = GPR[RS];
  unsigned64 op2 = GPR[RT];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (op1, op2);
  /* multiply out the sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
      + (unsigned64) VL4_8 (m10)
      + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);

  GPR[RD] = lo;
  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00011,011101:POOL32X:64::DMUHU
"dmuhu r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  unsigned64 op1 = GPR[RS];
  unsigned64 op2 = GPR[RT];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (op1, op2);
  /* multiply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
      + (unsigned64) VL4_8 (m10)
      + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
      + (unsigned64) VH4_8 (mid)
      + (unsigned64) VH4_8 (m01)
      + (unsigned64) VH4_8 (m10));

  GPR[RD] = hi;
  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00010,011110:POOL32X:64::DDIV
"ddiv r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  signed64 n = GPR[RS];
  signed64 d = GPR[RT];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (n, d);
  if (d == 0)
    GPR[RD] = SIGNED64 (0x8000000000000000);
  else if (d == -1 && n == SIGNED64 (0x8000000000000000))
    GPR[RD] = SIGNED64 (0x8000000000000000);
  else
    GPR[RD] = (n / d);

  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00011,011110:POOL32X:64::DMOD
"dmod r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  signed64 n = GPR[RS];
  signed64 d = GPR[RT];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (n, d);
  if (d == 0 || (d == -1 && n == SIGNED64 (0x8000000000000000)))
    GPR[RD] = SIGNED64 (0);
  else
    GPR[RD] = (n % d);

  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00010,011111:POOL32X:64::DDIVU
"ddivu r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  unsigned64 n = GPR[RS];
  unsigned64 d = GPR[RT];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (n, d);
  if (d == 0)
    GPR[RD] = UNSIGNED64 (0x8000000000000000);
  else
    GPR[RD] = (n / d);

  TRACE_ALU_RESULT (GPR[RD]);
}

000000,5.RS,5.RT,5.RD,00011,011111:POOL32X:64::DMODU
"dmodu r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  unsigned64 n = GPR[RS];
  unsigned64 d = GPR[RT];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (n, d);
  if (d == 0)
    GPR[RD] = UNSIGNED64 (0);
  else
    GPR[RD] = (n % d);

  TRACE_ALU_RESULT (GPR[RD]);
}

110010,26.OFFSET:POOL32X:32::BC
"bc <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = CIA + (OFFSET << 2);
  TRACE_BRANCH_RESULT (NIA);
}

111010,26.OFFSET:POOL32X:32::BALC
"balc <OFFSET>"
*mips32r6:
*mips64r6:
{
  RA = CIA + 4;
  NIA = CIA + (OFFSET << 2);
  TRACE_BRANCH_RESULT (NIA);
}

110110,5.RS!0,21.OFFSET:POOL32X:32::BEQZC
"beqzc r<RS>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT (GPR[RS]);
  if (GPR[RS] == 0)
    NIA = CIA + (OFFSET << 2);

  TRACE_BRANCH_RESULT (NIA);
}

110110,00000,5.RT,16.OFFSET:POOL32X:32::JRIC
"jric r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = GPR[RT] + (EXTEND16(OFFSET) << 2);
}

111110,5.RS!0,21.OFFSET:POOL32X:32::BNEZC
"bnezc r<RS>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT (GPR[RS]);
  if (GPR[RS] != 0)
    NIA = CIA + (OFFSET << 2);

  TRACE_BRANCH_RESULT (NIA);
}

111110,00000,5.RT,16.OFFSET:POOL32X:32::JRIALC
"jrialc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  RA = CIA + 4;
  NIA = GPR[RT] + (EXTEND16(OFFSET) << 2);
}

010110,00000,5.RT!0,16.OFFSET:POOL32X:32::BLEZC
"blezc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT (GPR[RT]);
  if (GPR[RT] <= 0);
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

010110,5.RS=RT,5.RT!0,16.OFFSET:POOL32X:32::BGEZC
"bgezc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (GPR[RS], GPR[RT]);
  if (GPR[RT] >= 0);
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

010110,5.RS!0!RT,5.RT!0,16.OFFSET:POOL32X:32::BGEC
"bcgec r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (GPR[RS], GPR[RT]);
  if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}


010111,00000,5.RT!0,16.OFFSET:POOL32X:32::BGTZC
"bgtzc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT (GPR[RT]);
  if (GPR[RT] > 0);
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

010111,5.RS=RT,5.RT!0,16.OFFSET:POOL32X:32::BLTZC
"bltzc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (GPR[RS], GPR[RT]);
  if (GPR[RT] < 0);
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

010111,5.RS!0!RT,5.RT!0,16.OFFSET:POOL32X:32::BLTC
"bltc r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (GPR[RS], GPR[RT]);
  if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

000110,00000,5.RT!0,16.OFFSET:POOL32X:32::BLEZALC
"blezalc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT (GPR[RT]);
  RA = CIA + 4;
  if (GPR[RT] <= 0);
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

000110,5.RS=RT,5.RT!0,16.OFFSET:POOL32X:32::BGEZALC
"bgezalc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (GPR[RS], GPR[RT]);
  RA = CIA + 4;
  if (GPR[RT] >= 0);
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

000110,5.RS!0!RT,5.RT!0,16.OFFSET:POOL32X:32::BBEC
"bbec r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (GPR[RS], GPR[RT]);
  if (GPR[RS] >= GPR[RT])
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

000111,00000,5.RT!0,16.OFFSET:POOL32X:32::BGTZALC
"bgtzalc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (GPR[RT], OFFSET);
  RA = CIA + 4;
  if (GPR[RT] > 0);
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

000111,5.RS=RT,5.RT!0,16.OFFSET:POOL32X:32::BLTZALC
"bltzalc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (OFFSET, GPR[RT]);
  RA = CIA + 4;
  if (GPR[RT] < 0);
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

000111,5.RS!0!RT,5.RT!0,16.OFFSET:POOL32X:32::BSTC
"bstc r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (GPR[RT], GPR[RS]);
  if (GPR[RS] < GPR[RT])
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

//TODO: JCRPOP is gone, this opcode is definitely being used
//      but the spec doesn't yet know what for...
//111011,5.RS=RT,5.RT=RS,16.OFFSET:POOL32X:32::XXX
//"xxx r<RT>, <OFFSET>"
//*mips32r6:
//*mips64r6:
//{
//}

111011,5.RS=0,5.RT!0,16.OFFSET:POOL32X:32::BEQZALC
"beqzalc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (OFFSET, GPR[RT]);
  RA = CIA + 4;
  if (GPR[RT] == 0)
    NIA = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

111011,5.RS!0,5.RT=0,16.OFFSET:POOL32X:32::BNEZALC
"bnezalc r<RS>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  TRACE_BRANCH_INPUT2 (OFFSET, GPR[RS]);
  RA = CIA + 4;
  if (GPR[RS] != 0)
    NIA = CIA +  (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_RESULT (NIA);
}

//BCNE is RS > RT, RS==RT is already handled by JCRPOP
111011,5.RS!0,5.RT!0,16.OFFSET:POOL32X:32::BxxC
"beqc r<RS>, r<RT>, <OFFSET>":RS<RT
"bnec r<RS>, r<RT> <OFFSET>"
*mips32r6:
*mips64r6:
{
  address_word dest = CIA + (EXTEND16 (OFFSET) << 2);
  TRACE_BRANCH_INPUT2 (GPR[RS], GPR[RT]);
  TRACE_BRANCH_INPUT (OFFSET);
  if (RS < RT)
  {
    //BCEQ
    if (GPR[RS] == GPR[RT])
      NIA = dest;
  }
  else
  {
    //BCNE
    if (GPR[RS] != GPR[RT])
      NIA = dest;
  }
  TRACE_BRANCH_RESULT (NIA);
}

011111,5.BASE,5.RT,9.OFFSET,0,110110:SPECIAL3:32::LL
"ll r<RT>, <OFFSET>(r<BASE>)"
*mips32r6:
*mips64r6:
{
  do_ll (SD_, RT, BASE, OFFSET);
}

011111,5.BASE,5.RT,9.OFFSET,0,100110:SPECIAL3:32::SC
"sc r<RT>, <OFFSET>(r<BASE>)"
*mips32r6:
*mips64r6:
{
  do_sc (SD_, RT, BASE, OFFSET);
}

011111,5.BASE,5.RT,9.OFFSET,0,110111:SPECIAL3:64::LLD
"lld r<RT>, <OFFSET>(r<BASE>)"
*mips64r6:
{
  check_u64 (SD_, instruction_0);
  do_lld (SD_, RT, BASE, OFFSET);
}

011111,5.BASE,5.RT,9.OFFSET,0,100111:SPECIAL3:64::SCD
"scd r<RT>, <OFFSET>(r<BASE>)"
*mips64r6:
{
  check_u64 (SD_, instruction_0);
  do_scd (SD_, RT, BASE, OFFSET);
}

011111,5.BASE,5.HINT,9.OFFSET,0,110101:SPECIAL3:32::PREF
"pref <HINT>, <OFFSET>(r<BASE>)"
*mips32r6:
*mips64r6:
{
  do_pref (SD_, HINT, BASE, OFFSET);
}

011111,5.BASE,5.HINT,9.OFFSET,0,100101:SPECIAL3:32::CACHE
"cache <HINT>, <OFFSET>(r<BASE>)"
*mips32r6:
*mips64r6:
{
  do_cache (SD_, HINT, BASE, OFFSET, instruction_0);
}

000000,5.RS,5.RT,5.RD,000,2.IMM,000101:SPECIAL:32::LSA
"lsa r<RD>, r<RS>, r<RT>, <IMM + 1>"
*mips32r6:
*mips64r6:
{
  unsigned32 t = GPR[RS] << (IMM + 1);
  GPR[RD] = EXTEND32(GPR[RT] + t);
}

000000,5.RS,5.RT,5.RD,000,2.IMM,010101:SPECIAL:64::DLSA
"dlsa r<RD>, r<RS>, r<RT>, <IMM + 1>"
*mips64r6:
{
  unsigned64 t = GPR[RS] << (IMM + 1);
  GPR[RD] = GPR[RT] + t;
}

001111,5.RS,5.RT,16.IMMEDIATE:POOL32X:32::LUI
"lui r<RT>, r<RS>, <IMMEDIATE>":RS!=26
"lui r<RT>, PC, <IMMEDIATE>"
*mips32r6:
*mips64r6:
{
  /* TODO: if rs==k0 && status.EXL != 1 then PC */
  address_word base = (RS == 26) ? CIA : GPR[RS];
  TRACE_ALU_INPUT2 (GPR[RS], IMMEDIATE);
  GPR[RT] = base + EXTEND32 (IMMEDIATE << 16);
  TRACE_ALU_RESULT (GPR[RT]);
}

000000,5.RS,00000,5.RD,00001,010000:POOL32X:32::CLZ
"clz r<RD>, r<RS>"
*mips32r6:
*mips64r6:
{
  do_clz (SD_, RD, RS);
}

000000,5.RS,00000,5.RD,00001,010001:POOL32X:32::CLO
"clo r<RD>, r<RS>"
*mips32r6:
*mips64r6:
{
  do_clo (SD_, RD, RS);
}

000000,5.RS,00000,5.RD,00001,010010:POOL32X:64::DCLZ
"dclz r<RD>, r<RS>"
*mips64r6:
{
  check_u64 (SD_, instruction_0);
  do_dclz (SD_, RD, RS);
}

000000,5.RS,00000,5.RD,00001,010011:POOL32X:64::DCLO
"dclo r<RD>, r<RS>"
*mips64r6:
{
  check_u64 (SD_, instruction_0);
  do_dclo (SD_, RD, RS);
}

//TODO: correct this once named, defined, and opcoded
//000000,00000,00000,5.RS,00000,000000:POOL32X:32::BITSWAP
//"bitswap r<RS>"
//*mips32r6:
//*mips64r6:
//{
//}
