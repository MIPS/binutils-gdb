:%s::::R6COND:int r6cond
{
  switch (r6cond)
    {
    case FP_R6CMP_SAF:
      return "SAF";
    case FP_R6CMP_SUN:
      return "SUN";
    case FP_R6CMP_SOR:
      return "SOR";
    case FP_R6CMP_SEQ:
      return "SEQ";
    case FP_R6CMP_SUNE:
      return "SUNE";
    case FP_R6CMP_SUEQ:
      return "SUEQ";
    case FP_R6CMP_SNE:
      return "SNE";
    case FP_R6CMP_SLT:
      return "SLT";
    case FP_R6CMP_SULT:
      return "SULT";
    case FP_R6CMP_SLE:
      return "SLE";
    case FP_R6CMP_SULE:
      return "SULE";
    case FP_R6CMP_AF:
      return "AF";
    case FP_R6CMP_UN:
      return "UN";
    case FP_R6CMP_OR:
      return "OR";
    case FP_R6CMP_EQ:
      return "EQ";
    case FP_R6CMP_UNE:
      return "UNE";
    case FP_R6CMP_UEQ:
      return "UEQ";
    case FP_R6CMP_NE:
      return "NE";
    case FP_R6CMP_LT:
      return "LT";
    case FP_R6CMP_ULT:
      return "ULT";
    case FP_R6CMP_LE:
      return "LE";
    case FP_R6CMP_ULE:
      return "ULE";
    default:
      abort ();
    }
}

010001,1010,1.FMT,5.FT,5.FS,5.FD,0,5.R6COND:POOL32X:32,f::CMP.cond.fmt
"cmp.%s<R6COND>.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  unsigned64 result;
  check_fpu (SD_);
  TRACE_ALU_INPUT2 (ValueFPR (FS, FMT), ValueFPR (FT, FMT)); 

  result = R6Compare (ValueFPR (FS, FMT), ValueFPR (FT, FMT), FMT, R6COND);
  StoreFPR (FD, FMT, result);
  TRACE_ALU_RESULT (result);
}

010001,01001,5.FT,16.OFFSET:POOL32X:32,f::BC1EQZ
"bc1eqz f<FT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  check_fpu (SD_);
  TRACE_ALU_INPUT1 (ValueFPR (FT, fmt_dc32));
  if (ValueFPR (FT, fmt_dc32) == 0)
    DELAY_SLOT (NIA + offset);
}

010001,01101,5.FT,16.OFFSET:POOL32X:32,f::BC1NEZ
"bc1nez f<FT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  check_fpu (SD_);
  TRACE_ALU_INPUT1 (ValueFPR (FT, fmt_dc32));
  if (ValueFPR (FT, fmt_dc32) != 0)
    DELAY_SLOT (NIA + offset);
}
