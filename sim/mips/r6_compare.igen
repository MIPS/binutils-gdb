:%s::::R6COND:int r6cond
{
  switch (cond)
    {
    case FP_CMP_SAF: 
      return "SAF";
    case FP_CMP_SUN: 
      return "SUN";
    case FP_CMP_SOR: 
      return "SOR";
    case FP_CMP_SEQ: 
      return "SEQ";
    case FP_CMP_SUNE: 
      return "SUNE";
    case FP_CMP_SUEQ: 
      return "SUEQ";
    case FP_CMP_SNE: 
      return "SNE";
    case FP_CMP_SLT: 
      return "SLT";
    case FP_CMP_SULT: 
      return "SULT";
    case FP_CMP_SLE: 
      return "SLE";
    case FP_CMP_SULE: 
      return "SULE";
    case FP_CMP_AF: 
      return "AF";
    case FP_CMP_UN: 
      return "UN";
    case FP_CMP_OR: 
      return "OR";
    case FP_CMP_EQ: 
      return "EQ";
    case FP_CMP_UNE: 
      return "UNE";
    case FP_CMP_UEQ: 
      return "UEQ";
    case FP_CMP_NE: 
      return "NE";
    case FP_CMP_LT: 
      return "LT";
    case FP_CMP_ULT: 
      return "ULT";
    case FP_CMP_LE: 
      return "LE";
    case FP_CMP_ULE: 
      return "ULE";
    default:
      abort ();
    }
}

010001,1010,1.FMT,5.FT,5.FS,5.FD,0,5.R6COND:POOL32X:32,f::CMP.cond.fmt
"cmp.%s<R6COND>.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  unsigned64 result;
  check_fpu (SD_);
  TRACE_ALU_INPUT3 (ValueFPR (FD, FMT), ValueFPR (FS, FMT), Value (FT, FMT)); 

  result = R6Compare (ValueFPR (FS, FMT), ValueFPR (FT, FMT), FMT, R6COND);
  StoreFPR (FD, FMT, result);
  TRACE_ALU_RESULT (result);
}
