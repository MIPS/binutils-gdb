// Simulator definition for the micromips ASE.
// Copyright (C) 2005-2014 Free Software Foundation, Inc.
// Contributed by Imagination Technologies, Ltd.
// Written by Ali Lown <ali.lown@imgtec.com>
//
// This file is part of GDB, the GNU debugger.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

:compute:::int:U_SHIFT_1BIT:U:(U << 1)
:compute:::int:U_SHIFT_2BIT:U:(U << 2)
:compute:::int:U_SHIFT_3BIT:U:(U << 3)
:compute:::int:EU_127:EU:((EU == 127) ? -1 \: EU)
:compute:::int:U_LW4X4:U2,U3:((U3 << 3) | (U2 << 2))
:compute:::int:AXUIPC_S_LO:S1,S2,S3:((EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12))) & 0x0000ffff)
:compute:::int:AXUIPC_S_HI:S1,S2,S3:((EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12))) & 0xffff0000)
:compute:::int:AXUIPC_S:S1,S2,S3:(EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12)))
:compute:::int:TRD2:RD20,RD21:(compute_gpr2_dest1_reg (SD_, ((RD21 << 1) | RD20)))
:compute:::int:TRE2:RD20,RD21:(compute_gpr2_dest2_reg (SD_, ((RD21 << 1) | RD20)))
:compute:::int:TRS2:RS4,RS2_0:((RS4 << 4) | RS2_0)
:compute:::int:TRT2:RT4,RT2_0:((RT4 << 4) | RT2_0)
:compute:::int:ADDRESS8:S1,S2:((S2 << 7) | (S1 << 1))
:compute:::address_word:ADDRESS11:S1,S2:(nia + EXTEND11((S2 << 10) | (S1 << 1)))
:compute:::int:ADDRESS15:S1,S2:((S2 << 14) | (S1 << 1))
:compute:::int:ADDRESS21:S1,S2:((S2 << 20) | (S1 << 1))
:compute:::address_word:ADDRESS22:S1,S2:(nia + EXTEND22((S2 << 21) | (S1 << 1)))
:compute:::address_word:ADDRESS26:S1,S2:(nia + EXTEND26((S2 << 25) | (S1 << 1)))
:compute:::int:INS_POS:LSB:(LSB)
:compute:::int:INS_SIZE:LSB,MSBD:(1 + MSBD - LSB)
:compute:::address_word:P7PBRI_ADDRESS:S1,S2:(nia + EXTEND12(S2 << 11 | S1 << 1))
:compute:::address_word:P7PBR1_ADDRESS:S1,S2:(nia + EXTEND15(S2 << 14 | S1 << 1))
:compute:::int:S_7_BIT:S1,S2:(EXTEND7((S1 << 6) | S2))
:compute:::int:S_14_BIT:S1,S2:(EXTEND14 ((S1 << 13) | S2))
:compute:::int:S_4_BIT:S1,S2:(EXTEND4((S1 << 3) | S2))
:compute:::int:S_9_BIT:S1,S2:((S1 << 8) | S2)
:compute:::int:RD1:RD:(compute_gpr1_dest_reg (SD_, RD))
:compute:::int:RT_5_BIT:RT1,RT2:((RT1 << 4) | RT2)
:compute:::int:RS_5_BIT:RS1,RS2:((RS1 << 4) | RS2)
:compute:::int:TRTZ:RTZ:((RTZ == 1) ? 17 \: RTZ)
:compute:::int:EU_12_13:EU:((EU == 12) ? 255 \: ((EU == 13) ? 65535 \: EU))

:function:::unsigned32:compute_gpr2_dest1_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 4;
    case 1: return 5;
    case 2: return 6;
    case 3: return 7;
    default: return 4;
    }
}

:function:::unsigned32:compute_gpr2_dest2_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 5;
    case 1: return 6;
    case 2: return 7;
    case 3: return 4;
    default: return 5;
    }
}

:function:::void:do_p16move:int rt, int rs
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2 (GPR[rt], GPR[rs]);
  GPR[rt] = GPR[rs];
  TRACE_ALU_RESULT2 (GPR[rt], GPR[rs]);
}

:function:::void:do_pauipc: int rt, int s
*micromips32r7:
*micromips64r7:
{
    int address = loadstore_ea (SD_, CIA, s);
    if (rt == 0)
    {
        GPR[rt] = address & ~0xfff;
    }
    else {
        GPR[rt] = address;
    }
}

:function:::address_word:do_bxxxc16:int rs, int rt, address_word offset, address_word nia
*micromips32r7:
*micromips64r7:
{
  if (rs < rt && GPR[rs] == GPR[rt])
    return nia + offset; //BEQC
  if (rs >= rt && GPR[rs] != GPR[rt])
    return nia + offset; //BNEC
  return nia;
}

:function:::void:do_ins_mm_r7:int rt, int rs, int pos, int size
{
  TRACE_ALU_INPUT4 (GPR[rt], GPR[rs], pos, size);
  if (size < 1)
    Unpredictable ();

  int merge_mask = ((1 << size) - 1) << pos;
  int result = GPR[rt] & ~merge_mask | (GPR[rs] << pos) & merge_mask;
  GPR[rt] = EXTEND32 (result);
  TRACE_ALU_RESULT1 (GPR[rt]);
}

:function:::unsigned32:compute_gpr1_dest_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 4;
    case 1: return 5;
    default: return 4;
    }
}

:function:::address_word:do_jialc_mm_r7:int rt, int rs, unsigned16 offset, address_word nia
{
  rt = nia | isa_mode;
  unsigned_word address = do_load (SD_, AccessLength_WORD, GPR[rs], offset);
  isa_mode = address & 1;
  return address & ~1;
}

:function:::unsigned_word:zero_extend:signed_word value, unsigned32 from_nbits
{
  unsigned32 low_bits_mask = (1 << from_nbits) - 1;
  return value & low_bits_mask;
}

:function:::char*:do_get_save_restore_gpr_list:int first_gpr, int count, int fp, int gp
*micromips32r7:
*micromips64r7:
{
  int fp_pending;
  int gp_pending;
  int num_pending;
  int i;
  static char gpr_list[100];
  int is_first_gpr;

  fp_pending = fp || (count==9 && !gp);
  gp_pending = gp;
  num_pending = count;
  gpr_list[0] = '\0';

  is_first_gpr = ((first_gpr >= 16 && first_gpr <= 23) ||
                 first_gpr == 28 ||
                 first_gpr == 30 ||
                 first_gpr == 31) ? 1 : 0;

  i = 0;

  if (fp_pending)
    num_pending--;
  if (gp_pending)
    num_pending--;

  while (i<num_pending)
    {
      char str1[3];
      sprintf(str1, "%d", i);

      if (i>0)
        strcat (gpr_list,",");
      strcat (gpr_list,"s");
      strcat (gpr_list,str1);
      i++;
    }

  if (fp_pending)
    {
      if (i > 0)
        strcat (gpr_list,",");
      strcat (gpr_list,"fp");
    }

  if (gp_pending)
    {
      if (i > 0 || fp_pending)
        strcat (gpr_list,",");
      strcat (gpr_list,"ra");
    }

  if ((i > 0 || fp_pending || gp_pending) && is_first_gpr)
    strcat (gpr_list,",");

  if (first_gpr >= 16 && first_gpr <= 23)
    {
      char str2[3];
      sprintf(str2, "%d", first_gpr-16);

      strcat (gpr_list,"s");
      strcat (gpr_list,str2);
    }
  else if (first_gpr == 28)
    strcat (gpr_list,"gp");
  else if (first_gpr == 30)
    strcat (gpr_list,"fp");
  else if (first_gpr == 31)
    strcat (gpr_list,"ra");

  return (gpr_list);
}

:function:::void:do_save_gprs_to_stack_and_adjust_sp: int first_gpr, int count, int fp, int gp, int offset
*micromips32r7:
*micromips64r7:
{
  unsigned_word va;

  int fp_pending;
  int gp_pending;
  int num_pending;
  int idx;

  fp_pending = fp || (count==9 && !gp);
  gp_pending = gp;
  num_pending = count;

  va = GPR[SPIDX];

  if (first_gpr >= 16 && first_gpr <= 23)
    {
      idx = first_gpr-16;
      do_store (SD_,AccessLength_WORD, va -= 4, 0, GPR[idx]);
    }
  else if (first_gpr == 28)
    {
      idx = 28;
      do_store (SD_,AccessLength_WORD, va -= 4, 0, GPR[idx]);
    }
  else if (first_gpr == 30)
    {
      idx = 30;
      do_store (SD_,AccessLength_WORD, va -= 4, 0, GPR[idx]);
    }
  else if (first_gpr == 31)
    {
      idx = 31;
      do_store (SD_,AccessLength_WORD, va -= 4, 0, GPR[idx]);
    }

  while (num_pending > 0)
    {
      if (fp_pending)
        {
          do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[30]);
          fp_pending = 0;
        }
      else if (gp_pending)
        {
          do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[31]);
          gp_pending = 0;
        }
      else
        {
          idx = 16 | (num_pending - 1);
          do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[idx]);
        }

        num_pending--;
    }

  GPR[SPIDX] -= offset;
}

:function:::void:do_restore_gprs_from_stack_and_adjust_sp: int first_gpr, int count, int fp, int gp, int offset
*micromips32r7:
*micromips64r7:
{
  unsigned_word va;

  int fp_pending;
  int gp_pending;
  int num_pending;
  int idx;

  fp_pending = fp || (count==9 && !gp);
  gp_pending = gp;
  num_pending = count;

  va = GPR[SPIDX] + offset;

  if (first_gpr >= 16 && first_gpr <= 23)
    {
      idx = first_gpr-16;
      GPR[idx] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
    }
  else if (first_gpr == 28)
    {
      idx = 28;
      GPR[idx] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
      //do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[idx]);
    }
  else if (first_gpr == 30)
    {
      idx = 30;
      GPR[idx] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
      //do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[idx]);
    }
  else if (first_gpr == 31)
    {
      idx = 31;
      GPR[idx] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
      //do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[idx]);
    }

  while (num_pending > 0)
    {
      if (fp_pending)
        {
          GPR[idx] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
          //do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[30]);
          fp_pending = 0;
        }
      else if (gp_pending)
        {
          GPR[idx] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
          //do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[31]);
          gp_pending = 0;
        }
      else
        {
          idx = 16 | (num_pending - 1);
          //do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[idx]);
          GPR[idx] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
        }

        num_pending--;
    }

  GPR[SPIDX] += offset;
}

:function:::address_word:do_eret:int nc, address_word nia
*micromips32r7:
*micromips64r7:
{
  if (SR & status_ERL)
    {
      /* Oops, not yet available */
      sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
      nia = EPC;
      SR &= ~status_ERL;
    }
  else
    {
      nia = EPC;
      SR &= ~status_EXL;
      //if ( SRSCtl.HSS > 0 && Status.BEV == 0)
      //  SRSCtl.CSS = SRSCtl.PSS
  }

  //TODO: clear LLbit for ERET
  //if (!nc)
  //  LLbit = 0;

  //TODO: ClearHazards()
  return NIA;
}

:%s::::GPR_LIST_SAVE16:int count
*micromips32r7:
*micromips64r7:
{
  if (count == 14 || count == 15 )
    return "";
  else
    return do_get_save_restore_gpr_list(SD_, 31, count, 0, 0);
}

:%s::::GPR_LIST_SAVE:int count
*micromips32r7:
*micromips64r7:
{
  return do_get_save_restore_gpr_list (SD_, -1, count, 0, 0);
}

:%s::::GP_SAVE:int gp
*micromips32r7:
*micromips64r7:
{
  return (gp > 0) ? ",gp" : "";
}

:%s::::FP_SAVE:int fp
*micromips32r7:
*micromips64r7:
{
  return (fp > 0) ? ",fp" : "";
}

:%s::::RT_SAVE:int rt
*micromips32r7:
*micromips64r7:
{
  if (rt >= 16 && rt <= 23)
    {
      char str[4];
      sprintf(str, ",s%d", rt-16);
      return str;
    }
  else if (rt == 28)
    return ",gp";
  else if (rt == 30)
    return ",fp";
  else if (rt == 31)
    return ",ra";

  return "";
}

00000000000000000000000000000000:R7DUMMY:32,f::DUMMY0.fmt
"dummy 0"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds */
}

00000000000000000000000000000001:R7DUMMY:32,f::DUMMY1.fmt
"dummy 1"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds (needs at least 2 instructions) */
}

001000,5.RT,5.RS,5.RD,0,1001010,000:R7POOL32A0:32::AND
"and r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1010010,000:R7POOL32A0:32::OR
"or r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1100010,000:R7POOL32A0:32::XOR
"xor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1011010,000:R7POOL32A0:32::NOR
"nor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0010,12.U:R7PU12:32::ANDI
"andi r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, RS, RT, U);
}

100000,5.RT,5.RS,0000,12.U:R7PU12:32::ORI
"ori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_ori (SD_, RS, RT, U);
}

100000,5.RT,5.RS,0001,12.U:R7PU12:32::XORI
"xori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_xori (SD_, RS, RT, U);
}

010100,3.RT,3.RS,10,0,0:R7POOL16C00:16::AND16
"and r<TRT>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, TRS, TRT, TRT);
}

010100,3.RD,3.RS,11,0,0:R7POOL16C00:16::OR16
"or r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, TRS, TRD, TRD);
}

101100,3.RT,3.RS,3.RD,0:R7P16ADDU:16::ADDU16
"addu r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, TRS, TRT, TRD);
}

001000,5.RT,5.RS,5.RD,0,0101010,000:R7POOL32A0:32::ADDU
"addu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, RS, RT, RD);
}

101100,3.RT,3.RS,3.RD,1:R7P16ADDU:16::SUBU16
"subu r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  do_subu (SD_, TRS, TRT, TRD);
}

001000,5.RT,5.RS,5.RD,0,0111010,000:R7POOL32A0:32::SUBU
"subu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_subu (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,0110011,000:R7POOL32A0:32::DIVU
"divu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_divu (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0100011,000:R7POOL32A0:32::DIV
"div r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_div (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,0000101,100,111,111:R7POOL32A0:32::BITSWAP
"bitswap r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_bitswap (SD_, RT, RS);
}

001000,5.RT,5.RS,5.RD,2.IMMEDIATE,000,011,111:R7POOL32A0:32::ALIGN
"align r<RD>, r<RS>, r<RT>, <IMMEDIATE>"
*micromips32r7:
*micromips64r7:
{
  do_align (SD_, RD, RS, RT, IMMEDIATE);
}

010110,5.RS,0,0000:R7P16JRC:16::JRC16
"jrc r<TRS>"
*micromips32r7:
*micromips64r7:
{
  NIA = process_isa_mode (SD_, GPR[TRS]);
}

010110,5.RS,1,0000:R7P16JRC:16::JALRC16
"jalrc r<TRS>"
*micromips32r7:
*micromips64r7:
{
  RA = NIA | ISA_MODE_MICROMIPS;
  NIA = process_isa_mode (SD_, GPR[TRS]);
}

010100,3.RT,3.RS,01,0,0:R7POOL16C00:16::XOR16
"xor r<TRT>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, TRS, TRT, TRT);
}

010100,3.RT,3.RS,00,0,0:R7POOL16C00:16::NOT16
"not r<TRT>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, 0, TRS, TRT);
}

111100,3.RT,3.RS,4.EU:R7ANDI16:16::ANDI16
"andi r<TRT>, r<TRS>, <EU_12_13>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, TRS, TRT, EU_12_13);
}

001100,3.RD,3.RS,0,3.SHIFT:P16SHIFT:16::SLL16
"sll r<TRD>, r<TRS>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  do_sll (SD_, TRS, TRD, SHIFT_DEC);
}

001100,3.RD,3.RS,1,3.SHIFT:P16SHIFT:16::SRL16
"srl r<TRD>, r<TRS>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  do_srl (SD_, TRS, TRD, SHIFT_DEC);
}

000100,5.RT!0,5.RS:R7P16MOVE:16::MOVE
"move r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_p16move (SD_, RT, RS);
}

100110,3.RS,6.S1,1.S2:R7BEQZC16:16::BEQZC16
"beqzc r<TRS>, <ADDRESS8>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_beqzc (SD_, TRS, EXTEND8 (ADDRESS8), NIA);
}

101110,3.RS,6.S1,1.S2:R7BNEZC16:16::BNEZC16
"bnezc r<TRS>, <ADDRESS8>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bnezc (SD_, TRS, EXTEND8 (ADDRESS8), NIA);
}

000101,3.RT,3.RS,00,2.U:R7P16LB:16::LB16
"lb r<TRT>, <U>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[TRS], U));
}

000101,3.RT,3.RS,10,2.U:R7P16LB:16::LBU16
"lbu r<TRT>, <U>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = do_load (SD_, AccessLength_BYTE, GPR[TRS], U);
}

001101,3.RT,3.RS,0,2.U,0:R7P16LH:16::LH16
"lh r<TRT>, <U_SHIFT_1BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[TRS],
                                U_SHIFT_1BIT));
}

001101,3.RT,3.RS,1,2.U,0:R7P16LH:16::LHU16
"lhu r<TRT>, <U_SHIFT_1BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = do_load (SD_, AccessLength_HALFWORD, GPR[TRS], U_SHIFT_1BIT);
}

110100,3.RT,7.EU:R7LI16:16::LI16
"li r<TRT>, <EU_127>"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EU_127;
}

100101,1.RT1,1.U2,3.RT2,1.RS1,1.U3,3.RS2:R7LW4X4:16::LW4X4
"lw r<RT_5_BIT>, <U_LW4X4>(r<RS_5_BIT>)"
*micromips32r7:
*micromips64r7:
{
  GPR[RT_5_BIT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[RS_5_BIT],
                                     U_LW4X4));
}

011101,3.RT,3.RS,4.U:R7LW16:16::LW16
"lw r<TRT>, <U_SHIFT_2BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[TRS],
                                U_SHIFT_2BIT));
}

101101,3.RT,7.U:R7LWGP16:16::LWGP16
"lw r<TRT>, <U_SHIFT_2BIT>(gp)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[28],
                                U_SHIFT_2BIT));
}

010101,5.RT,5.U:R7LWSP:16::LWSP
"lw r<RT>, <U_SHIFT_2BIT>(sp)"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, SP, U_SHIFT_2BIT));
}

010100,3.RT,3.RS,3.RD,1:R7POOL16C_0:16::LWXS16
"lwxs r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  GPR[TRD] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[TRS] << 2,
                                GPR[TRT]));
}

111000,5.RT,9.S1,10.S2,1,1.S3:R7PAUIPC:32::AxUIPC
"auipc r<RT>, <AXUIPC_S_HI>":RT != 0 && AXUIPC_S_LO==0
"aluipc r28, <AXUIPC_S_HI>":RT == 0 && AXUIPC_S_LO==0
"auipc r<RT>, <AXUIPC_S_HI>, <AXUIPC_S_LO>":RT != 0
"aluipc r28, <AXUIPC_S_HI>, <AXUIPC_S_LO>"
*micromips32r7:
*micromips64r7:
{
  do_pauipc(SD_, RT, AXUIPC_S);
}

001000,5.RT,5.RS,0100101,100,111,111:R7POOL32A0:32::CLO
"clo r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_clo (SD_, RT, RS);
}

001000,5.RT,5.RS,0101101,100,111,111:R7POOL32A0:32::CLZ
"clz r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_clz (SD_, RT, RS);
}

101111,1.RT4,1.RD20,3.RT2_0,1.RS4,1.RD21,3.RS2_0:R7MOVEP:16::MOVEP
"movep r<TRD2>, r<TRE2>, r<TRS2>, r<TRT2>"
*micromips32r7:
*micromips64r7:
{
  GPR[TRD2] = GPR[TRS2];
  GPR[TRE2] = GPR[TRT2];
}

000101,3.RTZ,3.RS,01,2.U:R7P16LB:16::SB16
"sb r<TRTZ>, <U>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GPR[TRS], U, zero_extend(SD_, GPR[TRTZ],
                                                             8));
}

001101,3.RTZ,3.RS,0,2.U,1:R7P16LH:16::SH16
"sh r<TRTZ>, <U_SHIFT_1BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[TRS], U_SHIFT_1BIT,
            zero_extend(SD_, GPR[TRTZ], 16));
}

111101,3.RTZ,3.RS,4.U:R7SW16:16::SW16
"sw r<TRTZ>, <U_SHIFT_2BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[TRS], U_SHIFT_2BIT,
            zero_extend(SD_, GPR[TRTZ], 32));
}

101001,5.RT,5.RS,1.S1,1001000,8.S2:R7SWS9:32::SWS9
"sw r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[RS], EXTEND9 (S_9_BIT),
	    zero_extend(SD_, GPR[RT], 32));
}

100001,5.RT,5.RS,1001,12.U:R7SW:32::SW
"sw r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[RS], U, GPR[RT]);
}

110101,5.RT,5.U:R7SWSP:16::SWSP
"sw r<RT>, <U_SHIFT_2BIT>(sp)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, SP, U_SHIFT_2BIT, zero_extend(SD_, GPR[RT],
                                                                  32));
}

010000,5.RT,19.U,11:R7SWGP:32::SWGP
"sw r<RT>, <U_SHIFT_2BIT>(gp)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GP, U_SHIFT_2BIT, GPR[RT]);
}

001110,9.S1,1.S2:R7BALC16:16::BALC16
"balc <ADDRESS11>"
*micromips32r7:
*micromips64r7:
{
  RA = NIA | isa_mode;
  NIA = ADDRESS11;
}

000010,1,24.S1,1.S2:R7PBAL:32::BALC
"balc <ADDRESS26>"
*micromips32r7:
*micromips64r7:
{
  RA = NIA | isa_mode;
  NIA = ADDRESS26;
}

000110,9.S1,1.S2:R7BC16:16::BC16
"bc <ADDRESS11>"
*micromips32r7:
*micromips64r7:
{
  NIA = ADDRESS11;
}

000010,0,24.S1,1.S2:R7PBAL:32::BC
"bc <ADDRESS26>"
*micromips32r7:
*micromips64r7:
{
  NIA = ADDRESS26;
}

101010,5.RT,0,19.S1,1.S2:R7PBZ:32::BEQZC
"beqzc r<RT>, <ADDRESS21>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_beqzc (SD_, RT, EXTEND21 (ADDRESS21), NIA);
}

101010,5.RT!0,1,19.S1,1.S2:R7PBZ:32::BNEZC
"bnezc r<RT>, <ADDRESS21>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bnezc (SD_, RT, EXTEND21 (ADDRESS21), NIA);
}

010110,3.RT,3.RS,4.U!0:R7P16BR1:16::BxxxC16
"beqc r<TRS>, r<TRT>, <U_SHIFT_1BIT>":RS<RT
"bnec r<TRS>, r<TRT>, <U_SHIFT_1BIT>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bxxxc16 (SD_, TRS, TRT, U_SHIFT_1BIT, NIA);
}

111010,5.RT,5.RS,00,13.S1,1.S2:R7PBR2:32::BNEC
"bnec r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  if (GPR[RS] != GPR[RT])
    NIA = NIA + EXTEND15 (ADDRESS15);
}

110010,5.RT,5.RS,00,13.S1,1.S2:R7PBR2:32::BEQC
"beqc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  if (GPR[RS] == GPR[RT])
    NIA = NIA + EXTEND15 (ADDRESS15);
}

100000,5.RT,5.RS,1110,0,5.MSBD,0,5.LSB:R7PINS:32::INS
"ins r<RT>, r<RS>, <INS_POS>, <INS_SIZE>"
*micromips32r7:
*micromips64r7:
{
  do_ins_mm_r7 (SD_, RT, RS, INS_POS, INS_SIZE);
}

100010,5.RT,5.RS,0000,12.OFFSET:R7PJ:32::JIALC
"jrc r<RS>": RT==31 && OFFSET==0
"jalrc r<RS>": RT==31 && OFFSET==0
"jalrc r<RT>, r<RS>": OFFSET==0
"jialc r<RS>, <OFFSET>": RT==31
"jialc r<RT>, r<RS>, <OFFSET>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_jialc_mm_r7 (SD_, RT, RS, OFFSET, NIA);
}

010010,5.RT,000,7.U,10.S1,1.S2:P7PBRI:32::BEQIC
"beqic r<RT>, <U>, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if (GPR[RT] == U) {
    NIA = P7PBRI_ADDRESS;
  }
}

111010,5.RT,5.RS,10,13.S1,1.S2:P7PBR1:32::BLTC
"bltc r<RS>, r<RT>, <P7PBR1_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
    NIA = P7PBR1_ADDRESS;
}

110010,5.RT,5.RS,10,13.S1,1.S2:P7PBR1:32::BGEC
"bgec r<RS>, r<RT>, <P7PBR1_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
    NIA = P7PBR1_ADDRESS;
}

010010,5.RT,010,7.U,10.S1,1.S2:P7PBRI:32::BGEIC
"bgeic r<RT>, <U>, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((signed_word) GPR[RT] >= U) {
    NIA = P7PBRI_ADDRESS;
  }
}

111010,5.RT,5.RS,11,13.S1,1.S2:P7PBR2:32::BLTUC
"bltuc r<RS>, r<RT>, <P7PBR1_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT]) {
    NIA = P7PBR1_ADDRESS;
  }
}

110010,5.RT,5.RS,11,13.S1,1.S2:P7PBR2:32::BGEUC
"bgeuc r<RS>, r<RT>, <P7PBR1_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((unsigned_word) (GPR[RS]) >= (unsigned_word)(GPR[RT])) {
    NIA = P7PBR1_ADDRESS;
  }
}

010010,5.RT,011,7.U,10.S1,1.S2:P7PBRI:32::BGEUIC
"bgeuic r<RT>, <U>, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((unsigned_word) GPR[RT] >= U) {
    NIA = P7PBRI_ADDRESS;
  }
}

010010,5.RT,110,7.U,10.S1,1.S2:P7PBRI:32::BLTIC
"bltic r<RT>, <U>, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((signed_word) GPR[RT] < U) {
    NIA = P7PBRI_ADDRESS;
  }
}

010010,5.RT,111,7.U,10.S1,1.S2:P7PBRI:32::BLTUIC
"bltuic RT, U, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((unsigned_word) GPR[RT] < U) {
    NIA = P7PBRI_ADDRESS;
  }
}

010010,5.RT,100,7.U,10.S1,1.S2:P7PBRI:32::BNEIC
"bneic RT, U, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if (GPR[RT] != U) {
    NIA = P7PBRI_ADDRESS;
  }
}

000000,5.RT!0,5.RS,1.S1,00,13.S2:R7PPADDIU:32::ADDIU
"addiu r<RT>, r<RS>, <S_14_BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[RS]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], S_14_BIT);
  GPR[RT] = EXTEND32 (GPR[RS] + S_14_BIT);
  TRACE_ALU_RESULT (GPR[RT]);
}

010000,5.RT,19.U,00:R7PGPREL:32::ADDIUGP
"addiu r<RT>, GP, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[GPIDX]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[GPIDX], U_SHIFT_2BIT);
  GPR[RT] = GPR[GPIDX] + U_SHIFT_2BIT;
  TRACE_ALU_RESULT (GPR[RT]);
}

011100,3.RT,1,6.U:R7P16ADDIU1:16::ADDIUR1SP
"addiu r<TRT>, SP, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[SPIDX]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[SPIDX], U_SHIFT_2BIT);
  GPR[TRT] = EXTEND32 (GPR[SPIDX] + U_SHIFT_2BIT);
  TRACE_ALU_RESULT (GPR[TRT]);
}

100100,3.RT,3.RS,0,3.U:R7P16ADDIU2:16::ADDIUR2
"addiu r<TRT>, r<TRS>, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[TRS]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[TRS], U_SHIFT_2BIT);
  GPR[TRT] = EXTEND32 (GPR[TRS] + U_SHIFT_2BIT);
  TRACE_ALU_RESULT (GPR[TRT]);
}

100100,5.RT,1.S1,1,3.S2:R7P16ADDIU2:16::ADDIURS5
"nop":RT==0
"addiu r<RT>, <S_4_BIT>"
*micromips32r7:
*micromips64r7:
{
  if (RT != 0)
  {
    if (NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RT], S_4_BIT);
    GPR[RT] = EXTEND32 (GPR[RT] + S_4_BIT);
    TRACE_ALU_RESULT (GPR[RT]);
  }
}

001000,5.RT,00000,01,00011,101,111,111:R7POOL32A0:32::DI
"di":RT == 0
"di r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_di (SD_, RT);
}

001000,5.RT,00000,01,01011,101,111,111:R7POOL32A0:32::EI
"ei":RT == 0
"ei r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_ei (SD_, RT);
}

101001,5.OP,5.RS,1.S1,0011001,8.S2:R7PLSS1:32::CACHE
"cache <OP>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  address_word vaddr;
  address_word paddr;
  int uncached;
  vaddr = loadstore_ea (SD_, GPR[RS], EXTEND9 (S_9_BIT));
  if (AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET,
                          isREAL))
    CacheOp (OP, vaddr, paddr, instruction_0);
}

011010,1.RT1,1.RD,3.RT2,20.S1,1.S2:R7MOVEBALC:32::MOVE.BALC
"move.balc r<RD1>, r<RT_5_BIT>, <ADDRESS22>"
*micromips32r7:
*micromips64r7:
{
  GPR[RD1] = GPR[RT_5_BIT];
  RA = NIA | isa_mode;
  NIA = ADDRESS22;
}

100010,5.RT,5.RS,0001,12.U:R7PJ:32::JIALC.HB
"jalrc.hb r<RS>":RT==31&&U==0
"jalrc.hb r<RT>, r<RS>":U==0
"jialc.hb r<RS>, <U>":RT==31
"jialc.hb r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_jialc_mm_r7 (SD_, RT, RS, U, NIA);
  //TODO: ClearHazards()?
}

100000,5.RT,5.RS,11110,5.MSBD,0,5.LSB:R7PEXT:32::EXT
"ext r<RT>, r<RS>, <LSB>, <MSBD+1>"
*micromips32r7:
*micromips64r7:
{
  if (LSB + MSBD + 1 > 32)
    Unpredictable ();

  TRACE_ALU_INPUT3 (GPR[RS], LSB,  MSBD + 1);
  GPR[RT] = EXTEND32 (zero_extend(SD_, GPR[RS] >> LSB, MSBD + 1));
  TRACE_ALU_RESULT1 (GPR[RT]);
}

000111,4.GPR_LIST_SAVE16,0,4.U,0:R7P16SRW:16::SAVE16
"save %s<GPR_LIST_SAVE16>, <U_SHIFT_3BIT>"
*micromips32r7:
*micromips64r7:
{
  if (GPR_LIST_SAVE16==14 || GPR_LIST_SAVE16==15)
    do_save_gprs_to_stack_and_adjust_sp(SD_, -1, 0, 0, 0, U_SHIFT_3BIT);
  else
    do_save_gprs_to_stack_and_adjust_sp(SD_, 31, GPR_LIST_SAVE16, 0, 0,
                                        U_SHIFT_3BIT);
}

100000,5.RT_SAVE,4.GPR_LIST_SAVE,0,0011,9.U,0,1.FP_SAVE,1.GP_SAVE:R7PSR:32::SAVE
"save %s<GPR_LIST_SAVE>%s<GP_SAVE>%s<FP_SAVE>%s<RT_SAVE>, <U_SHIFT_3BIT>"
*micromips32r7:
*micromips64r7:
{
  do_save_gprs_to_stack_and_adjust_sp(SD_, RT_SAVE, GPR_LIST_SAVE, FP_SAVE,
                                      GP_SAVE, U_SHIFT_3BIT);
}

000111,4.GPR_LIST_SAVE16,1,4.U,0:R7PRESTORE16:16::RESTORE16
"restore <U_SHIFT_3BIT>":GPR_LIST_SAVE16==15
"restore.jrc %s<GPR_LIST_SAVE16>, <U_SHIFT_3BIT>"
*micromips32r7:
*micromips64r7:
{
  if (GPR_LIST_SAVE16==14 || GPR_LIST_SAVE16==15)
    do_restore_gprs_from_stack_and_adjust_sp(SD_, -1, 0, 0, 0, U_SHIFT_3BIT);
  else
    do_restore_gprs_from_stack_and_adjust_sp(SD_, 31, GPR_LIST_SAVE16, 0, 0,
                                             U_SHIFT_3BIT);

  isa_mode =  GPR[RAIDX] & 0x1;
  NIA = GPR[RAIDX] & (-1 << 1);
}

100000,5.RT_SAVE,4.GPR_LIST_SAVE,10011,9.U,0,1.FP_SAVE,1.GP_SAVE:R7PRESTORE:32::RESTORE
"restore %s<GPR_LIST_SAVE>%s<GP_SAVE>%s<FP_SAVE>%s<RT_SAVE>, <U_SHIFT_3BIT>"
*micromips32r7:
*micromips64r7:
{
  do_restore_gprs_from_stack_and_adjust_sp(SD_, RT_SAVE, GPR_LIST_SAVE, FP_SAVE,
                                           GP_SAVE, U_SHIFT_3BIT);
}

100000,5.RT_SAVE,4.GPR_LIST_SAVE,10011,9.U,1,1.FP_SAVE,1.GP_SAVE:R7PRESTORE:32::RESTORE.JRC16
"restore.jrc %s<GPR_LIST_SAVE>%s<GP_SAVE>%s<FP_SAVE>%s<RT_SAVE>, <U_SHIFT_3BIT>"
*micromips32r7:
*micromips64r7:
{
  do_restore_gprs_from_stack_and_adjust_sp(SD_, RT_SAVE, GPR_LIST_SAVE, FP_SAVE,
                                           GP_SAVE, U_SHIFT_3BIT);

  isa_mode =  GPR[RAIDX] & 0x1;
  NIA = GPR[RAIDX] & (-1 << 1);
}

001000,000000000,0,11,11001,101,111,111:R7POOL32A0:32::ERET
"eret"
*micromips32r7:
*micromips64r7:
{
  //TODO: signal coprocessor_exception(0) if !IsCoprocessor0Enabled()
  NIA = do_eret(SD_, 0, NIA);
}

001000,000000000,1,11,11001,101,111,111:R7POOL32A0:32::ERETNC
"eretnc"
*micromips32r7:
*micromips64r7:
{
  //TODO: signal coprocessor_exception(0) if !IsCoprocessor0Enabled()
  NIA = do_eret(SD_, 1, NIA);
}

000000,00000,10,19.CODE:R7PRI:32::BREAK
"break %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  do_break (SD_, instruction_0);
}

000000,00000,11,19.CODE:R7PRI:32::SDBBP
"sdbbp %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (DebugBreakPoint, instruction_0);
}

111000,5.RT,9.S1,10.S2,0,1.S3:R7PLUI:32::LUI
"lui r<RT>, <AXUIPC_S>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2 (GPR[0], AXUIPC_S);
  GPR[RT] = EXTEND32 (GPR[0] + EXTEND32(AXUIPC_S));
  TRACE_ALU_RESULT (GPR[RT]);
}

100001,5.RT,5.RS,0000,12.U:R7PLSU12:32::LB
"lb r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lb (SD_, RT, U, RS);
}

010001,5.RT,000,18.U:R7PLSGP:32::LBGP
"lb r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GP, U));
}

100001,5.RT,5.RS,0010,12.U:R7PLSU12:32::LBU
"lbu r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lbu (SD_, RT, U, RS);
}

010001,5.RT,010,18.U:R7PLSGP:32::LBUGP
"lbu r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = do_load (SD_, AccessLength_BYTE, GP, U);
}

100001,5.RT,5.RS,0100,12.U:R7PLSU12:32::LH
"lh r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lh (SD_, RT, U, RS);
}

010001,5.RT,100,18.U:R7PLSGP:32::LHGP
"lh r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GP, U));
}

100001,5.RT,5.RS,0110,12.U:R7PLSU12:32::LHU
"lhu r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lhu (SD_, RT, U, RS);
}

010001,5.RT,110,18.U:R7PLSGP:32::LHUGP
"lhu r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = do_load (SD_, AccessLength_HALFWORD, GP, U);
}

100001,5.RT,5.RS,1000,12.U:R7PLSU12:32::LW
"lw r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RT, U, RS);
}

101001,5.RT,5.RS,1.S1,1000000,8.S2:R7SWS9:32::LWS9
"lw r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RT, EXTEND9 (S_9_BIT), RS);
}

010000,5.RT,19.U,10:R7LWGP:32::LWGP
"lw r<RT>, <U_SHIFT_2BIT>(gp)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RT, U_SHIFT_2BIT, GPIDX);
}

100001,5.RT,5.RS,0101,12.U:R7PLSU12:32::SH
"sh r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[RS], EXTEND16 (U),
      GPR[RT]);
}

010001,5.RT,101,18.U:R7PLSGP:32::SHGP
"sh r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GP, U, GPR[RT]);
}

100001,5.RT,5.RS,0001,12.U:R7PLSU12:32::SB
"sb r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GPR[RS], EXTEND16 (U), GPR[RT]);
}

010001,5.RT,001,18.U:R7PLSGP:32::SBGP
"sb r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GP, U, GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0,1101010,000:R7POOL32A0:32::SLT
"slt r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_slt (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1110010,000:R7POOL32A0:32::SLTU
"sltu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_sltu (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,11000000000,5.SHIFT:R7PSHIFT:32::SLL
"sll r<RT>, r<RS>, #<SHIFT>"
*micromips32r7:
*micromips64r7:
{
  do_sll (SD_, RS, RT, SHIFT);
}

100000,5.RT,5.RS,11000000010,5.SHIFT:R7PSHIFT:32::SRL
"srl r<RT>, r<RS>, #<SHIFT>"
*micromips32r7:
*micromips64r7:
{
  do_srl (SD_, RS, RT, SHIFT);
}

100000,5.RT,5.RS,11000000100,5.SHIFT:R7PSHIFT:32::SRA
"sra r<RT>, r<RS>, #<SHIFT>"
*micromips32r7:
*micromips64r7:
{
  do_sra (SD_, RS, RT, SHIFT);
}

001000,5.RT,5.RS,5.RD,0,0000010,000:R7POOL32A0:32::SLLV
"sllv r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_sllv (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,0001010,000:R7POOL32A0:32::SRLV
"srlv r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_srlv (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,0010010,000:R7POOL32A0:32::SRAV
"srav r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_srav (SD_, RS, RT, RD);
}

001000,5.RS,5.RT,5.RD,0,1000010,000:R7POOL32A0:32::MOVZ
"movz r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_movz (SD_, RD, RS, RT);
}

100000,5.RT,5.RS,0101,12.U:R7PU12:32::SLTIU
"sltiu r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_sltiu (SD_, RS, RT, U);
}

001000,5.RT,5.RS,5.RD,1000,0,000,111:R7PPLSX:32::LWX
"lwx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  GPR[RD] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[RS], GPR[RT]));
}

001000,5.RT,5.RS,5.RD,0110,0,000,111:R7PPLSX:32::LHUX
"lhux r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  GPR[RD] = do_load (SD_, AccessLength_HALFWORD, GPR[RS], GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0100,0,000,111:R7PPLSX:32::LHX
"lhx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  GPR[RD] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[RS], GPR[RT]));
}

001000,5.RT,5.RS,5.RD,0010,0,000,111:R7PPLSX:32::LBUX
"lbux r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  GPR[RD] = do_load (SD_, AccessLength_BYTE, GPR[RS], GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0000,0,000,111:R7PPLSX:32::LBX
"lbx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  GPR[RD] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[RS], GPR[RT]));
}

001000,5.RT,5.RS,5.RD,1001,0,000,111:R7PPLSX:32::SWX
"swx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[RT], GPR[RS], GPR[RD]);
}

001000,5.RT,5.RS,5.RD,0101,0,000,111:R7PPLSX:32::SHX
"shx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[RT], GPR[RS], GPR[RD]);
}

001000,5.RT,5.RS,5.RD,0001,0,000,111:R7PPLSX:32::SBX
"sbx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GPR[RT], GPR[RS], GPR[RD]);
}

001000,5.RT,5.RS,5.RD,0,0000011,000:R7POOL32A0:32::MUL
"mul r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_mul (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0001011,000:R7POOL32A0:32::MUH
"muh r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_muh (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0010011,000:R7POOL32A0:32::MULU
"mulu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_mulu (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0011011,000:R7POOL32A0:32::MUHU
"muhu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_muhu (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,2.U,000,001,111:R7POOL32A7:32::LSA
"lsa r<RD>, r<RS>, r<RT>, <U + 1>"
*micromips32r7:
*micromips64r7:
{
  do_lsa (SD_, RD, RS, RT, U);
}

001000,5.RT,5.RS,0111101,100,111,111:R7POOL32A0:32::WSBH
"wsbh r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_wsbh (SD_, RT, RS);
}

100000,5.RT,5.RS,1100,000,0110,5.SHIFT:R7PSHIFT:32::ROTR
"rotr r<RT>, r<RS>, <SHIFT>"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = do_ror (SD_, GPR[RS], SHIFT);
}

001000,5.RT,5.RS,5.RD,0,0011010,000:R7POOL32A0:32::ROTRV
"rotrv r<RD>, r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  GPR[RD] = do_ror (SD_, GPR[RT], GPR[RS]);
}

101001,5.RT,5.RS,1.S1,1001,0,01,6.S2,00:R7PSC:32::SC
"sc r<RT>, <S_7_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_sc (SD_, RT, S_7_BIT, RS, instruction_0);
}

101001,5.RT,5.RS,1.S1,1000,0,01,6.S2,00:R7PLL:32::LL
"ll r<RT>, <S_7_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_ll (SD_, RT, S_7_BIT, RS);
}

001000,5.RT,5.RS,5.RD,00110010,000:R7POOL32A0:32::SUB
"sub r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_sub (SD_, RD, RS, RT);
}

000100,00000,10,3.CODE:R7P16RI:16::BREAK16
"break16 %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  do_break (SD_, instruction_0);
}

000100,00000,11,3.CODE:R7P16RI:16::SDBBP16
"sdbbp16 %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (DebugBreakPoint, instruction_0);
}

001000,5.RT,5.RS,5.RD,00100010000:R7POOL32A0:32::ADD
"add r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_add (SD_, RS, RT, RD);
}

101001,5.RT,5.RS,1.S1,0000000,8.S2:R7PLSS0:32::LBS9
"lb r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lb (SD_, RT, S_9_BIT, RS);
}

101001,5.RT,5.RS,1.S1,0010,0,00,8.S2:R7PLSS0:32::LBUS9
"lbu r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lbu (SD_, RT, S_9_BIT, RS);
}

101001,5.RT,5.RS,1.S1,0100,0,00,8.S2:R7PLSS0:32::LHS9
"lh r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lh (SD_, RT, S_9_BIT, RS);
}

101001,5.RT,5.RS,1.S1,0110,0,00,8.S2:R7PLSS0:32::LHUS9
"lhu r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lhu (SD_, RT, S_9_BIT, RS);
}

101001,5.HINT!31,5.RS,1.S1,0011,0,00,8.S2:R7PPREFS:32::PREFS9
"pref <HINT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_pref (SD_, HINT, EXTEND12 (S_9_BIT), RS);
}

101001,5.RT,5.RS,1.S1,0001,0,00,8.S2:R7PLSS0:32::SBS9
"sb r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GPR[RS], EXTEND16 (S_9_BIT), GPR[RT]);
}

101001,5.RT,5.RS,1.S1,0101,0,00,8.S2:R7PLSS0:32::SHS9
"sh r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[RS], EXTEND16 (S_9_BIT),
      GPR[RT]);
}

000000,00000,00,19.CODE:R7PRI:32::SIGRIE
"sigrie %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (ReservedInstruction, instruction_0);
}

101001,11111,5.RS,1.S1,0011,0,00,8.S2:R7PPREFS:32::SYNCIS9
"synci <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  // sync i-cache - nothing to do currently
}

001000,0000000000,01,00001,101,111,111:R7POOL32AXF5GROUP1:32::TLBINV
"tlbinv"
*micromips32r7:
*micromips64r7:
{
  // invalidate a set of TLB entries based on ASID and Index match - nothing to do currently
}

001000,0000000000,01,01001,101,111,111:R7POOL32AXF5GROUP1:32::TLBINVF
"tlbinvf"
*micromips32r7:
*micromips64r7:
{
  // invalidate a set of TLB entries based on Index match - nothing to do currently
}

001000,5.RT,5.RS,5.RD,1000,1,000,111:R7PPLSXS:32::LWXS
"lwxs r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lwxs (SD_, RD, RS, RT);
}

001000,10.CODE,10,00101,101,111,111:POOL32AXF5GROUP2:32::SYSCALL
"syscall %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (SystemCall, instruction_0);
}
