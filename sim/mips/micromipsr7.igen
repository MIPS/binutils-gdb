// Simulator definition for the micromips ASE.
// Copyright (C) 2005-2014 Free Software Foundation, Inc.
// Contributed by Imagination Technologies, Ltd.
// Written by Ali Lown <ali.lown@imgtec.com>
//
// This file is part of GDB, the GNU debugger.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

:compute:::int:U_SHIFT_1BIT:U:(U << 1)
:compute:::int:U_SHIFT_2BIT:U:(U << 2)
:compute:::int:U_SHIFT_3BIT:U:(U << 3)
:compute:::int:EU_127:EU:((EU == 127) ? -1 \: EU)
:compute:::int:U_LW4X4:U2,U3:((U3 << 3) | (U2 << 2))
:compute:::int:AXUIPC_S_LO:S1,S2,S3:((EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12))) & 0x0000ffff)
:compute:::int:AXUIPC_S_HI:S1,S2,S3:((EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12))) & 0xffff0000)
:compute:::int:AXUIPC_S:S1,S2,S3:(EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12)))
:compute:::int:TRD2:RD20,RD21:(compute_gpr2_dest1_reg (SD_, (RD21 << 1 | RD20)))
:compute:::int:TRE2:RD20,RD21:(compute_gpr2_dest2_reg (SD_, (RD21 << 1 | RD20)))
:compute:::int:TRS2:RS4,RS2_0:((RS4 << 4) | RS2_0)
:compute:::int:TRT2:RT4,RT2_0:((RT4 << 4) | RT2_0)
:compute:::address_word:ADDRESS8:S1,S2:(nia + EXTEND8((S2 << 7) | (S1 << 1)))
:compute:::address_word:ADDRESS11:S1,S2:(nia + EXTEND11((S2 << 10) | (S1 << 1)))
:compute:::address_word:ADDRESS15:S1,S2:(nia + EXTEND15((S2 << 14) | (S1 << 1)))
:compute:::address_word:ADDRESS21:S1,S2:(nia + EXTEND21((S2 << 20) | (S1 << 1)))
:compute:::address_word:ADDRESS22:S1,S2:(nia + EXTEND22((S2 << 21) | (S1 << 1)))
:compute:::address_word:ADDRESS26:S1,S2:(nia + EXTEND26((S2 << 25) | (S1 << 1)))
:compute:::int:INS_POS:LSB:(LSB)
:compute:::int:INS_SIZE:LSB,MSBD:(1 + MSBD - LSB)
:compute:::address_word:ADDRESS12:S1,S2:(nia + EXTEND12(S2 << 11 | S1 << 1))
:compute:::address_word:ADDRESS15:S1,S2:(nia + EXTEND15(S2 << 14 | S1 << 1))
:compute:::int:S_14_BIT:S1,S2:(EXTEND14 ((S1 << 13) | S2))
:compute:::int:S_4_BIT:S1,S2:(EXTEND4((S1 << 3) | S2))
:compute:::int:S_9_BIT:S1,S2:(EXTEND9((S1 << 8) | S2))
:compute:::int:S_9_BIT_LLSC:S1,S2:(EXTEND9((S1 << 8) | (S2 << 2)))
:compute:::int:RD1:RD:(compute_gpr1_dest_reg (SD_, RD))
:compute:::int:RT_5_BIT:RT1,RT2:((RT1 << 4) | RT2)
:compute:::int:RS_5_BIT:RS1,RS2:((RS1 << 4) | RS2)
:compute:::int:TRTZ:RTZ:((RTZ == 1) ? 17 \: RTZ)
:compute:::int:EU_12_13:EU:((EU == 12) ? 255 \: ((EU == 13) ? 65535 \: EU))

:function:::unsigned32:compute_gpr2_dest1_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 4;
    case 1: return 5;
    case 2: return 6;
    case 3: return 7;
    default: return 4;
    }
}

:function:::unsigned32:compute_gpr2_dest2_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 5;
    case 1: return 6;
    case 2: return 7;
    case 3: return 4;
    default: return 5;
    }
}

:function:::address_word:do_bxxxc16:int rs, int rt, address_word offset, address_word nia
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[rs], GPR[rt]);
  if (rs < rt && GPR[rs] == GPR[rt])
    return nia + offset; //BEQC
  if (rs >= rt && GPR[rs] != GPR[rt])
    return nia + offset; //BNEC
  return nia;
}

:function:::void:do_ins_mm_r7:int rt, int rs, int pos, int size
{
  TRACE_ALU_INPUT4 (GPR[rt], GPR[rs], pos, size);
  if (size < 1)
    Unpredictable ();

  int merge_mask = ((1 << size) - 1) << pos;
  int result = GPR[rt] & ~merge_mask | (GPR[rs] << pos) & merge_mask;
  GPR[rt] = EXTEND32 (result);
  TRACE_ALU_RESULT1 (GPR[rt]);
}

:function:::unsigned32:compute_gpr1_dest_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 4;
    case 1: return 5;
    default: return 4;
    }
}

:function:::address_word:do_jalrc_mm_r7:int rt, int rs, unsigned16 offset, address_word nia
{
  rt = nia | isa_mode;
  unsigned_word address = do_load (SD_, AccessLength_WORD, GPR[rs], offset);
  isa_mode = address & 1;
  return address & ~1;
}

:function:::unsigned:zero_extend:signed_word value, unsigned32 from_nbits
{
  unsigned32 low_bits_mask = (1 << from_nbits) - 1;
  return value & low_bits_mask;
}

:function:::void:do_save_gprs_to_stack_and_adjust_sp: int first_gpr, int count, int fp, int gp, int offset
*micromips32r7:
*micromips64r7:
{
  unsigned_word va;

  int fp_pending;
  int gp_pending;
  int num_pending;
  int idx;

  fp_pending = fp || (count==9 && !gp);
  gp_pending = gp;
  num_pending = count;

  va = GPR[SPIDX];
  if (first_gpr >= 0 && first_gpr < 32)
    do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[first_gpr]);

  while (num_pending > 0)
    {
      if (fp_pending)
        {
          do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[30]);
          fp_pending = 0;
        }
      else if (gp_pending)
        {
          do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[GPIDX]);
          gp_pending = 0;
        }
      else
        {
          idx = 16 | (num_pending - 1);
          do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[idx]);
        }

        num_pending--;
    }

  GPR[SPIDX] -= offset;
}

:function:::void:do_restore_gprs_from_stack_and_adjust_sp: int first_gpr, int count, int fp, int gp, int offset
*micromips32r7:
*micromips64r7:
{
  unsigned_word va;

  int fp_pending;
  int gp_pending;
  int num_pending;
  int idx;

  fp_pending = fp || (count==9 && !gp);
  gp_pending = gp;
  num_pending = count;

  va = GPR[SPIDX] + offset;
  if (first_gpr >= 0 && first_gpr < 32)
    GPR[first_gpr] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));

  while (num_pending > 0)
    {
      if (fp_pending)
        {
          GPR[30] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
          fp_pending = 0;
        }
      else if (gp_pending)
        {
          GPR[GPIDX] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
          gp_pending = 0;
        }
      else
        {
          idx = 16 | (num_pending - 1);
          GPR[idx] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
        }
        num_pending--;
    }

  GPR[SPIDX] += offset;
}

:function:::address_word:do_eret:int nc, address_word nia
*micromips32r7:
*micromips64r7:
{
  if (SR & status_ERL)
    {
      /* Oops, not yet available */
      sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
      nia = EPC;
      SR &= ~status_ERL;
    }
  else
    {
      nia = EPC;
      SR &= ~status_EXL;
      //if ( SRSCtl.HSS > 0 && Status.BEV == 0)
      //  SRSCtl.CSS = SRSCtl.PSS
  }

  if (!nc)
    LLBIT = 0;

  //TODO: ClearHazards()
  return nia;
}

// op: 0 = NORMAL,  1 = EXTEND8, 2 = EXTEND16, 3 = EXTEND32
:function:::void:do_lxx_mmr7:int rd, int base, int index, int op
{
  TRACE_ALU_INPUT3(GPR[rd], GPR[index], GPR[base]);
  if (op == 0)
    GPR[rd] = do_load (SD_, AccessLength_BYTE, GPR[base], GPR[index]);
  else if (op == 1)
    GPR[rd] = EXTEND8 (do_load (SD_, AccessLength_HALFWORD, GPR[base],
                                GPR[index]));
  else if (op == 2)
    GPR[rd] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[base],
                                 GPR[index]));
  else if (op == 3)
    GPR[rd] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[base],
                                 GPR[index]));
  TRACE_ALU_RESULT(GPR[rd]);
}

:function:::void:do_lsa_mm_r7:int rd, int rs, int rt, unsigned immediate
{
  unsigned32 sum = (GPR[rs] << immediate) + GPR[rt];
  GPR[rd] = EXTEND32(sum);
  TRACE_ALU_RESULT (GPR[rd]);
}

:%s::::GPR_LIST_SAVE:int count
*micromips32r7:
*micromips64r7:
{
  int i;
  static char gpr_list[100];

  gpr_list[0] = '\0';

  i = 0;

  while (i<count)
    {
      char str1[3];
      sprintf(str1, "%d", i);

      if (i>0)
        strcat (gpr_list,", ");
      strcat (gpr_list,"s");
      strcat (gpr_list,str1);
      i++;
    }
  return (gpr_list);
  //return do_get_save_restore_gpr_list (SD_, -1, count, 0, 0);
}

:%s::::GP_SAVE:int gp
*micromips32r7:
*micromips64r7:
{
  return (gp > 0) ? "gp" : "";
}

:%s::::FP_SAVE:int fp
*micromips32r7:
*micromips64r7:
{
  return (fp > 0) ? "fp" : "";
}

:%s::::RT_SAVE:int rt
*micromips32r7:
*micromips64r7:
{
  if (rt >= 16 && rt <= 23)
  {
    char str[4];
    sprintf(str, "s%d", rt-16);
    return str;
  }
  else if (rt == 28)
    return "gp";
  else if (rt == 30)
    return "fp";
  else if (rt == 31)
    return "ra";
  else if (rt >= 0 && rt < 28)
  {
    char str[4];
    sprintf(str, "r%d", rt);
    return str;
  }

  return "";
}

00000000000000000000000000000000:R7DUMMY:32,f::DUMMY0.fmt
"dummy 0"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds */
}

00000000000000000000000000000001:R7DUMMY:32,f::DUMMY1.fmt
"dummy 1"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds (needs at least 2 instructions) */
}

011100,3.RT,1,6.U:R7P16ADDIU1:16::ADDIUR1SP
"addiu r<TRT>, SP, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[SPIDX]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[SPIDX], U_SHIFT_2BIT);
  GPR[TRT] = EXTEND32 (GPR[SPIDX] + U_SHIFT_2BIT);
  TRACE_ALU_RESULT (GPR[TRT]);
}

100100,3.RT,3.RS,0,3.U:R7P16ADDIU2:16::ADDIUR2
"addiu r<TRT>, r<TRS>, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[TRS]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[TRS], U_SHIFT_2BIT);
  GPR[TRT] = EXTEND32 (GPR[TRS] + U_SHIFT_2BIT);
  TRACE_ALU_RESULT (GPR[TRT]);
}

100100,5.RT,1.S1,1,3.S2:R7P16ADDIU2:16::ADDIURS5
"nop":RT==0
"addiu r<RT>, <S_4_BIT>"
*micromips32r7:
*micromips64r7:
{
  if (RT != 0)
  {
    if (NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RT], S_4_BIT);
    GPR[RT] = EXTEND32 (GPR[RT] + S_4_BIT);
    TRACE_ALU_RESULT (GPR[RT]);
  }
}

101100,3.RT,3.RS,3.RD,0:R7P16ADDU:16::ADDU16
"addu r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, TRS, TRT, TRD);
}

010100,3.RT,3.RS,10,0,0:R7POOL16C00:16::AND16
"and r<TRT>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, TRS, TRT, TRT);
}

111100,3.RT,3.RS,4.EU:R7ANDI16:16::ANDI16
"andi r<TRT>, r<TRS>, <EU_12_13>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, TRS, TRT, EU_12_13);
}

001110,9.S1,1.S2:R7BALC16:16::BALC16
"balc <ADDRESS11>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(RA);
  RA = NIA | isa_mode;
  NIA = ADDRESS11;
  TRACE_ALU_RESULT(RA);
}

000110,9.S1,1.S2:R7BC16:16::BC16
"bc <ADDRESS11>"
*micromips32r7:
*micromips64r7:
{
  NIA = ADDRESS11;
}

110110,3.RT,3.RS,4.U!0:R7P16BR1:16::BxxC16
"beqc r<TRS>, r<TRT>, <U_SHIFT_1BIT>":RS<RT
"bnec r<TRS>, r<TRT>, <U_SHIFT_1BIT>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bxxxc16 (SD_, TRS, TRT, U_SHIFT_1BIT, NIA);
}

100110,3.RT,6.S1,1.S2:R7BEQZC16:16::BEQZC16
"beqzc r<TRT>, <ADDRESS8>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[TRT]);
  if(GPR[TRT] == 0)
    NIA = ADDRESS8;
}

101110,3.RT,6.S1,1.S2:R7BNEZC16:16::BNEZC16
"bnezc r<TRT>, <ADDRESS8>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[TRT]);
  if(GPR[TRT] != 0)
    NIA = ADDRESS8;
}

000100,00000,10,3.CODE:R7P16RI:16::BREAK16
"break16 %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  do_break (SD_, instruction_0);
}

110110,5.RT,1,0000:R7P16JRC:16::JALRC16
"jalrc r<TRT>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(RA);
  RA = NIA | isa_mode;
  NIA = process_isa_mode (SD_, GPR[TRT]);
}

110110,5.RT,0,0000:R7P16JRC:16::JRC16
"jrc r<TRT>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[TRT]);
  NIA = process_isa_mode (SD_, GPR[TRT]);
}

000101,3.RT,3.RS,00,2.U:R7P16LB:16::LB16
"lb r<TRT>, <U>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[TRT], U, GPR[TRS]);
  GPR[TRT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[TRS], U));
  TRACE_ALU_RESULT(GPR[TRT]);
}

000101,3.RT,3.RS,10,2.U:R7P16LB:16::LBU16
"lbu r<TRT>, <U>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[TRT], U, GPR[TRS]);
  GPR[TRT] = do_load (SD_, AccessLength_BYTE, GPR[TRS], U);
  TRACE_ALU_RESULT(GPR[TRT]);
}

001101,3.RT,3.RS,0,2.U,0:R7P16LH:16::LH16
"lh r<TRT>, <U_SHIFT_1BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[TRT], U_SHIFT_1BIT, GPR[TRS]);
  GPR[TRT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[TRS],
                                U_SHIFT_1BIT));
  TRACE_ALU_RESULT(GPR[TRT]);
}

001101,3.RT,3.RS,1,2.U,0:R7P16LH:16::LHU16
"lhu r<TRT>, <U_SHIFT_1BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[TRT], U_SHIFT_1BIT, GPR[TRS]);
  GPR[TRT] = do_load (SD_, AccessLength_HALFWORD, GPR[TRS], U_SHIFT_1BIT);
  TRACE_ALU_RESULT(GPR[TRT]);
}

110100,3.RT,7.EU:R7LI16:16::LI16
"li r<TRT>, <EU_127>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[TRT]);
  GPR[TRT] = EU_127;
  TRACE_ALU_RESULT(GPR[TRT]);
}

100101,1.RT1,1.U2,3.RT2,1.RS1,1.U3,3.RS2:R7LW4X4:16::LW4X4
"lw r<RT_5_BIT>, <U_LW4X4>(r<RS_5_BIT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT_5_BIT], U_LW4X4, GPR[RS_5_BIT]);
  GPR[RT_5_BIT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[RS_5_BIT],
                                     U_LW4X4));
  TRACE_ALU_RESULT(GPR[RT_5_BIT]);
}

011101,3.RT,3.RS,4.U:R7LW16:16::LW16
"lw r<TRT>, <U_SHIFT_2BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[TRT], U_SHIFT_2BIT, GPR[TRS]);
  GPR[TRT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[TRS],
                                U_SHIFT_2BIT));
  TRACE_ALU_RESULT(GPR[TRT]);
}

101101,3.RT,7.U:R7LWGP16:16::LWGP16
"lw r<TRT>, <U_SHIFT_2BIT>(gp)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[TRT], U_SHIFT_2BIT, GP);
  GPR[TRT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[28],
                                U_SHIFT_2BIT));
  TRACE_ALU_RESULT(GPR[TRT]);
}

010101,5.RT,5.U:R7LWSP:16::LWSP
"lw r<RT>, <U_SHIFT_2BIT>(sp)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U_SHIFT_2BIT, SP);
  GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, SP, U_SHIFT_2BIT));
  TRACE_ALU_RESULT(GPR[RT]);
}

010100,3.RT,3.RS,3.RD,1:R7POOL16C_0:16::LWXS16
"lwxs r<TRD>, r<TRS>(r<TRT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[TRD], GPR[TRS], GPR[TRT]);
  GPR[TRD] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[TRT],
                                GPR[TRS] << 2));
  TRACE_ALU_RESULT(GPR[TRD]);
}

000100,5.RT!0,5.RS:R7P16MOVE:16::MOVE
"move r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2 (GPR[RT], GPR[RS]);
  GPR[RT] = GPR[RS];
  TRACE_ALU_RESULT2 (GPR[RT], GPR[RS]);
}

101111,1.RT4,1.RD20,3.RT2_0,1.RS4,1.RD21,3.RS2_0:R7MOVEP:16::MOVEP
"movep r<TRD2>, r<TRE2>, r<TRS2>, r<TRT2>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT4 (GPR[TRD2], GPR[TRE2], GPR[TRS2], GPR[TRT2]);
  GPR[TRD2] = GPR[TRS2];
  GPR[TRE2] = GPR[TRT2];
  TRACE_ALU_RESULT2 (GPR[TRD2], GPR[TRE2]);
}

010100,3.RT,3.RS,00,0,0:R7POOL16C00:16::NOT16
"not r<TRT>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, 0, TRS, TRT);
}

010100,3.RT,3.RS,11,0,0:R7POOL16C00:16::OR16
"or r<TRT>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, TRS, TRT, TRT);
}

000111,4.GPR_LIST_SAVE,1,4.U,0:R7PRESTORE16:16::RESTORE16
"restore <U_SHIFT_3BIT>":GPR_LIST_SAVE==15
"restore.jrc <U_SHIFT_3BIT>":GPR_LIST_SAVE==14
"restore.jrc <U_SHIFT_3BIT>, ra, fp, s0-s7":GPR_LIST_SAVE==9
"restore.jrc <U_SHIFT_3BIT>, ra, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  if (GPR_LIST_SAVE==14 || GPR_LIST_SAVE==15)
    do_restore_gprs_from_stack_and_adjust_sp(SD_, -1, 0, 0, 0, U_SHIFT_3BIT);
  else
    do_restore_gprs_from_stack_and_adjust_sp(SD_, 31, GPR_LIST_SAVE, 0, 0,
                                             U_SHIFT_3BIT);
  if (GPR_LIST_SAVE != 15) {
    isa_mode =  GPR[RAIDX] & 0x1;
    NIA = GPR[RAIDX] & ~1;
  }
}

000111,4.GPR_LIST_SAVE,0,4.U,0:R7P16SRW:16::SAVE16
"save <U_SHIFT_3BIT>": GPR_LIST_SAVE == 14 || GPR_LIST_SAVE == 15
"save <U_SHIFT_3BIT>, ra": GPR_LIST_SAVE == 0
"save <U_SHIFT_3BIT>, ra, fp, s0-s7": GPR_LIST_SAVE == 9
"save <U_SHIFT_3BIT>, ra, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  if (GPR_LIST_SAVE==14 || GPR_LIST_SAVE==15)
    do_save_gprs_to_stack_and_adjust_sp(SD_, -1, 0, 0, 0, U_SHIFT_3BIT);
  else
    do_save_gprs_to_stack_and_adjust_sp(SD_, 31, GPR_LIST_SAVE, 0, 0,
                                        U_SHIFT_3BIT);
}

000101,3.RTZ,3.RS,01,2.U:R7P16LB:16::SB16
"sb r<TRTZ>, <U>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3 (GPR[TRTZ], U, GPR[TRS]);
  do_store (SD_, AccessLength_BYTE, GPR[TRS], U,
            zero_extend(SD_, GPR[TRTZ], 8));
  int temp = do_load(SD_, AccessLength_BYTE, GPR[TRS], U);
  TRACE_ALU_RESULT(temp);
}

001101,3.RTZ,3.RS,0,2.U,1:R7P16LH:16::SH16
"sh r<TRTZ>, <U_SHIFT_1BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3 (GPR[TRTZ], U_SHIFT_1BIT, GPR[TRS]);
  do_store (SD_, AccessLength_HALFWORD, GPR[TRS], U_SHIFT_1BIT,
            zero_extend(SD_, GPR[TRTZ], 16));
  int temp = do_load(SD_, AccessLength_HALFWORD, GPR[TRS], U_SHIFT_1BIT);
  TRACE_ALU_RESULT(temp);
}

001100,3.RT,3.RS,0,3.SHIFT:P16SHIFT:16::SLL16
"sll r<TRT>, r<TRS>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  //do_sll (SD_, TRS, TRD, SHIFT_DEC);
  unsigned32 temp = (GPR[TRS] << SHIFT_DEC);
  TRACE_ALU_INPUT3 (GPR[TRT], GPR[TRS], SHIFT_DEC);
  GPR[TRT] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[TRT]);
}

001100,3.RT,3.RS,1,3.SHIFT:P16SHIFT:16::SRL16
"srl r<TRT>, r<TRS>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  //do_srl (SD_, TRS, TRD, SHIFT_DEC);
  TRACE_ALU_INPUT3 (GPR[TRT], GPR[TRS], SHIFT_DEC);
  GPR[TRT] = GPR[TRS] >> SHIFT_DEC;
  TRACE_ALU_RESULT (GPR[TRT]);
}

101100,3.RT,3.RS,3.RD,1:R7P16ADDU:16::SUBU16
"subu r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  do_subu (SD_, TRS, TRT, TRD);
}

111101,3.RTZ,3.RS,4.U:R7SW16:16::SW16
"sw r<TRTZ>, <U_SHIFT_2BIT>(r<TRS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3 (GPR[TRTZ], U_SHIFT_2BIT, GPR[TRS]);
  do_store (SD_, AccessLength_WORD, GPR[TRS], U_SHIFT_2BIT,
            zero_extend(SD_, GPR[TRTZ], 32));
  int temp = do_load(SD_, AccessLength_WORD, GPR[TRS], U_SHIFT_2BIT);
  TRACE_ALU_RESULT(temp);
}

110101,5.RT,5.U:R7SWSP:16::SWSP
"sw r<RT>, <U_SHIFT_2BIT>(sp)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3 (GPR[RT], U_SHIFT_2BIT, SP);
  do_store (SD_, AccessLength_WORD, SP, U_SHIFT_2BIT,
            zero_extend(SD_, GPR[RT], 32));
  int temp = do_load(SD_, AccessLength_WORD, SP, U_SHIFT_2BIT);
  TRACE_ALU_RESULT(temp);
}

000100,00000,01,0,2.CODE:R7P16SYSCALL:16::SYSCALL16
"syscall %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (SystemCall, instruction_0);
}

010100,3.RT,3.RS,01,0,0:R7POOL16C00:16::XOR16
"xor r<TRT>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, TRS, TRT, TRT);
}

000100,00000,11,3.CODE:R7P16RI:16::SDBBP16
"sdbbp16 %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (DebugBreakPoint, instruction_0);
}

// 32-bit instructions

001000,5.RT,5.RS,5.RD,0,0100010000:R7POOL32A0:32::ADD
"add r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_add (SD_, RS, RT, RD);
}

000000,5.RT!0,5.RS,1.S1,00,13.S2:R7PPADDIU:32::ADDIU
"addiu r<RT>, r<RS>, <S_14_BIT>"
*micromips32r7:
*micromips64r7:
{
  do_addiu (SD_, RS, RT, S_14_BIT);
}

010000,5.RT,19.U,00:R7PGPREL:32::ADDIUGP
"addiu r<RT>, GP, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  do_addiu (SD_, GPIDX, RT, U_SHIFT_2BIT);
}

111000,5.RT,9.S1,10.S2,1,1.S3:R7PAUIPC:32::AxUIPC
"auipc r<RT>, <AXUIPC_S_HI>":RT != 0 && AXUIPC_S_LO==0
"aluipc GP, <AXUIPC_S_HI>":RT == 0 && AXUIPC_S_LO==0
"auipc r<RT>, <AXUIPC_S_HI>, <AXUIPC_S_LO>":RT != 0
"aluipc GP, <AXUIPC_S_HI>, <AXUIPC_S_LO>"
*micromips32r7:
*micromips64r7:
{
  address_word address = NIA + AXUIPC_S;
  if (RT == 0)
  {
    TRACE_ALU_INPUT2(GPR[GPIDX], address);
    GPR[GPIDX] = address & ~0xfff;
    TRACE_ALU_RESULT(GPR[GPIDX]);
  }
  else {
    TRACE_ALU_INPUT2(GPR[RT], address);
    GPR[RT] = address;
    TRACE_ALU_RESULT(GPR[RT]);
  }
}

001000,5.RT,5.RS,5.RD,0,0101010,000:R7POOL32A0:32::ADDU
"addu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,5.IMMEDIATE,011,111:R7POOL32A0:32::ALIGN
"align r<RD>, r<RS>, r<RT>, <IMMEDIATE>"
*micromips32r7:
*micromips64r7:
{
  //do_align (SD_, RD, RS, RT, IMMEDIATE);
  unsigned64 tmp = (GPR[RT] << 32) | GPR[RS];
  TRACE_ALU_INPUT4 (GPR[RD], GPR[RS], GPR[RT], tmp);
  // FIXME: check if tmp is calculated correctly
  GPR[RD] = EXTEND32 (tmp >> IMMEDIATE);
  TRACE_ALU_RESULT (GPR[RD]);

}

001000,5.RT,5.RS,5.RD,0,1001010,000:R7POOL32A0:32::AND
"and r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0010,12.U:R7PU12:32::ANDI
"andi r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, RS, RT, U);
}

001010,1,24.S1,1.S2:R7PBAL:32::BALC
"balc <ADDRESS26>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(RA);
  RA = NIA | isa_mode;
  NIA = ADDRESS26;
  TRACE_ALU_RESULT(RA);
}

001010,0,24.S1,1.S2:R7PBAL:32::BC
"bc <ADDRESS26>"
*micromips32r7:
*micromips64r7:
{
  NIA = ADDRESS26;
}

100010,5.RT,5.RS,00,13.S1,1.S2:R7PBR2:32::BEQC
"beqc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if (GPR[RS] == GPR[RT])
    NIA = ADDRESS15;
}

110010,5.RT,000,7.U,10.S1,1.S2:P7PBRI:32::BEQIC
"beqic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if (GPR[RT] == U) {
    NIA = ADDRESS12;
  }
}

111010,5.RT,0,19.S1,1.S2:R7PBZ:32::BEQZC
"beqzc r<RT>, <ADDRESS21>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[RT]);
  if (GPR[RT] == 0)
    NIA = ADDRESS21;
}

100010,5.RT,5.RS,10,13.S1,1.S2:P7PBR1:32::BGEC
"bgec r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
    NIA = ADDRESS15;
}

110010,5.RT,010,7.U,10.S1,1.S2:P7PBRI:32::BGEIC
"bgeic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if ((signed_word) GPR[RT] >= U) {
    NIA = ADDRESS12;
  }
}

100010,5.RT,5.RS,11,13.S1,1.S2:P7PBR2:32::BGEUC
"bgeuc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if ((unsigned_word) (GPR[RS]) >= (unsigned_word)(GPR[RT])) {
    NIA = ADDRESS15;
  }
}

110010,5.RT,011,7.U,10.S1,1.S2:P7PBRI:32::BGEUIC
"bgeuic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if ((unsigned_word) GPR[RT] >= U) {
    NIA = ADDRESS12;
  }
}

001000,5.RT,5.RS,0000101,100,111,111:R7POOL32A0:32::BITSWAP
"bitswap r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_bitswap (SD_, RT, RS);
}

101010,5.RT,5.RS,10,13.S1,1.S2:P7PBR1:32::BLTC
"bltc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
    NIA = ADDRESS15;
}

110010,5.RT,110,7.U,10.S1,1.S2:P7PBRI:32::BLTIC
"bltic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if ((signed_word) GPR[RT] < U) {
    NIA = ADDRESS12;
  }
}

101010,5.RT,5.RS,11,13.S1,1.S2:P7PBR2:32::BLTUC
"bltuc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT]) {
    NIA = ADDRESS15;
  }
}

110010,5.RT,111,7.U,10.S1,1.S2:P7PBRI:32::BLTUIC
"bltuic <RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if ((unsigned_word) GPR[RT] < U) {
    NIA = ADDRESS12;
  }
}

101010,5.RT,5.RS,00,13.S1,1.S2:R7PBR2:32::BNEC
"bnec r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if (GPR[RS] != GPR[RT])
    NIA = ADDRESS15;
}

110010,5.RT,100,7.U,10.S1,1.S2:P7PBRI:32::BNEIC
"bneic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if (GPR[RT] != U) {
    NIA = ADDRESS12;
  }
}

111010,5.RT!0,1,19.S1,1.S2:R7PBZ:32::BNEZC
"bnezc r<RT>, <ADDRESS21>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[RT]);
  if (GPR[RT] != 0)
    NIA = ADDRESS21;
}

000000,00000,10,19.CODE:R7PRI:32::BREAK
"break %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  do_break (SD_, instruction_0);
}

101001,5.OP,5.RS,1.S1,0011001,8.S2:R7PLSS1:32::CACHE
"cache <OP>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  address_word vaddr;
  address_word paddr;
  int uncached;
  vaddr = loadstore_ea (SD_, GPR[RS], EXTEND9 (S_9_BIT));
  if (AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET,
                          isREAL))
    CacheOp (OP, vaddr, paddr, instruction_0);
}

001000,5.RT,5.RS,0100101,100,111,111:R7POOL32A0:32::CLO
"clo r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_clo (SD_, RT, RS);
}

001000,5.RT,5.RS,0101101,100,111,111:R7POOL32A0:32::CLZ
"clz r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_clz (SD_, RT, RS);
}

001000,5.RT,00000,01,00011,101,111,111:R7POOL32A0:32::DI
"di":RT == 0
"di r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_di (SD_, RT);
}

001000,5.RT,5.RS,5.RD,0,0100011,000:R7POOL32A0:32::DIV
"div r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_div (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0110011,000:R7POOL32A0:32::DIVU
"divu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_divu (SD_, RD, RS, RT);
}

001000,5.RT,00000,01,01011,101,111,111:R7POOL32A0:32::EI
"ei":RT == 0
"ei r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_ei (SD_, RT);
}

001000,000000000,0,11,11001,101,111,111:R7POOL32A0:32::ERET
"eret"
*micromips32r7:
*micromips64r7:
{
  //TODO: signal coprocessor_exception(0) if !IsCoprocessor0Enabled()
  NIA = do_eret(SD_, 0, NIA);
}

001000,000000000,1,11,11001,101,111,111:R7POOL32A0:32::ERETNC
"eretnc"
*micromips32r7:
*micromips64r7:
{
  //TODO: signal coprocessor_exception(0) if !IsCoprocessor0Enabled()
  NIA = do_eret(SD_, 1, NIA);
}

100000,5.RT,5.RS,11110,5.MSBD,0,5.LSB:R7PEXT:32::EXT
"ext r<RT>, r<RS>, <LSB>, <MSBD+1>"
*micromips32r7:
*micromips64r7:
{
  if (LSB + MSBD + 1 > 32)
    Unpredictable ();

  TRACE_ALU_INPUT4 (GPR[RT], GPR[RS], LSB,  MSBD + 1);
  GPR[RT] = EXTEND32 (zero_extend(SD_, GPR[RS] >> LSB, MSBD + 1));
  TRACE_ALU_RESULT1 (GPR[RT]);
}

100000,5.RT,5.RS,1110,0,5.MSBD,0,5.LSB:R7PINS:32::INS
"ins r<RT>, r<RS>, <INS_POS>, <INS_SIZE>"
*micromips32r7:
*micromips64r7:
{
  do_ins_mm_r7 (SD_, RT, RS, INS_POS, INS_SIZE);
}

010010,5.RT,5.RS,0000,12.X:R7PJ:32::JALRC
"jalrc r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  //NIA = do_jalrc_mm_r7 (SD_, RT, RS, U, NIA);
  GPR[RT] = NIA | isa_mode;
  unsigned_word address = GPR[RS];
  isa_mode = address & 1;
  NIA = address & ~1;
}

010010,5.RT,5.RS,0001,12.X:R7PJ:32::JALRC.HB
"jalrc.hb r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  //NIA = do_jalrc_mm_r7 (SD_, RT, RS, U, NIA);
  GPR[RT] = NIA | isa_mode;
  unsigned_word address = GPR[RS];
  isa_mode = address & 1;
  NIA = address & ~1;
  //TODO: ClearHazards()?
}

100001,5.RT,5.RS,0000,12.U:R7PLSU12:32::LB
"lb r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GPR[RS]);
  GPR[RT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[RS],U));
  TRACE_ALU_RESULT(GPR[RT]);
}

010001,5.RT,000,18.U:R7PLSGP:32::LBGP
"lb r<RT>, <U>(GP)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GP);
  GPR[RT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GP, U));
  TRACE_ALU_RESULT(GPR[RT]);
}

101001,5.RT,5.RS,1.S1,0000000,8.S2:R7PLSS0:32::LBS9
"lb r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT, GPR[RS]);
  GPR[RT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[RS], S_9_BIT));
  TRACE_ALU_RESULT(GPR[RT]);
}

100001,5.RT,5.RS,0010,12.U:R7PLSU12:32::LBU
"lbu r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GPR[RS]);
  GPR[RT] = do_load (SD_, AccessLength_BYTE, GPR[RS], U);
  TRACE_ALU_RESULT(GPR[RT]);
}

010001,5.RT,010,18.U:R7PLSGP:32::LBUGP
"lbu r<RT>, <U>(GP)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GP);
  GPR[RT] = do_load (SD_, AccessLength_BYTE, GP, U);
  TRACE_ALU_RESULT(GPR[RT]);
}

101001,5.RT,5.RS,1.S1,0010,0,00,8.S2:R7PLSS0:32::LBUS9
"lbu r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT, GPR[RS]);
  GPR[RT] = do_load (SD_, AccessLength_BYTE, GPR[RS], S_9_BIT);
  TRACE_ALU_RESULT(GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0010,0,000,111:R7PPLSX:32::LBUX
"lbux r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lxx_mmr7 (SD_, RD, RT, RS, 0);
}

001000,5.RT,5.RS,5.RD,0000,0,000,111:R7PPLSX:32::LBX
"lbx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lxx_mmr7 (SD_, RD, RT, RS, 1);
}

100001,5.RT,5.RS,0100,12.U:R7PLSU12:32::LH
"lh r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GPR[RS]);
  GPR[RT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[RS], U));
  TRACE_ALU_RESULT(GPR[RT]);
}

010001,5.RT,100,18.U:R7PLSGP:32::LHGP
"lh r<RT>, <U>(GP)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GP);
  GPR[RT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GP, U));
  TRACE_ALU_RESULT(GPR[RT]);
}

101001,5.RT,5.RS,1.S1,0100,0,00,8.S2:R7PLSS0:32::LHS9
"lh r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT, GPR[RS]);
  GPR[RT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[RS], S_9_BIT));
  TRACE_ALU_RESULT(GPR[RT]);
}

100001,5.RT,5.RS,0110,12.U:R7PLSU12:32::LHU
"lhu r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GPR[RS]);
  GPR[RT] = do_load (SD_, AccessLength_HALFWORD, GPR[RS], U);
  TRACE_ALU_RESULT(GPR[RT]);
}

010001,5.RT,110,18.U:R7PLSGP:32::LHUGP
"lhu r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GP);
  GPR[RT] = do_load (SD_, AccessLength_HALFWORD, GP, U);
  TRACE_ALU_RESULT(GPR[RT]);
}

101001,5.RT,5.RS,1.S1,0110,0,00,8.S2:R7PLSS0:32::LHUS9
"lhu r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT, GPR[RS]);
  GPR[RT] = do_load (SD_, AccessLength_HALFWORD, GPR[RS], S_9_BIT);
  TRACE_ALU_RESULT(GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0110,0,000,111:R7PPLSX:32::LHUX
"lhux r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RD], GPR[RS], GPR[RT]);
  GPR[RD] = do_load (SD_, AccessLength_HALFWORD, GPR[RT], GPR[RS]);
  TRACE_ALU_RESULT(GPR[RD]);
}

001000,5.RT,5.RS,5.RD,0110,1,000,111:R7PPLSXS:32::LHUXS
"lhux r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RD], GPR[RS], GPR[RT]);
  GPR[RD] = do_load (SD_, AccessLength_HALFWORD, GPR[RT], GPR[RS] << 1);
  TRACE_ALU_RESULT(GPR[RD]);
}

001000,5.RT,5.RS,5.RD,0100,0,000,111:R7PPLSX:32::LHX
"lhx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lxx_mmr7 (SD_, RD, RT, RS, 2);
}

001000,5.RT,5.RS,5.RD,0100,1,000,111:R7PPLSXS:32::LHXS
"lhxs r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RD], GPR[RS], GPR[RT]);
  GPR[RD] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[RT],
                     GPR[RS] << 1));
  TRACE_ALU_RESULT(GPR[RD]);
}

101001,5.RT,5.RS,1.S1,1000,0,01,6.S2,00:R7PLL:32::LL
"ll r<RT>, <S_9_BIT_LLSC>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT_LLSC, GPR[RS]);
  do_ll (SD_, RT, S_9_BIT_LLSC, RS);
  TRACE_ALU_RESULT(GPR[RT]);
}

001000,5.RT,5.RS,5.RD,2.U,000,001,111:R7POOL32A7:32::LSA
"lsa r<RD>, r<RS>, r<RT>, <U>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT4 (GPR[RD], GPR[RS], GPR[RT], U);
  unsigned32 sum = (GPR[RS] << U) + GPR[RT];
  // old way:
  //unsigned32 sum = (GPR[RS] << U + 1) + GPR[RT];
  GPR[RD] = EXTEND32(sum);
  TRACE_ALU_RESULT (GPR[RD]);
}

111000,5.RT,9.S1,10.S2,0,1.S3:R7PLUI:32::LUI
"lui r<RT>, <AXUIPC_S_HI>, <AXUIPC_S_LO>":AXUIPC_S_LO != 0
"lui r<RT>, <AXUIPC_S_HI>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2 (GPR[RT], AXUIPC_S);
  GPR[RT] = EXTEND32 (AXUIPC_S);
  TRACE_ALU_RESULT (GPR[RT]);
}

100001,5.RT,5.RS,1000,12.U:R7PLSU12:32::LW
"lw r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GPR[RS]);
  GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[RS], U));
  TRACE_ALU_RESULT(GPR[RT]);
}

101001,5.RT,5.RS,1.S1,1000000,8.S2:R7SWS9:32::LWS9
"lw r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT, GPR[RS]);
  GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[RS], S_9_BIT));
  TRACE_ALU_RESULT(GPR[RT]);
}

010000,5.RT,19.U,10:R7LWGP:32::LWGP
"lw r<RT>, <U_SHIFT_2BIT>(GP)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U_SHIFT_2BIT, GP);
  GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GP, U_SHIFT_2BIT));
  TRACE_ALU_RESULT(GPR[RT]);

}

001000,5.RT,5.RS,5.RD,1000,0,000,111:R7PPLSX:32::LWX
"lwx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lxx_mmr7 (SD_, RD, RT, RS, 3);
  //GPR[RD] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[RS], GPR[RT]));
}

001000,5.RT,5.RS,5.RD,1000,1,000,111:R7PPLSXS:32::LWXS
"lwxs r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RD], GPR[RS], GPR[RT]);
  GPR[RD] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[RT],
                               GPR[RS] << 2));
  TRACE_ALU_RESULT(GPR[RD]);
}

001000,5.RT,5.C0S,2.X1,3.SEL,1.X2,0000110,000:R7POOL32A0:32::MFC0
"mfc0 r<RT>, r<C0S>, <SEL>"
*micromips32r7:
*micromips64r7:
{
  DecodeCoproc (instruction_0, 0, cp0_mfc0, RT, C0S, SEL);
}

001000,5.RT,5.RS,5.RD,00101011000:R7POOL32A0:32::MOD
"mod r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_mod (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,00111011000:R7POOL32A0:32::MODU
"modu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_modu (SD_, RD, RS, RT);
}

000010,1.RT1,1.RD,3.RT2,20.S1,1.S2:R7MOVEBALC:32::MOVE.BALC
"move.balc r<RD1>, r<RT_5_BIT>, <ADDRESS22>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RD1], GPR[RT_5_BIT]);
  GPR[RD1] = GPR[RT_5_BIT];
  RA = NIA | isa_mode;
  NIA = ADDRESS22;
  TRACE_ALU_RESULT(GPR[RD1]);
}

001000,5.RT,5.RS,5.RD,11000010000:R7POOL32A0:32::MOVN
"movn r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_movn (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,1000010,000:R7POOL32A0:32::MOVZ
"movz r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_movz (SD_, RD, RS, RT);
}

001000,5.RT,5.C0S,2.X1,3.SEL,1.X2,0001110,000:R7POOL32A0:32::MTC0
"mtc0 r<RT>, r<C0S>, <SEL>"
*micromips32r7:
*micromips64r7:
{
  DecodeCoproc (instruction_0, 0, cp0_mtc0, RT, C0S, SEL);
}

001000,5.RT,5.RS,5.RD,0,0001011,000:R7POOL32A0:32::MUH
"muh r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_muh (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0011011,000:R7POOL32A0:32::MUHU
"muhu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_muhu (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0000011,000:R7POOL32A0:32::MUL
"mul r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_mul (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0010011,000:R7POOL32A0:32::MULU
"mulu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_mulu (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,1011010,000:R7POOL32A0:32::NOR
"nor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1010010,000:R7POOL32A0:32::OR
"or r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0000,12.U:R7PU12:32::ORI
"ori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_ori (SD_, RS, RT, U);
}

100000,00000,5.X1,1100,3.X2,0000,00101:R7PHB:32::PAUSE
"pause"
*micromips32r7:
*micromips64r7:
{
}

101001,5.HINT!31,5.RS,1.S1,0011,0,00,8.S2:R7PPREFS:32::PREF
"pref <HINT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_pref (SD_, HINT, S_9_BIT, RS);
}

100000,5.RT_SAVE,4.GPR_LIST_SAVE,10011,9.U,0,1.FP_SAVE,1.GP_SAVE:R7PRESTORE:32::RESTORE
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>": GPR_LIST_SAVE == 0
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GPR_LIST_SAVE>": (!FP_SAVE && !GP_SAVE) && GPR_LIST_SAVE != 0
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>": FP_SAVE && !GP_SAVE && GPR_LIST_SAVE < 2
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GPR_LIST_SAVE>" : FP_SAVE && !GP_SAVE && GPR_LIST_SAVE >=2
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>": GP_SAVE && !FP_SAVE && GPR_LIST_SAVE < 2
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>" : !FP_SAVE && GP_SAVE && GPR_LIST_SAVE >=2
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>": (FP_SAVE && GP_SAVE) && GPR_LIST_SAVE < 3
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  do_restore_gprs_from_stack_and_adjust_sp(SD_, RT_SAVE, GPR_LIST_SAVE, FP_SAVE,
                                           GP_SAVE, U_SHIFT_3BIT);
}

100000,5.RT_SAVE,4.GPR_LIST_SAVE,10011,9.U,1,1.FP_SAVE,1.GP_SAVE:R7PRESTORE:32::RESTORE.JRC
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>": GPR_LIST_SAVE == 0
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GPR_LIST_SAVE>": (!FP_SAVE && !GP_SAVE) && GPR_LIST_SAVE != 0
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>": FP_SAVE && !GP_SAVE && GPR_LIST_SAVE < 2
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GPR_LIST_SAVE>" : FP_SAVE && !GP_SAVE && GPR_LIST_SAVE >=2
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>": GP_SAVE && !FP_SAVE && GPR_LIST_SAVE < 2
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>" : !FP_SAVE && GP_SAVE && GPR_LIST_SAVE >=2
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>": (FP_SAVE && GP_SAVE) && GPR_LIST_SAVE < 3
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  do_restore_gprs_from_stack_and_adjust_sp(SD_, RT_SAVE, GPR_LIST_SAVE, FP_SAVE,
                                           GP_SAVE, U_SHIFT_3BIT);

  isa_mode =  GPR[RAIDX] & 0x1;
  NIA = GPR[RAIDX] & ~1;
}

100000,5.RT,5.RS,1100,000,0110,5.SHIFT:R7PSHIFT:32::ROTR
"rotr r<RT>, r<RS>, <SHIFT>"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = do_ror (SD_, GPR[RS], SHIFT);
}

001000,5.RT,5.RS,5.RD,0,0011010,000:R7POOL32A0:32::ROTRV
"rotrv r<RD>, r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  GPR[RD] = do_ror (SD_, GPR[RT], GPR[RS]);
}

001000,5.RT,5.RS,5.RD,0,1100010,000:R7POOL32A0:32::XOR
"xor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0001,12.U:R7PU12:32::XORI
"xori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_xori (SD_, RS, RT, U);
}

100000,5.RT_SAVE,4.GPR_LIST_SAVE,0,0011,9.U,1.X,1.FP_SAVE,1.GP_SAVE:R7PSR:32::SAVE
"save <U_SHIFT_3BIT>, %s<RT_SAVE>": GPR_LIST_SAVE == 0
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GPR_LIST_SAVE>": (!FP_SAVE && !GP_SAVE) && GPR_LIST_SAVE != 0
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>": FP_SAVE && !GP_SAVE && GPR_LIST_SAVE < 2
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GPR_LIST_SAVE>" : FP_SAVE && !GP_SAVE && GPR_LIST_SAVE >=2
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>": GP_SAVE && !FP_SAVE && GPR_LIST_SAVE < 2
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>" : !FP_SAVE && GP_SAVE && GPR_LIST_SAVE >=2
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>": (FP_SAVE && GP_SAVE) && GPR_LIST_SAVE < 3
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  do_save_gprs_to_stack_and_adjust_sp(SD_, RT_SAVE, GPR_LIST_SAVE, FP_SAVE,
                                      GP_SAVE, U_SHIFT_3BIT);
}

100001,5.RT,5.RS,0001,12.U:R7PLSU12:32::SB
"sb r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GPR[RS]);
  do_store (SD_, AccessLength_BYTE, GPR[RS], U, GPR[RT]);
  unsigned32 temp = do_load(SD_, AccessLength_BYTE, GPR[RS], U);
  TRACE_ALU_RESULT(temp);
}

010001,5.RT,001,18.U:R7PLSGP:32::SBGP
"sb r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GP);
  do_store (SD_, AccessLength_BYTE, GP, U, GPR[RT]);
  unsigned32 temp = do_load(SD_, AccessLength_BYTE, GP, U);
  TRACE_ALU_RESULT(temp);
}

101001,5.RT,5.RS,1.S1,0001,0,00,8.S2:R7PLSS0:32::SBS9
"sb r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT, GPR[RS]);
  do_store (SD_, AccessLength_BYTE, GPR[RS], S_9_BIT, GPR[RT]);
  unsigned32 temp = do_load(SD_, AccessLength_BYTE, GPR[RS], S_9_BIT);
  TRACE_ALU_RESULT(temp);
}

001000,5.RT,5.RS,5.RD,0001,0,000,111:R7PPLSX:32::SBX
"sbx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RD], GPR[RS], GPR[RT]);
  do_store (SD_, AccessLength_BYTE, GPR[RT], GPR[RS], GPR[RD]);
  unsigned32 temp = do_load(SD_, AccessLength_BYTE, GPR[RT], GPR[RS]);
  TRACE_ALU_RESULT(temp);
}

101001,5.RT,5.RS,1.S1,1001,0,01,6.S2,00:R7PSC:32::SC
"sc r<RT>, <S_9_BIT_LLSC>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_sc (SD_, RT, S_9_BIT_LLSC, RS, instruction_0);
}

001000,5.RT,5.RS,0010101100111111:R7POOL32A0:32::SEB
"seb r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_seb (SD_, RT, RS);
}

001000,5.RT,5.RS,0011101,100,111,111:R7POOL32A0:32::SEH
"seh r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_seh (SD_, RT, RS);
}

100000,5.RT,5.RS,0110,12.IMMEDIATE:R7PU12:32::SEQI
"seqi r<RT>, r<RS>, <IMMEDIATE>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], GPR[RS], IMMEDIATE);
  GPR[RT] = (GPR[RS] == IMMEDIATE) ? 1 : 0;
  TRACE_ALU_RESULT(GPR[RT]);
}

100001,5.RT,5.RS,0101,12.U:R7PLSU12:32::SH
"sh r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GPR[RS]);
  do_store (SD_, AccessLength_HALFWORD, GPR[RS], U, GPR[RT]);
  unsigned32 temp = do_load(SD_, AccessLength_HALFWORD, GPR[RS], U);
  TRACE_ALU_RESULT(temp);
}

010001,5.RT,101,18.U:R7PLSGP:32::SHGP
"sh r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GP);
  do_store (SD_, AccessLength_HALFWORD, GP, U, GPR[RT]);
  unsigned32 temp = do_load(SD_, AccessLength_HALFWORD, GP, U);
  TRACE_ALU_RESULT(temp);
}

101001,5.RT,5.RS,1.S1,0101,0,00,8.S2:R7PLSS0:32::SHS9
"sh r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT, GPR[RS]);
  do_store (SD_, AccessLength_HALFWORD, GPR[RS], S_9_BIT, GPR[RT]);
  unsigned32 temp = do_load(SD_, AccessLength_HALFWORD, GPR[RS], S_9_BIT);
  TRACE_ALU_RESULT(temp);
}

001000,5.RT,5.RS,5.RD,0101,0,000,111:R7PPLSX:32::SHX
"shx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RD], GPR[RS], GPR[RT]);
  do_store (SD_, AccessLength_HALFWORD, GPR[RT], GPR[RS], GPR[RD]);
  unsigned32 temp = do_load(SD_, AccessLength_HALFWORD, GPR[RT], GPR[RS]);
  TRACE_ALU_RESULT(temp);
}

001000,5.RT,5.RS,5.RD,0101,1,000,111:R7PPLSXS:32::SHXS
"shxs r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RD], GPR[RS], GPR[RT]);
  do_store (SD_, AccessLength_HALFWORD, GPR[RT], GPR[RS] << 1, GPR[RD]);
  unsigned32 temp = do_load(SD_, AccessLength_HALFWORD, GPR[RT], GPR[RS] << 1);
  TRACE_ALU_RESULT(temp);
}

000000,00000,00,19.CODE:R7PRI:32::SIGRIE
"sigrie %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (ReservedInstruction, instruction_0);
}


100000,5.RT!0,5.RS,1100,3.X,0000,5.SHIFT:R7PSHIFT:32::SLL
"sll r<RT>, r<RS>, <SHIFT>"
*micromips32r7:
*micromips64r7:
{
  //do_sll (SD_, RS, RT, SHIFT);
  unsigned32 temp = (GPR[RS] << SHIFT);
  TRACE_ALU_INPUT3 (GPR[RT], GPR[RS], SHIFT);
  GPR[RT] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0,0000010,000:R7POOL32A0:32::SLLV
"sllv r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  //do_sllv (SD_, RT, RS, RD);
  int s = MASKED (GPR[RT], 4, 0);
  unsigned32 temp = (GPR[RS] << s);
  TRACE_ALU_INPUT3 (GPR[RD], GPR[RS], s);
  GPR[RD] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[RD]);
}

001000,5.RT,5.RS,5.RD,0,1101010,000:R7POOL32A0:32::SLT
"slt r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_slt (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0100,12.IMMEDIATE:R7PU12:32::SLTI
"slti r<RT>, r<RS>, <IMMEDIATE>"
*micromips32r7:
*micromips64r7:
{
  do_slti (SD_, RS, RT, IMMEDIATE);
}

100000,5.RT,5.RS,0101,12.U:R7PU12:32::SLTIU
"sltiu r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_sltiu (SD_, RS, RT, U);
}

001000,5.RT,5.RS,5.RD,0,1110010,000:R7POOL32A0:32::SLTU
"sltu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_sltu (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,1100,3.X,0100,5.SHIFT:R7PSHIFT:32::SRA
"sra r<RT>, r<RS>, <SHIFT>"
*micromips32r7:
*micromips64r7:
{
  //do_sra (SD_, RS, RT, SHIFT);
  signed32 temp = (signed32) GPR[RS] >> SHIFT;
  if (NotWordValue (GPR[RS]))
    Unpredictable ();
  TRACE_ALU_INPUT3 (GPR[RT], GPR[RS], SHIFT);
  GPR[RT] = temp;
  TRACE_ALU_RESULT (GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0,0010010,000:R7POOL32A0:32::SRAV
"srav r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_srav (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,11000000010,5.SHIFT:R7PSHIFT:32::SRL
"srl r<RT>, r<RS>, <SHIFT>"
*micromips32r7:
*micromips64r7:
{
  //do_srl (SD_, RS, RT, SHIFT);
  unsigned32 temp = (unsigned32) GPR[RS] >> SHIFT;
  if (NotWordValue (GPR[RS]))
    Unpredictable ();
  TRACE_ALU_INPUT3 (GPR[RT], GPR[RS], SHIFT);
  GPR[RT] = temp;
  TRACE_ALU_RESULT (GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0,0001010,000:R7POOL32A0:32::SRLV
"srlv r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_srlv (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,1.X,0110010,000:R7POOL32A0:32::SUB
"sub r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_sub (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,1.X,0111010,000:R7POOL32A0:32::SUBU
"subu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_subu (SD_, RS, RT, RD);
}

100001,5.RT,5.RS,1001,12.U:R7SW:32::SW
"sw r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U, GPR[RS]);
  do_store (SD_, AccessLength_WORD, GPR[RS], U, zero_extend(SD_, GPR[RT], 32));
  unsigned32 temp = do_load(SD_, AccessLength_WORD, GPR[RS], U);
  TRACE_ALU_RESULT(temp);
}

101001,5.RT,5.RS,1.S1,1001000,8.S2:R7SWS9:32::SWS9
"sw r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT, GPR[RS]);
  do_store (SD_, AccessLength_WORD, GPR[RS], S_9_BIT,
            zero_extend(SD_, GPR[RT], 32));
  unsigned32 temp = do_load(SD_, AccessLength_WORD, GPR[RS], S_9_BIT);
  TRACE_ALU_RESULT(temp);
}

010000,5.RT,19.U,11:R7SWGP:32::SWGP
"sw r<RT>, <U_SHIFT_2BIT>(gp)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], U_SHIFT_2BIT, GP);
  do_store (SD_, AccessLength_WORD, GP, U_SHIFT_2BIT,
            zero_extend(SD_, GPR[RT], 32));
  unsigned32 temp = do_load(SD_, AccessLength_WORD, GP, U_SHIFT_2BIT);
  TRACE_ALU_RESULT(temp);
}

001000,5.RT,5.RS,5.RD,1001,0,000,111:R7PPLSX:32::SWX
"swx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RD], GPR[RS], GPR[RT]);
  do_store (SD_, AccessLength_WORD, GPR[RT], GPR[RS],
            zero_extend(SD_, GPR[RD], 32));
  unsigned32 temp = do_load(SD_, AccessLength_WORD, GPR[RT], GPR[RS]);
  TRACE_ALU_RESULT(temp);
}

001000,5.RT,5.RS,5.RD,1001,1,000,111:R7PPLSXS:32::SWXS
"swxs r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RD], GPR[RS], GPR[RT]);
  do_store (SD_, AccessLength_WORD, GPR[RT], GPR[RS] << 2,
            zero_extend(SD_, GPR[RD], 32));
  unsigned32 temp = do_load(SD_, AccessLength_WORD, GPR[RT], GPR[RS] << 2);
  TRACE_ALU_RESULT(temp);
}

100000,00000,5.STYPE,1100,3.X,0000,00110:R7PHB:32::SYNC
"sync":STYPE==0
"sync <STYPE>"
*micromips32r7:
*micromips64r7:
{
  SyncOperation (STYPE);
}

101001,11111,5.RS,1.S1,0011,0,00,8.S2:R7PPREFS:32::SYNCIS9
"synci <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  // sync i-cache - nothing to do currently
}

000000,00000,11,19.CODE:R7PRI:32::SDBBP
"sdbbp %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (DebugBreakPoint, instruction_0);
}

001000,5.RT,5.RS,0111101,100,111,111:R7POOL32A0:32::WSBH
"wsbh r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_wsbh (SD_, RT, RS);
}

001000,0000000000,01,00001,101,111,111:R7POOL32AXF5GROUP1:32::TLBINV
"tlbinv"
*micromips32r7:
*micromips64r7:
{
  // invalidate a set of TLB entries based on ASID and Index match - nothing to do currently
}

001000,0000000000,01,01001,101,111,111:R7POOL32AXF5GROUP1:32::TLBINVF
"tlbinvf"
*micromips32r7:
*micromips64r7:
{
  // invalidate a set of TLB entries based on Index match - nothing to do currently
}

001000,10.CODE,10,00101,101,111,111:R7PSYSCALL:32::SYSCALL
"syscall %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (SystemCall, instruction_0);
}

100000,00000,5.X1,1100,3.X2,0000,00011:R7PHB:32::EHB
"ehb"
*micromips32r7:
*micromips64r7:
