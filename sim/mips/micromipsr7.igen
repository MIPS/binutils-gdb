// Simulator definition for the micromips ASE.
// Copyright (C) 2005-2014 Free Software Foundation, Inc.
// Contributed by Imagination Technologies, Ltd.
// Written by Ali Lown <ali.lown@imgtec.com>
//
// This file is part of GDB, the GNU debugger.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

:compute:::int:U_SHIFT_1BIT:U:(U << 1)
:compute:::int:U_SHIFT_2BIT:U:(U << 2)
:compute:::int:U_SHIFT_3BIT:U:(U << 3)
:compute:::int:U_DEC127:U:((U < 127) ? U \: -1)
:compute:::int:TRT4:RT:(compute_gpr4in5_reg (SD_, RT))
:compute:::int:TBASE4:BASE:(compute_gpr4in5_reg (SD_, BASE))
:compute:::int:U_LW4X4:BASE,RT:(((GPR[BASE] & 0x4) << 1) | (GPR[RT] & 0x4))
:compute:::int:MOVE_RS:CODE,MINOR_OPCODE:(CODE << 2 | MINOR_OPCODE)
:compute:::int:AXUIPC_S_LO:S1,S2,S3:((EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12))) & 0x0000ffff)
:compute:::int:AXUIPC_S_HI:S1,S2,S3:((EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12))) & 0xffff0000)
:compute:::int:AXUIPC_S:S1,S2,S3:(EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12)))
:compute:::int:TRD2:RD20,RD21:(compute_gpr2_dest1_reg (SD_, (RD21 | RD20)))
:compute:::int:TRE2:RD20,RD21:(compute_gpr2_dest2_reg (SD_, (RD21 | RD20)))
:compute:::int:TRS2:RS4,RS2_0:((RS4 << 3) | (RS2_0 >> 1))
:compute:::int:TRT2:RT4,RT2_0:((RT4 << 3) | (RT2_0 >> 1))
:compute:::int:ADDRESS8:S1,S2:((S2 << 7) | (S1 << 1))
:compute:::int:ADDRESS11:S1,S2:((S2 << 10) | (S1 << 1))
:compute:::int:ADDRESS15:S1,S2:((S2 << 14) | (S1 << 1))
:compute:::int:ADDRESS21:S1,S2:((S2 << 20) | (S1 << 1))
:compute:::int:ADDRESS22:S1,S2:((S2 << 21) | (S1 << 1))
:compute:::int:ADDRESS26:S1,S2:((S2 << 25) | (S1 << 1))
:compute:::int:INS_POS:LSB:(LSB)
:compute:::int:INS_SIZE:LSB,MSBD:(1 + MSBD - LSB)
:compute:::address_word:P7PBRI_ADDRESS:S1,S2:(nia + EXTEND12(S2 << 11 | S1 << 1))
:compute:::address_word:P7PBR1_ADDRESS:S1,S2:(nia + EXTEND15(S2 << 14 | S1 << 1))
:compute:::int:S_14_BIT:S1,S2:((S1 << 13) | S2)
:compute:::int:S_4_BIT:S1,S2:((S1 << 3) | S2)
:compute:::int:S_8_BIT:S1,S2:((S1 << 7) | S2)
:compute:::int:RD1:RD:(compute_gpr1_dest_reg (SD_, RD))
:compute:::int:RS_5_BIT:RS1,RS2:((RS1 << 4) | RS2)

:function:::unsigned32:compute_gpr4in5_reg:int reg
*micromips32r7:
*micromips64r7:
{
  if (reg < 8 || (reg >= 16 && reg < 24))
    return reg;
  else if ((reg >=8 && reg < 16) || (reg >= 24 && reg < 32))
    return reg - 8;
}

:function:::unsigned32:compute_gpr2_dest1_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 4;
    case 1: return 5;
    case 2: return 6;
    case 3: return 7;
    default: return 4;
    }
}

:function:::unsigned32:compute_gpr2_dest2_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 5;
    case 1: return 6;
    case 2: return 7;
    case 3: return 4;
    default: return 5;
    }
}

:function:::void:do_sll_mm_r7:int rs, int rd, int shift
*micromips32r7:
*micromips64r7:
{
  shift = (shift == 0) ? 8 : shift;
  unsigned32 temp = (GPR[rs] << shift);
  TRACE_ALU_INPUT2 (GPR[rs], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_srl_mm_r7:int rs, int rd, int shift
*micromips32r7:
*micromips64r7:
{
  shift = (shift == 0) ? 8 : shift;
  unsigned32 temp = (GPR[rs] >> shift);
  TRACE_ALU_INPUT2 (GPR[rs], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_p16move:int rd, int code, int minor_opcode, address_word instruction_0
*micromips32r7:
*micromips64r7:
{
  if (rd == 0 && code == 0 && minor_opcode == 0)
  {
    // NOP
  }
  else if (rd == 0 && minor_opcode == 0x1)
  {
    // BREAK
    do_break (SD_, instruction_0);
  }
  else if (rd == 0 && minor_opcode == 0x3)
  {
    // SDBBP
    SignalException (DebugBreakPoint, instruction_0);
  }
  else
  {
    // MOVE
    GPR[rd] = GPR[code << 2 | minor_opcode];
  }
}

:function:::void:do_pauipc: int rt, int s
*micromips32r7:
*micromips64r7:
{
    int address = loadstore_ea (SD_, CIA, s);
    if (rt == 0)
    {
        GPR[rt] = address & ~0xfff;
    }
    else {
        GPR[rt] = address;
    }
}

:function:::address_word:do_bc16:address_word offset
{
  return CIA + offset;
}

:function:::address_word:do_balc16:address_word offset
{
  RA = CIA | isa_mode;
  return CIA + offset;
}

:function:::address_word:do_beqc16_bnec16:int rs, int rt, address_word offset, address_word nia
*micromips32r7:
*micromips64r7:
{
  if (rs < rt && GPR[rs] == GPR[rt])
    return nia + offset; //BEQC
  if (GPR[rs] != GPR[rt])
    return nia + offset; //BNEC
  return NIA;
}

:function:::void:do_ins_mm_r7:int rt, int rs, int pos, int size
{
  TRACE_ALU_INPUT4 (GPR[rt], GPR[rs], pos, size);
  if (size < 1)
    Unpredictable ();

  int merge_mask = ((1 << size) - 1) << pos;
  int result = GPR[rt] & ~merge_mask | (GPR[rs] << pos) & merge_mask;
  GPR[rt] = EXTEND32 (result);
  TRACE_ALU_RESULT1 (GPR[rt]);
}

:function:::unsigned32:compute_gpr1_dest_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 4;
    case 1: return 5;
    default: return 4;
    }
}

:function:::address_word:do_jialc_mm_r7:int rt, int rs, unsigned16 offset
{
  rt = CIA | isa_mode;
  unsigned_word address = do_load (SD_, AccessLength_WORD, GPR[rs], offset);
  isa_mode = address & 1;
  return address & ~1;
}

:function:::unsigned_word:zero_extend:signed_word value, unsigned32 from_nbits
{
  unsigned32 low_bits_mask = (1 << from_nbits) - 1;
  return value & low_bits_mask;
}

00000000000000000000000000000000:R7DUMMY:32,f::DUMMY0.fmt
"dummy 0"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds */
}

00000000000000000000000000000001:R7DUMMY:32,f::DUMMY1.fmt
"dummy 1"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds (needs at least 2 instructions) */
}

001000,5.RT,5.RS,5.RD,0,1001010,000:R7POOL32A0:32::AND
"and r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1010010,000:R7POOL32A0:32::OR
"or r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1100010,000:R7POOL32A0:32::XOR
"xor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1011010,000:R7POOL32A0:32::NOR
"nor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0010,12.U:R7PU12:32::ANDI
"andi r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, RS, RT, U);
}

100000,5.RT,5.RS,0000,12.U:R7PU12:32::ORI
"ori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_ori (SD_, RS, RT, U);
}

100000,5.RT,5.RS,0001,12.U:R7PU12:32::XORI
"xori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_xori (SD_, RS, RT, U);
}

010100,3.RD,3.RS,10,0,0:R7POOL16C00:16::AND16
"and r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, TRS, TRD, TRD);
}

010100,3.RD,3.RS,11,0,0:R7POOL16C00:16::OR16
"or r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, TRS, TRD, TRD);
}

000100,3.RD,3.RS,3.RT,0:R7P16ADDU:16::ADDU16
"addu r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, TRS, TRT, TRD);
}

001000,5.RT,5.RS,5.RD,0,0101010,000:R7POOL32A0:32::ADDU
"addu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, RS, RT, RD);
}

000100,3.RD,3.RS,3.RT,1:R7P16ADDU:16::SUBU16
"subu r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  do_subu (SD_, TRS, TRT, TRD);
}

001000,5.RT,5.RS,5.RD,0,0110011,000:R7POOL32A0:32::DIVU
"divu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_divu (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0100011,000:R7POOL32A0:32::DIV
"div r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_div (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,0000101,100,111,111:R7POOL32A0:32::BITSWAP
"bitswap r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_bitswap (SD_, RT, RS);
}

001000,5.RT,5.RS,5.RD,2.IMMEDIATE,000,011,111:R7POOL32A0:32::ALIGN
"align r<RD>, r<RS>, r<RT>, <IMMEDIATE>"
*micromips32r7:
*micromips64r7:
{
  do_align (SD_, RD, RS, RT, IMMEDIATE);
}

010110,5.RS,0,0000:R7P16JRC:16::JRC16
"jrc r<TRS>"
*micromips32r7:
*micromips64r7:
{
  NIA = process_isa_mode (SD_, GPR[TRS]);
}

010110,5.RS,1,0000:R7P16JRC:16::JALRC16
"jalrc r<TRS>"
*micromips32r7:
*micromips64r7:
{
  RA = NIA | ISA_MODE_MICROMIPS;
  NIA = process_isa_mode (SD_, GPR[TRS]);
}

010100,3.RD,3.RS,01,0,0:R7POOL16C00:16::XOR16
"xor r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, TRS, TRD, TRD);
}

010100,3.RD,3.RS,00,0,0:R7POOL16C00:16::NOT16
"not r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, 0, TRS, TRD);
}

111100,3.RD,3.RS,4.U:R7ANDI16:16::ANDI16
"andi r<TRD>, r<TRS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, TRS, TRD, U);
}

001100,3.RD,3.RS,0,3.SHIFT:P16SHIFT:16::SLL16
"sll r<TRD>, r<TRS>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  do_sll_mm_r7 (SD_, TRS, TRD, SHIFT_DEC);
}

001100,3.RD,3.RS,1,3.SHIFT:P16SHIFT:16::SRL16
"srl r<TRD>, r<TRS>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  do_srl_mm_r7 (SD_, TRS, TRD, SHIFT_DEC);
}

101100,5.RD,3.CODE, 2.MINOR_OPCODE:R7P16MOVE:16::MOVE16
"nop": RD == 0 && CODE == 0 && MINOR_OPCODE == 0
"break %#lx<CODE>": RD == 0 && MINOR_OPCODE == 0x1
"sdbbp %#lx<CODE>": RD == 0 && MINOR_OPCODE == 0x3
"move r<RD>, r<MOVE_RS>"
*micromips32r7:
*micromips64r7:
{
  do_p16move (SD_, RD, CODE, MINOR_OPCODE, instruction_0);
}

100110,3.RS,6.S1,1.S2:R7BEQZC16:16::BEQZC16
"beqzc r<TRS>, <ADDRESS8>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_beqzc (SD_, TRS, EXTEND8 (ADDRESS8), NIA);
}

101110,3.RS,6.S1,1.S2:R7BNEZC16:16::BNEZC16
"bnezc r<TRS>, <ADDRESS8>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bnezc (SD_, TRS, EXTEND8 (ADDRESS8), NIA);
}

000101,3.RT,3.BASE,00,2.U:R7P16LB:16::LB16
"lb r<TRT>, <U>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[TBASE], U));
}

000101,3.RT,3.BASE,10,2.U:R7P16LB:16::LBU16
"lbu r<TRT>, <U>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = do_load (SD_, AccessLength_BYTE, GPR[TBASE], U);
}

001101,3.RT,3.BASE,0,2.U,0:R7P16LH:16::LH16
"lh r<TRT>, <U_SHIFT_1BIT>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[TBASE],
                                U_SHIFT_1BIT));
}

001101,3.RT,3.BASE,1,2.U,0:R7P16LH:16::LHU16
"lhu r<TRT>, <U_SHIFT_1BIT>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = do_load (SD_, AccessLength_HALFWORD, GPR[TBASE], U_SHIFT_1BIT);
}

110100,3.RD,7.U:R7LI16:16::LI16
"li r<TRD>, <U_DEC127>"
*micromips32r7:
*micromips64r7:
{
  GPR[TRD] = U_DEC127;
}

100101,5.RT,5.BASE:R7LW4X4:16::LW4X4
"lw r<TRT4>, <U_LW4X4>(r<TBASE4>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT4] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[TBASE4], U_LW4X4));
}

011101,3.RT,3.BASE,4.U:R7LW16:16::LW16
"lw r<TRT>, <U_SHIFT_2BIT>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[TBASE],
                                U_SHIFT_2BIT));
}

101101,3.RT,7.U:R7LWGP16:16::LWGP16
"lw r<TRT>, <U_SHIFT_2BIT>(gp)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[28],
                                U_SHIFT_2BIT));
}

010101,5.RT,5.U:R7LWSP:16::LWSP
"lw r<TRT>, <U_SHIFT_2BIT>(sp)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND32 (do_load (SD_, AccessLength_WORD, SP, U_SHIFT_2BIT));
}

010100,3.RD,3.RS,3.RT,1:R7POOL16C_0:16::LWXS16
"lwxs r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  GPR[TRD] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[TRS] << 2,
                                GPR[TRT]));
}

111000,5.RT,9.S1,10.S2,1,1.S3:R7PAUIPC:32::AxUIPC
"auipc r<RT>, <AXUIPC_S_HI>":RT != 0 && AXUIPC_S_LO==0
"aluipc r28, <AXUIPC_S_HI>":RT == 0 && AXUIPC_S_LO==0
"auipc r<RT>, <AXUIPC_S_HI>, <AXUIPC_S_LO>":RT != 0
"aluipc r28, <AXUIPC_S_HI>, <AXUIPC_S_LO>"
*micromips32r7:
*micromips64r7:
{
  do_pauipc(SD_, RT, AXUIPC_S);
}

001000,5.RT,5.RS,0100101,100,111,111:R7POOL32A0:32::CLO
"clo r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_clo (SD_, RT, RS);
}

001000,5.RT,5.RS,0101101,100,111,111:R7POOL32A0:32::CLZ
"clz r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_clz (SD_, RT, RS);
}

101111,1.RS4,1.RD20,3.RS2_0,1.RT4,1.RD21,3.RT2_0:R7MOVEP:16::MOVEP
"movep r<TRD2>, r<TRE2>, r<TRS2>, r<TRT2>"
*micromips32r7:
*micromips64r7:
{
  GPR[TRD2] = GPR[TRS2];
  GPR[TRE2] = GPR[TRT2];
}

000101,3.RT_S,3.BASE,01,2.U:R7P16LB:16::SB16
"sb r<TRT_S>, <U>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GPR[TBASE], U, GPR[TRT_S]);
}

001101,3.RT_S,3.BASE,0,2.U,1:R7P16LH:16::SH16
"sh r<TRT_S>, <U_SHIFT_1BIT>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[TBASE], U_SHIFT_1BIT, GPR[TRT_S]);
}

111101,3.RT_S,3.BASE,4.U:R7SW16:16::SW16
"sw r<TRT_S>, <U_SHIFT_2BIT>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[TBASE], U_SHIFT_2BIT, GPR[TRT_S]);
}

110101,5.RT,5.U:R7SWSP:16::SWSP
"sw r<TRT>, <U_SHIFT_2BIT>(sp)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, SP, U_SHIFT_2BIT, GPR[TRT]);
}

001110,9.S1,1.S2:R7BALC16:16::BALC16
"balc <ADDRESS11>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_balc16 (SD_, EXTEND11 (ADDRESS11));
}

000010,1,24.S1,1.S2:R7PBAL:32::BALC
"balc <ADDRESS26>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_balc16 (SD_, EXTEND26 (ADDRESS26));
}

000110,9.S1,1.S2:R7BC16:16::BC16
"bc <ADDRESS11>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bc16 (SD_, EXTEND11 (ADDRESS11));
}

000010,0,24.S1,1.S2:R7PBAL:32::BC
"bc <ADDRESS26>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bc16 (SD_, EXTEND26 (ADDRESS26));
}

101010,5.RS!0,0,19.S1,1.S2:R7PBZ:32::BEQZC
"beqzc r<RS>, <ADDRESS21>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_beqzc (SD_, RS, EXTEND21 (ADDRESS21), NIA);
}

101010,5.RS!0,1,19.S1,1.S2:R7PBZ:32::BNEZC
"bnezc r<RS>, <ADDRESS21>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bnezc (SD_, RS, EXTEND21 (ADDRESS21), NIA);
}

010110,3.RT,3.RS,4.U!0:R7P16BR1:16::BxxxC16
"beqc r<TRS>, r<TRT>, <U_SHIFT_1BIT>":RS<RT
"bnec r<TRS>, r<TRT>, <U_SHIFT_1BIT>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_beqc16_bnec16 (SD_, TRS, TRT, U_SHIFT_1BIT, NIA);
}

111010,5.RT,5.RS,00,13.S1,1.S2:R7PBR2:32::BEQC
"beqc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bxxxc (SD_, RS, RT, EXTEND15 (ADDRESS15), NIA);
}

111010,5.RT,5.RS,01,13.S1,1.S2:R7PBR2:32::BNEC
"bnec r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bnxxxc (SD_, RS, RT, EXTEND15 (ADDRESS15), NIA);
}

100000,5.RT,5.RS,1110,0,5.MSBD,0,5.LSB:R7PINS:32::INS
"ins r<RT>, r<RS>, <INS_POS>, <INS_SIZE>"
*micromips32r7:
*micromips64r7:
{
  do_ins_mm_r7 (SD_, RT, RS, INS_POS, INS_SIZE);
}

100010,5.RT,5.RS,0000,12.OFFSET:R7PJ:32::JIALC
"jrc r<RS>": RT==31 && OFFSET==0
"jalrc r<RS>": RT==31 && OFFSET==0
"jalrc r<RT>, r<RS>": OFFSET==0
"jialc r<RS>, <OFFSET>": RT==31
"jialc r<RT>, r<RS>, <OFFSET>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_jialc_mm_r7 (SD_, RT, RS, OFFSET);
}

010010,5.RS,000,7.U,10.S1,1.S2:P7PBRI:32::BEQIC
"beqic r<RS>, <U>, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if (GPR[RS] != 0) {
    NIA = P7PBRI_ADDRESS;
  }
}

110010,5.RT,5.RS,00,13.S1,1.S2:P7PBR1:32::BGEC
"bgec r<RS>, r<RT>, <P7PBR1_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
   if (GPR[RS] >= GPR[RT]) {
     NIA = P7PBR1_ADDRESS;
   }
}

010010,5.RS,101,7.U,10.S1,1.S2:P7PBRI:32::BGEIC
"bgeic r<RS>, <U>, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if (GPR[RS] >= U) {
    NIA = P7PBRI_ADDRESS;
  }
}

# BGEUC
110010,5.RT,5.RS,10,13.S1,1.S2:P7PBR1:32::BGEUC
"bgeuc r<RS>, r<RT>, <P7PBR1_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((unsigned32) (GPR[RS]) >= (unsigned32) (GPR[RT])) {
    NIA = P7PBR1_ADDRESS;
  }
}

010010,5.RS,111,7.U,10.S1,1.S2:P7PBRI:32::BGEUIC
"bgeuic r<RS>, <U>, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((unsigned32) (GPR[RS]) >= U) {
    NIA = P7PBRI_ADDRESS;
  }
}

110010,5.RT,5.RS,01,13.S1,1.S2:P7PBR1:32::BLTC
"bltc r<RS>, r<RT>, <P7PBR1_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if (GPR[RS] < GPR[RT]) {
    NIA = P7PBR1_ADDRESS;
  }
}

010010,5.RS,100,7.U,10.S1,1.S2:P7PBRI:32::BLTIC
"bltic r<RS>, <U>, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if (GPR[RS] < U) {
    NIA = P7PBRI_ADDRESS;
  }
}

110010,5.RT,5.RS,11,13.S1,1.S2:P7PBR1:32::BLTUC
"bltuc r<RS>, r<RT>, <P7PBR1_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((unsigned32) (GPR[RS]) < (unsigned32)(GPR[RT])) {
    NIA = P7PBR1_ADDRESS;
  }
}

010010,5.RS,110,7.U,10.S1,1.S2:P7PBRI:32::BLTUIC
"bltuic RS, U, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if ((unsigned32)(GPR[RS]) < U) {
    NIA = P7PBRI_ADDRESS;
  }
}

010010,5.RS,001,7.U,10.S1,1.S2:P7PBRI:32::BNEIC
"bneic RS, U, <P7PBRI_ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  if (GPR[RS] != U) {
    NIA = P7PBRI_ADDRESS;
  }
}

000000,5.RT!0,5.RS,1.S1,00,13.S2:R7PPADDIU:32::ADDIU
"addiu r<RT>, r<RS>, <S_14_BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[RS]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], EXTEND14 (S_14_BIT));
  GPR[RT] = EXTEND32 (GPR[RS] + EXTEND14 (S_14_BIT));
  TRACE_ALU_RESULT (GPR[RT]);
}

010000,5.RT,19.U,00:R7PGPREL:32::ADDIUGP
"addiu r<RT>, GP, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[GPIDX]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[GPIDX], U_SHIFT_2BIT);
  GPR[RT] = GPR[GPIDX] + U_SHIFT_2BIT;
  TRACE_ALU_RESULT (GPR[RT]);
}

011100,3.RD,1,6.U:R7P16ADDIU1:16::ADDIUR1SP
"addiu r<TRD>, SP, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[SPIDX]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[SPIDX], U_SHIFT_2BIT);
  GPR[TRD] = EXTEND32 (GPR[SPIDX] + U_SHIFT_2BIT);
  TRACE_ALU_RESULT (GPR[TRD]);
}

100100,3.RD,3.RS,0,3.U:R7P16ADDIU2:16::ADDIUR2
"addiu r<TRD>, r<TRS>, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[TRS]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[TRS], U_SHIFT_2BIT);
  GPR[TRD] = EXTEND32 (GPR[TRS] + U_SHIFT_2BIT);
  TRACE_ALU_RESULT (GPR[TRD]);
}

100100,5.RD,1.S1,1,3.S2:R7P16ADDIU2:16::ADDIURS5
"addiu r<TRD>, <S_4_BIT>"
*micromips32r7:
*micromips64r7:
{
  if (NotWordValue (GPR[TRD]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[TRD], EXTEND4 (S_4_BIT));
  GPR[TRD] = EXTEND32 (GPR[TRD] + EXTEND4 (S_4_BIT));
  TRACE_ALU_RESULT (GPR[TRD]);
}


001000,00000,5.RS,01,00011,101,111,111:R7POOL32A0:32::DI
"di":RS == 0
"di r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_di (SD_, RS);
}

001000,00000,5.RS,01,01011,101,111,111:R7POOL32A0:32::EI
"ei":RS == 0
"ei r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_ei (SD_, RS);
}

101001,5.OP,5.BASE,1.S1,0011001,8.S2:R7PLSS1:32::CACHE
"cache <OP>, <S_8_BIT>(r<BASE>)"
*micromips32r7:
*micromips64r7:
{
  address_word vaddr;
  address_word paddr;
  int uncached;
  vaddr = loadstore_ea (SD_, GPR[BASE], EXTEND9 (S_8_BIT));
  if (AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET,
                          isREAL))
    CacheOp (OP, vaddr, paddr, instruction_0);
}

011010,1.RS1,1.RD,3.RS2,20.S1,1.S2:R7MOVEBALC:32::MOVE.BALC
"move.balc r<RD1>, r<RS_5_BIT>, <ADDRESS22>"
*micromips32r7:
*micromips64r7:
{
  GPR[RD1] = GPR[RS_5_BIT];
  NIA = do_balc16 (SD_, EXTEND22 (ADDRESS22));
}

100010,5.RT,5.RS,0001,12.U:R7PJ:32::JIALC.HB
"jalrc.hb r<RS>":RT==31&&U==0
"jalrc.hb r<RT>, r<RS>":U==0
"jialc.hb r<RS>, <U>":RT==31
"jialc.hb r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_jialc_mm_r7 (SD_, RT, RS, U);
  //TODO: ClearHazards()?
}

100000,5.RT,5.RS,11110,5.MSBD,0,5.LSB:R7PEXT:32::EXT
"ext r<RT>, r<RS>, <LSB>, <MSBD+1>"
*micromips32r7:
*micromips64r7:
{
  if (LSB + MSBD + 1 > 32)
    Unpredictable ();

  TRACE_ALU_INPUT3 (GPR[RS], LSB,  MSBD + 1);
  GPR[RT] = EXTEND32 (zero_extend(SD_, GPR[RS] >> LSB, MSBD + 1));
  TRACE_ALU_RESULT1 (GPR[RT]);
}
