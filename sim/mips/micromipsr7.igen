// Simulator definition for the micromips ASE.
// Copyright (C) 2005-2014 Free Software Foundation, Inc.
// Contributed by Imagination Technologies, Ltd.
// Written by Ali Lown <ali.lown@imgtec.com>
//
// This file is part of GDB, the GNU debugger.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

:compute:::int:U_SHIFT_1BIT:U:(U << 1)
:compute:::int:U_SHIFT_2BIT:U:(U << 2)
:compute:::int:U_SHIFT_3BIT:U:(U << 3)
:compute:::int:EU_127:EU:((EU == 127) ? -1 \: EU)
:compute:::int:U_LW4X4:U2,U3:((U3 << 3) | (U2 << 2))
:compute:::int:AXUIPC_S_LO:S1,S2,S3:((EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12))) & 0x0000ffff)
:compute:::int:AXUIPC_S_HI:S1,S2,S3:((EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12))) & 0xffff0000)
:compute:::int:AXUIPC_S:S1,S2,S3:(EXTEND32((S3 << 31) | (S2 << 21) | (S1 << 12)))
:compute:::int:TRD2:RD20,RD21:(compute_gpr2_dest1_reg (SD_, (RD21 << 1 | RD20)))
:compute:::int:TRE2:RD20,RD21:(compute_gpr2_dest2_reg (SD_, (RD21 << 1 | RD20)))
:compute:::int:TRS2:RS4,RS2_0:((RS4 << 4) | RS2_0)
:compute:::int:TRT2:RT4,RT2_0:((RT4 << 4) | RT2_0)
:compute:::int:TRD2_REV:RD4,RD2_0:((RD4 << 4) | RD2_0)
:compute:::int:TRE2_REV:RE4,RE2_0:((RE4 << 4) | RE2_0)
:compute:::int:TRS2_REV:RS20,RS21:(compute_gpr2_dest1_reg (SD_, (RS21 << 1 | RS20)))
:compute:::int:TRT2_REV:RS20,RS21:(compute_gpr2_dest2_reg (SD_, (RS21 << 1 | RS20)))
:compute:::address_word:ADDRESS8:S1,S2:(nia + EXTEND8((S2 << 7) | (S1 << 1)))
:compute:::address_word:ADDRESS11:S1,S2:(nia + EXTEND11((S2 << 10) | (S1 << 1)))
:compute:::address_word:ADDRESS15:S1,S2:(nia + EXTEND15((S2 << 14) | (S1 << 1)))
:compute:::address_word:ADDRESS21:S1,S2:(nia + EXTEND21((S2 << 20) | (S1 << 1)))
:compute:::address_word:ADDRESS22:S1,S2:(nia + EXTEND22((S2 << 21) | (S1 << 1)))
:compute:::address_word:ADDRESS26:S1,S2:(nia + EXTEND26((S2 << 25) | (S1 << 1)))
:compute:::int:INS_POS:LSB:(LSB)
:compute:::int:INS_SIZE:LSB,MSBD:(1 + MSBD - LSB)
:compute:::address_word:ADDRESS12:S1,S2:(nia + EXTEND12(S2 << 11 | S1 << 1))
:compute:::int:S_14_BIT:S1,S2:(EXTEND14 ((S1 << 13) | S2))
:compute:::int:S_4_BIT:S1,S2:(EXTEND4((S1 << 3) | S2))
:compute:::int:S_9_BIT:S1,S2:(EXTEND9((S1 << 8) | S2))
:compute:::int:S_9_BIT_LLSC:S1,S2:(EXTEND9((S1 << 8) | (S2 << 2)))
:compute:::int:RD1:RD:(compute_gpr1_dest_reg (SD_, RD))
:compute:::int:RT_5_BIT:RT1,RT2:((RT1 << 4) | RT2)
:compute:::int:RS_5_BIT:RS1,RS2:((RS1 << 4) | RS2)
:compute:::int:TRTZ:RTZ:((RTZ >= 1 && RTZ <= 3) ? (16 + RTZ) \: RTZ)
:compute:::int:EU_12_13:EU:((EU == 12) ? 255 \: ((EU == 13) ? 65535 \: EU))
:compute:::int:RS_MOVE:RS1,RS_CODE_1,RS_CODE_2:((RS1 << 3) | (RS_CODE_1 << 2) | RS_CODE_2)
:compute:::int:CODE_BREAK:RS_CODE_1,RS_CODE_2:((RS_CODE_1 << 2) | RS_CODE_2)
:compute:::int:TRD_R7:RD:((RD < 4) ? (16 + RD) \: RD)
:compute:::int:TRS_R7:RS:((RS < 4) ? (16 + RS) \: RS)
:compute:::int:TRT_R7:RT:((RT < 4) ? (16 + RT) \: RT)

:function:::unsigned32:compute_gpr2_dest1_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 4;
    case 1: return 5;
    case 2: return 6;
    case 3: return 7;
    default: return 4;
    }
}

:function:::unsigned32:compute_gpr2_dest2_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 5;
    case 1: return 6;
    case 2: return 7;
    case 3: return 8;
    default: return 5;
    }
}

:function:::unsigned32:compute_gpr1_dest_reg:int reg
*micromips32r7:
*micromips64r7:
{
  switch(reg)
    {
    case 0: return 4;
    case 1: return 5;
    default: return 4;
    }
}

:function:::unsigned:zero_extend:signed_word value, unsigned32 from_nbits
{
  unsigned32 low_bits_mask = (1 << from_nbits) - 1;
  return value & low_bits_mask;
}

:function:::void:do_save_gprs_to_stack_and_adjust_sp: int first_gpr, int count, int fp, int gp, int offset
*micromips32r7:
*micromips64r7:
{
  unsigned_word va;

  int fp_pending;
  int gp_pending;
  int num_pending;
  int idx;

  fp_pending = fp || (count==9 && !gp);
  gp_pending = gp;
  num_pending = count;

  va = GPR[SPIDX];
  if (first_gpr >= 0 && first_gpr < 32) {
    do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[first_gpr]);
    COP0_COUNT++;
  }

  while (num_pending > 0)
    {
      if (fp_pending)
        {
          do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[30]);
          fp_pending = 0;
        }
      else if (gp_pending)
        {
          do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[GPIDX]);
          gp_pending = 0;
        }
      else
        {
          idx = 16 | (num_pending - 1);
          do_store (SD_, AccessLength_WORD, va -= 4, 0, GPR[idx]);
        }
        COP0_COUNT++;
        num_pending--;
    }

  GPR[SPIDX] -= offset;
}

:function:::void:do_restore_gprs_from_stack_and_adjust_sp: int first_gpr, int count, int fp, int gp, int offset
*micromips32r7:
*micromips64r7:
{
  unsigned_word va;

  int fp_pending;
  int gp_pending;
  int num_pending;
  int idx;

  fp_pending = fp || (count==9 && !gp);
  gp_pending = gp;
  num_pending = count;

  va = GPR[SPIDX] + offset;
  if (first_gpr >= 0 && first_gpr < 32) {
    GPR[first_gpr] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
    COP0_COUNT++;
  }

  while (num_pending > 0)
    {
      if (fp_pending)
        {
          GPR[30] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
          fp_pending = 0;
        }
      else if (gp_pending)
        {
          GPR[GPIDX] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
          gp_pending = 0;
        }
      else
        {
          idx = 16 | (num_pending - 1);
          GPR[idx] = EXTEND32 (do_load(SD_, AccessLength_WORD, va -= 4, 0));
        }
        COP0_COUNT++;
        num_pending--;
    }

  GPR[SPIDX] += offset;
}

:function:::address_word:do_eret:int nc, address_word nia
*micromips32r7:
*micromips64r7:
{
  if (SR & status_ERL)
    {
      /* Oops, not yet available */
      sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
      nia = EPC;
      SR &= ~status_ERL;
    }
  else
    {
      nia = EPC;
      SR &= ~status_EXL;
      //if ( SRSCtl.HSS > 0 && Status.BEV == 0)
      //  SRSCtl.CSS = SRSCtl.PSS
  }

  if (!nc)
    LLBIT = 0;

  //TODO: ClearHazards()
  return nia;
}

:%s::::GPR_LIST_SAVE:int count
*micromips32r7:
*micromips64r7:
{
  int i;
  static char gpr_list[100];

  gpr_list[0] = '\0';

  i = 0;

  while (i<count)
    {
      char str1[3];
      if (i == 0 || i==count-1) {
        sprintf(str1, "%d", i);
        strcat (gpr_list,"s");
        strcat (gpr_list,str1);
        if(i==0 && count > 1)
          strcat (gpr_list,"-");
      }
      i++;
    }
  return (gpr_list);
}

:function:::void:do_break_r7:address_word instruction_0
{
  /* Check for some break instruction which are reserved for use by the
     simulator.  */
  unsigned int break_code = instruction_0 & HALT_INSTRUCTION_MASKR7;
  if (break_code == (HALT_INSTRUCTIONR7 & HALT_INSTRUCTION_MASKR7))
    {
      sim_engine_halt (SD, CPU, NULL, cia,
           sim_exited, (unsigned int)(A0 & 0xFFFFFFFF));
    }
  else if (break_code == (BREAKPOINT_INSTRUCTIONR7 & HALT_INSTRUCTION_MASKR7))
    {
      PC = cia;
      SignalException (BreakPoint, instruction_0);
    }

  else
    {
    /* If we get this far, we're not an instruction reserved by the sim. Raise
       the exception. */
      SignalException (BreakPoint, instruction_0);
    }
}

:%s::::GP_SAVE:int gp
*micromips32r7:
*micromips64r7:
{
  return (gp > 0) ? "gp" : "";
}

:%s::::FP_SAVE:int fp
*micromips32r7:
*micromips64r7:
{
  return (fp > 0) ? "fp" : "";
}

:%s::::RT_SAVE:int rt
*micromips32r7:
*micromips64r7:
{
  if (rt >= 16 && rt <= 23)
  {
    char str[4];
    sprintf(str, "s%d", rt-16);
    return str;
  }
  else if (rt == 28)
    return "gp";
  else if (rt == 30)
    return "fp";
  else if (rt == 31)
    return "ra";
  else if (rt >= 0 && rt < 28)
  {
    char str[4];
    sprintf(str, "r%d", rt);
    return str;
  }

  return "";
}

:%s::::IMM48:int U
*micromips32r7:
*micromips64r7:
{
  unsigned16 U2 = do_load (SD_, AccessLength_HALFWORD, CIA + 4, 0);
  unsigned32 total = U << 16 | U2;
  char str[32];
  sprintf(str, "%u", total);
  return str;
}

00000000000000000000000000000000:R7DUMMY:32,f::DUMMY0.fmt
"dummy 0"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds */
}

00000000000000000000000000000001:R7DUMMY:32,f::DUMMY1.fmt
"dummy 1"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds (needs at least 2 instructions) */
}

011100,3.RT,1,6.U:R7P16ADDIU1:16::ADDIUR1SP
"addiu r<TRT_R7>, SP, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  do_addiu (SD_, SPIDX, TRT_R7, U_SHIFT_2BIT);
}

100100,3.RT,3.RS,0,3.U:R7P16ADDIU2:16::ADDIUR2
"addiu r<TRT_R7>, r<TRS_R7>, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  do_addiu (SD_, TRS_R7, TRT_R7, U_SHIFT_2BIT);
}

100100,5.RT,1.S1,1,3.S2:R7P16ADDIU2:16::ADDIURS5
"nop":RT==0
"addiu r<RT>, <S_4_BIT>"
*micromips32r7:
*micromips64r7:
{
  if (RT != 0)
    do_addiu (SD_, RT, RT, S_4_BIT);
}

101100,3.RT,3.RS,3.RD,0:R7P16ADDU:16::ADDU16
"addu r<TRD_R7>, r<TRS_R7>, r<TRT_R7>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, TRS_R7, TRT_R7, TRD_R7);
}

010100,3.RT,3.RS,10,0,0:R7POOL16C00:16::AND16
"and r<TRT_R7>, r<TRS_R7>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, TRS_R7, TRT_R7, TRT_R7);
}

111100,3.RT,3.RS,4.EU:R7ANDI16:16::ANDI16
"andi r<TRT_R7>, r<TRS_R7>, <EU_12_13>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, TRS_R7, TRT_R7, EU_12_13);
}

001110,9.S1,1.S2:R7BALC16:16::BALC16
"balc <ADDRESS11>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(RA);
  RA = NIA | isa_mode;
  NIA = ADDRESS11;
  TRACE_ALU_RESULT(RA);

  // For cycle counting
  COP0_COUNT++;
}

000110,9.S1,1.S2:R7BC16:16::BC16
"bc <ADDRESS11>"
*micromips32r7:
*micromips64r7:
{
  NIA = ADDRESS11;
}

110110,3.RT,3.RS,4.U!0:R7P16BR1:16::BxxC16
"beqc r<TRS_R7>, r<TRT_R7>, <U_SHIFT_1BIT>":RS<RT
"bnec r<TRS_R7>, r<TRT_R7>, <U_SHIFT_1BIT>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[TRS_R7], GPR[TRT_R7]);
  if (RS < RT && GPR[TRS_R7] == GPR[TRT_R7])
    NIA = NIA + U_SHIFT_1BIT; //BEQC
  else if (RS >= RT && GPR[TRS_R7] != GPR[TRT_R7])
    NIA = NIA + U_SHIFT_1BIT; //BNEC
}

100110,3.RT,6.S1,1.S2:R7BEQZC16:16::BEQZC16
"beqzc r<TRT_R7>, <ADDRESS8>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[TRT_R7]);
  if(GPR[TRT_R7] == 0)
    NIA = ADDRESS8;
}

101110,3.RT,6.S1,1.S2:R7BNEZC16:16::BNEZC16
"bnezc r<TRT_R7>, <ADDRESS8>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[TRT_R7]);
  if(GPR[TRT_R7] != 0)
    NIA = ADDRESS8;
}

110110,5.RT,1,0000:R7P16JRC:16::JALRC16
"jalrc r<RT>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], RA);
  RA = NIA | isa_mode;
  NIA = process_isa_mode (SD_, GPR[RT]);
  TRACE_ALU_RESULT(RA);

  // For cycle counting
  COP0_COUNT++;
}

110110,5.RT,0,0000:R7P16JRC:16::JRC16
"jrc r<RT>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[RT]);
  NIA = process_isa_mode (SD_, GPR[RT]);
}

000101,3.RT,3.RS,00,2.U:R7P16LB:16::LB16
"lb r<TRT_R7>, <U>(r<TRS_R7>)"
*micromips32r7:
*micromips64r7:
{
  do_lb (SD_, TRT_R7, U, TRS_R7);
}

000101,3.RT,3.RS,10,2.U:R7P16LB:16::LBU16
"lbu r<TRT_R7>, <U>(r<TRS_R7>)"
*micromips32r7:
*micromips64r7:
{
  do_lbu (SD_, TRT_R7, U, TRS_R7);
}

001101,3.RT,3.RS,0,2.U,0:R7P16LH:16::LH16
"lh r<TRT_R7>, <U_SHIFT_1BIT>(r<TRS_R7>)"
*micromips32r7:
*micromips64r7:
{
  do_lh (SD_, TRT_R7, U_SHIFT_1BIT, TRS_R7);
}

001101,3.RT,3.RS,1,2.U,0:R7P16LH:16::LHU16
"lhu r<TRT_R7>, <U_SHIFT_1BIT>(r<TRS_R7>)"
*micromips32r7:
*micromips64r7:
{
  do_lhu (SD_, TRT_R7, U_SHIFT_1BIT, TRS_R7);
}

110100,3.RT,7.EU:R7LI16:16::LI16
"li r<TRT_R7>, <EU_127>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[TRT_R7]);
  GPR[TRT_R7] = EU_127;
  TRACE_ALU_RESULT(GPR[TRT_R7]);
}

100101,1.RT1,1.U2,3.RT2,1.RS1,1.U3,3.RS2:R7LW4X4:16::LW4X4
"lw r<RT_5_BIT>, <U_LW4X4>(r<RS_5_BIT>)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RT_5_BIT, U_LW4X4, RS_5_BIT);
}

011101,3.RT,3.RS,4.U:R7LW16:16::LW16
"lw r<TRT_R7>, <U_SHIFT_2BIT>(r<TRS_R7>)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, TRT_R7, U_SHIFT_2BIT, TRS_R7);
}

101101,3.RT,7.U:R7LWGP16:16::LWGP16
"lw r<TRT_R7>, <U_SHIFT_2BIT>(gp)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, TRT_R7, U_SHIFT_2BIT, GPIDX);
}

010101,5.RT,5.U:R7LWSP:16::LWSP
"lw r<RT>, <U_SHIFT_2BIT>(sp)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RT, U_SHIFT_2BIT, SPIDX);
}

010100,3.RT,3.RS,3.RD,1:R7POOL16C_0:16::LWXS16
"lwxs r<TRD_R7>, r<TRS_R7>(r<TRT_R7>)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, TRD_R7, GPR[TRS_R7] << 2, TRT_R7);
}

// These four instructions are grouped together because of a bug in GNUSIM
// pattern recognition
000100,5.RT,2.RS1,1.RS_CODE_1,2.RS_CODE_2:R7P16MOVE:16::P16MOVE_P16RI
"move r<RT>, r<RS_MOVE>": RT != 0
"syscall <RS_CODE_2>": RS1 == 1
"sdbbp <CODE_BREAK>": RS1 == 3
"break <CODE_BREAK>"
*micromips32r7:
*micromips64r7:
{
  if (RT == 0) {
    if (RS1 == 1)
      SignalException (SystemCall, instruction_0);
    else if (RS1 == 3)
      SignalException (DebugBreakPoint, instruction_0);
    else
      do_break_r7 (SD_, instruction_0);
  }
  else {
    TRACE_ALU_INPUT2 (GPR[RT], GPR[RS_MOVE]);
    GPR[RT] = GPR[RS_MOVE];
    TRACE_ALU_RESULT2 (GPR[RT], GPR[RS_MOVE]);
  }
}

101111,1.RT4,1.RD20,3.RT2_0,1.RS4,1.RD21,3.RS2_0:R7MOVEP:16::MOVEP
"movep r<TRD2>, r<TRE2>, r<TRS2>, r<TRT2>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT4 (GPR[TRD2], GPR[TRE2], GPR[TRS2], GPR[TRT2]);
  GPR[TRD2] = GPR[TRS2];
  GPR[TRE2] = GPR[TRT2];
  TRACE_ALU_RESULT2 (GPR[TRD2], GPR[TRE2]);

  // For cycle counting
  COP0_COUNT++;
}

111111,1.RE4,1.RS20,3.RE2_0,1.RD4,1.RS21,3.RD2_0:R7MOVEP:16::MOVEPREV
"movep r<TRD2_REV>, r<TRE2_REV>, r<TRS2_REV>, r<TRT2_REV>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT4 (GPR[TRD2_REV], GPR[TRE2_REV], GPR[TRS2_REV], GPR[TRT2_REV]);
  GPR[TRD2_REV] = GPR[TRS2_REV];
  GPR[TRE2_REV] = GPR[TRT2_REV];
  TRACE_ALU_RESULT2 (GPR[TRD2_REV], GPR[TRE2_REV]);

  // For cycle counting
  COP0_COUNT++;
}

010100,3.RT,3.RS,00,0,0:R7POOL16C00:16::NOT16
"not r<TRT_R7>, r<TRS_R7>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, 0, TRS_R7, TRT_R7);
}

010100,3.RT,3.RS,11,0,0:R7POOL16C00:16::OR16
"or r<TRT_R7>, r<TRS_R7>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, TRS_R7, TRT_R7, TRT_R7);
}

000111,4.GPR_LIST_SAVE,1,4.U,0:R7PRESTORE16:16::RESTORE16
"restore <U_SHIFT_3BIT>":GPR_LIST_SAVE==15
"restore.jrc <U_SHIFT_3BIT>":GPR_LIST_SAVE==14
"restore.jrc <U_SHIFT_3BIT>, ra, fp, s0-s7":GPR_LIST_SAVE==9
"restore.jrc <U_SHIFT_3BIT>, ra, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  if (GPR_LIST_SAVE==14 || GPR_LIST_SAVE==15)
    do_restore_gprs_from_stack_and_adjust_sp(SD_, -1, 0, 0, 0, U_SHIFT_3BIT);
  else
    do_restore_gprs_from_stack_and_adjust_sp(SD_, 31, GPR_LIST_SAVE, 0, 0,
                                             U_SHIFT_3BIT);
  if (GPR_LIST_SAVE != 15)
    NIA = process_isa_mode (SD_, RA);
}

000111,4.GPR_LIST_SAVE,0,4.U,0:R7P16SRW:16::SAVE16
"save <U_SHIFT_3BIT>": GPR_LIST_SAVE == 14 || GPR_LIST_SAVE == 15
"save <U_SHIFT_3BIT>, ra": GPR_LIST_SAVE == 0
"save <U_SHIFT_3BIT>, ra, fp, s0-s7": GPR_LIST_SAVE == 9
"save <U_SHIFT_3BIT>, ra, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  if (GPR_LIST_SAVE==14 || GPR_LIST_SAVE==15)
    do_save_gprs_to_stack_and_adjust_sp(SD_, -1, 0, 0, 0, U_SHIFT_3BIT);
  else
    do_save_gprs_to_stack_and_adjust_sp(SD_, 31, GPR_LIST_SAVE, 0, 0,
                                        U_SHIFT_3BIT);
}

000101,3.RTZ,3.RS,01,2.U:R7P16LB:16::SB16
"sb r<TRTZ>, <U>(r<TRS_R7>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GPR[TRS_R7], U, GPR[TRTZ]);
}

001101,3.RTZ,3.RS,0,2.U,1:R7P16LH:16::SH16
"sh r<TRTZ>, <U_SHIFT_1BIT>(r<TRS_R7>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[TRS_R7], U_SHIFT_1BIT, GPR[TRTZ]);
}

001100,3.RT,3.RS,0,3.SHIFT:P16SHIFT:16::SLL16
"sll r<TRT_R7>, r<TRS_R7>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  do_sll (SD_, TRS_R7, TRT_R7, SHIFT_DEC);
}

001100,3.RT,3.RS,1,3.SHIFT:P16SHIFT:16::SRL16
"srl r<TRT_R7>, r<TRS_R7>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  do_srl (SD_, TRS_R7, TRT_R7, SHIFT_DEC);
}

101100,3.RT,3.RS,3.RD,1:R7P16ADDU:16::SUBU16
"subu r<TRD_R7>, r<TRS_R7>, r<TRT_R7>"
*micromips32r7:
*micromips64r7:
{
  do_subu (SD_, TRS_R7, TRT_R7, TRD_R7);
}

111101,3.RTZ,3.RS,4.U:R7SW16:16::SW16
"sw r<TRTZ>, <U_SHIFT_2BIT>(r<TRS_R7>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[TRS_R7], U_SHIFT_2BIT, GPR[TRTZ]);
}

110101,5.RT,5.U:R7SWSP:16::SWSP
"sw r<RT>, <U_SHIFT_2BIT>(sp)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, SP, U_SHIFT_2BIT, GPR[RT]);
}

010100,3.RT,3.RS,01,0,0:R7POOL16C00:16::XOR16
"xor r<TRT_R7>, r<TRS_R7>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, TRT_R7, TRS_R7, TRT_R7);
}

// 32-bit instructions

001000,5.RT,5.RS,5.RD,0,0100010000:R7POOL32A0:32::ADD
"add r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_add (SD_, RS, RT, RD);
}

000000,5.RT!0,5.RS,1.S1,00,13.S2:R7PPADDIU:32::ADDIU
"addiu r<RT>, r<RS>, <S_14_BIT>"
*micromips32r7:
*micromips64r7:
{
  do_addiu (SD_, RS, RT, S_14_BIT);
}

010000,5.RT,19.U,00:R7PGPREL:32::ADDIUGP
"addiu r<RT>, GP, <U_SHIFT_2BIT>"
*micromips32r7:
*micromips64r7:
{
  do_addiu (SD_, GPIDX, RT, U_SHIFT_2BIT);
}

111000,5.RT,9.S1,10.S2,1,1.S3:R7PAUIPC:32::AxUIPC
"auipc r<RT>, <AXUIPC_S_HI>":RT != 0 && AXUIPC_S_LO==0
"aluipc GP, <AXUIPC_S_HI>":RT == 0 && AXUIPC_S_LO==0
"auipc r<RT>, <AXUIPC_S_HI>, <AXUIPC_S_LO>":RT != 0
"aluipc GP, <AXUIPC_S_HI>, <AXUIPC_S_LO>"
*micromips32r7:
*micromips64r7:
{
  address_word address = NIA + AXUIPC_S;
  if (RT == 0)
  {
    TRACE_ALU_INPUT2(GPR[GPIDX], address);
    GPR[GPIDX] = address & ~0xfff;
    TRACE_ALU_RESULT(GPR[GPIDX]);
  }
  else {
    TRACE_ALU_INPUT2(GPR[RT], address);
    GPR[RT] = address;
    TRACE_ALU_RESULT(GPR[RT]);
  }
}

001000,5.RT,5.RS,5.RD,0,0101010,000:R7POOL32A0:32::ADDU
"addu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,5.IMMEDIATE,011,111:R7POOL32A0:32::ALIGN
"align r<RD>, r<RS>, r<RT>, <IMMEDIATE>"
*micromips32r7:
*micromips64r7:
{
  unsigned64 tmp = (GPR[RT] << 32) | GPR[RS];
  TRACE_ALU_INPUT4 (GPR[RD], GPR[RS], GPR[RT], tmp);
  GPR[RD] = EXTEND32 (tmp >> IMMEDIATE);
  TRACE_ALU_RESULT (GPR[RD]);

}

001000,5.RT,5.RS,5.RD,0,1001010,000:R7POOL32A0:32::AND
"and r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0010,12.U:R7PU12:32::ANDI
"andi r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, RS, RT, U);
}

001010,1,24.S1,1.S2:R7PBAL:32::BALC
"balc <ADDRESS26>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(RA);
  RA = NIA | isa_mode;
  NIA = ADDRESS26;
  TRACE_ALU_RESULT(RA);

  // For cycle counting
  COP0_COUNT++;
}

001010,0,24.S1,1.S2:R7PBAL:32::BC
"bc <ADDRESS26>"
*micromips32r7:
*micromips64r7:
{
  NIA = ADDRESS26;
}

100010,5.RT,5.RS,00,13.S1,1.S2:R7PBR2:32::BEQC
"beqc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if (GPR[RS] == GPR[RT])
    NIA = ADDRESS15;
}

110010,5.RT,000,7.U,10.S1,1.S2:P7PBRI:32::BEQIC
"beqic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if (GPR[RT] == U) {
    NIA = ADDRESS12;
  }
}

111010,5.RT,0,19.S1,1.S2:R7PBZ:32::BEQZC
"beqzc r<RT>, <ADDRESS21>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[RT]);
  if (GPR[RT] == 0)
    NIA = ADDRESS21;
}

100010,5.RT,5.RS,10,13.S1,1.S2:P7PBR1:32::BGEC
"bgec r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
    NIA = ADDRESS15;
}

110010,5.RT,010,7.U,10.S1,1.S2:P7PBRI:32::BGEIC
"bgeic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if ((signed_word) GPR[RT] >= U) {
    NIA = ADDRESS12;
  }
}

100010,5.RT,5.RS,11,13.S1,1.S2:P7PBR2:32::BGEUC
"bgeuc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if ((unsigned_word) (GPR[RS]) >= (unsigned_word)(GPR[RT])) {
    NIA = ADDRESS15;
  }
}

110010,5.RT,011,7.U,10.S1,1.S2:P7PBRI:32::BGEUIC
"bgeuic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if ((unsigned_word) GPR[RT] >= U) {
    NIA = ADDRESS12;
  }
}

001000,5.RT,5.RS,0000101,100,111,111:R7POOL32A0:32::BITSWAP
"bitswap r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_bitswap (SD_, RT, RS);
}

101010,5.RT,5.RS,10,13.S1,1.S2:P7PBR1:32::BLTC
"bltc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
    NIA = ADDRESS15;
}

110010,5.RT,110,7.U,10.S1,1.S2:P7PBRI:32::BLTIC
"bltic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if ((signed_word) GPR[RT] < U) {
    NIA = ADDRESS12;
  }
}

101010,5.RT,5.RS,11,13.S1,1.S2:P7PBR2:32::BLTUC
"bltuc r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT]) {
    NIA = ADDRESS15;
  }
}

110010,5.RT,111,7.U,10.S1,1.S2:P7PBRI:32::BLTUIC
"bltuic <RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if ((unsigned_word) GPR[RT] < U) {
    NIA = ADDRESS12;
  }
}

101010,5.RT,5.RS,00,13.S1,1.S2:R7PBR2:32::BNEC
"bnec r<RS>, r<RT>, <ADDRESS15>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RS], GPR[RT]);
  if (GPR[RS] != GPR[RT])
    NIA = ADDRESS15;
}

110010,5.RT,100,7.U,10.S1,1.S2:P7PBRI:32::BNEIC
"bneic r<RT>, <U>, <ADDRESS12>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RT], U);
  if (GPR[RT] != U) {
    NIA = ADDRESS12;
  }
}

111010,5.RT!0,1,19.S1,1.S2:R7PBZ:32::BNEZC
"bnezc r<RT>, <ADDRESS21>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT1(GPR[RT]);
  if (GPR[RT] != 0)
    NIA = ADDRESS21;
}

000000,00000,10,19.CODE:R7PRI:32::BREAK
"break %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  do_break_r7 (SD_, instruction_0);
}

101001,5.OP,5.RS,1.S1,0011001,8.S2:R7PLSS1:32::CACHE
"cache <OP>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_cache (SD_, OP, RS, S_9_BIT, instruction_0);
}

001000,5.RT,5.RS,0100101,100,111,111:R7POOL32A0:32::CLO
"clo r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_clo (SD_, RT, RS);
}

001000,5.RT,5.RS,0101101,100,111,111:R7POOL32A0:32::CLZ
"clz r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_clz (SD_, RT, RS);
}

001000,5.RT,00000,01,00011,101,111,111:R7POOL32A0:32::DI
"di":RT == 0
"di r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_di (SD_, RT);
}

001000,5.RT,5.RS,5.RD,0,0100011,000:R7POOL32A0:32::DIV
"div r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_div (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0110011,000:R7POOL32A0:32::DIVU
"divu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_divu (SD_, RD, RS, RT);
}

001000,5.RT,00000,01,01011,101,111,111:R7POOL32A0:32::EI
"ei":RT == 0
"ei r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_ei (SD_, RT);
}

001000,000000000,0,11,11001,101,111,111:R7POOL32A0:32::ERET
"eret"
*micromips32r7:
*micromips64r7:
{
  //TODO: signal coprocessor_exception(0) if !IsCoprocessor0Enabled()
  NIA = do_eret(SD_, 0, NIA);
}

001000,000000000,1,11,11001,101,111,111:R7POOL32A0:32::ERETNC
"eretnc"
*micromips32r7:
*micromips64r7:
{
  //TODO: signal coprocessor_exception(0) if !IsCoprocessor0Enabled()
  NIA = do_eret(SD_, 1, NIA);
}

100000,5.RT,5.RS,11110,5.MSBD,0,5.LSB:R7PEXT:32::EXT
"ext r<RT>, r<RS>, <LSB>, <MSBD+1>"
*micromips32r7:
*micromips64r7:
{
  if (LSB + MSBD + 1 > 32)
    Unpredictable ();

  do_ext (SD_, RT, RS, LSB, MSBD);
}

100000,5.RT,5.RS,1110,0,5.MSBD,0,5.LSB:R7PINS:32::INS
"ins r<RT>, r<RS>, <INS_POS>, <INS_SIZE>"
*micromips32r7:
*micromips64r7:
{
  if ((1 + MSBD - LSB) < 1)
    Unpredictable ();
  do_ins (SD_, RT, RS, LSB, MSBD);
}

010010,5.RT,5.RS,0000,12.X:R7PJ:32::JALRC
"jalrc r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = NIA | isa_mode;
  unsigned_word address = GPR[RS];
  isa_mode = address & 1;
  NIA = address & ~1;

  // For cycle counting
  COP0_COUNT++;
}

010010,5.RT,5.RS,0001,12.X:R7PJ:32::JALRC.HB
"jalrc.hb r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = NIA | isa_mode;
  unsigned_word address = GPR[RS];
  isa_mode = address & 1;
  NIA = address & ~1;
  //TODO: ClearHazards()?

  // For cycle counting
  COP0_COUNT++;
}

100001,5.RT,5.RS,0000,12.U:R7PLSU12:32::LB
"lb r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lb (SD_, RT, U, RS);
}

010001,5.RT,000,18.U:R7PLSGP:32::LBGP
"lb r<RT>, <U>(GP)"
*micromips32r7:
*micromips64r7:
{
  do_lb (SD_, RT, U, GPIDX);
}

101001,5.RT,5.RS,1.S1,0000000,8.S2:R7PLSS0:32::LBS9
"lb r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lb (SD_, RT, S_9_BIT, RS);
}

100001,5.RT,5.RS,0010,12.U:R7PLSU12:32::LBU
"lbu r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lbu (SD_, RT, U, RS);
}

010001,5.RT,010,18.U:R7PLSGP:32::LBUGP
"lbu r<RT>, <U>(GP)"
*micromips32r7:
*micromips64r7:
{
  do_lbu (SD_, RT, U, GPIDX);
}

101001,5.RT,5.RS,1.S1,0010,0,00,8.S2:R7PLSS0:32::LBUS9
"lbu r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lbu (SD_, RT, S_9_BIT, RS);
}

001000,5.RT,5.RS,5.RD,0010,0,000,111:R7PPLSX:32::LBUX
"lbux r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lbu (SD_, RD, GPR[RS], RT);
}

001000,5.RT,5.RS,5.RD,0000,0,000,111:R7PPLSX:32::LBX
"lbx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lb (SD_, RD, GPR[RS], RT);
}

100001,5.RT,5.RS,0100,12.U:R7PLSU12:32::LH
"lh r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lh (SD_, RT, U, RS);
}

010001,5.RT,100,18.U:R7PLSGP:32::LHGP
"lh r<RT>, <U>(GP)"
*micromips32r7:
*micromips64r7:
{
  do_lh (SD_, RT, U, GPIDX);
}

101001,5.RT,5.RS,1.S1,0100,0,00,8.S2:R7PLSS0:32::LHS9
"lh r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lh (SD_, RT, S_9_BIT, RS);
}

100001,5.RT,5.RS,0110,12.U:R7PLSU12:32::LHU
"lhu r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lhu (SD_, RT, U, RS);
}

010001,5.RT,110,18.U:R7PLSGP:32::LHUGP
"lhu r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  do_lhu (SD_, RT, U, GPIDX);
}

101001,5.RT,5.RS,1.S1,0110,0,00,8.S2:R7PLSS0:32::LHUS9
"lhu r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lhu (SD_, RT, S_9_BIT, RS);
}

001000,5.RT,5.RS,5.RD,0110,0,000,111:R7PPLSX:32::LHUX
"lhux r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lhu (SD_, RD, GPR[RS], RT);
}

001000,5.RT,5.RS,5.RD,0110,1,000,111:R7PPLSXS:32::LHUXS
"lhux r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lhu (SD_, RD, GPR[RS] << 1, RT);
}

001000,5.RT,5.RS,5.RD,0100,0,000,111:R7PPLSX:32::LHX
"lhx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lh (SD_, RD, GPR[RS], RT);
}

001000,5.RT,5.RS,5.RD,0100,1,000,111:R7PPLSXS:32::LHXS
"lhxs r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lh (SD_, RD, GPR[RS] << 1, RT);
}

101001,5.RT,5.RS,1.S1,1000,0,01,6.S2,00:R7PLL:32::LL
"ll r<RT>, <S_9_BIT_LLSC>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT_LLSC, GPR[RS]);
  do_ll (SD_, RT, S_9_BIT_LLSC, RS);
  TRACE_ALU_RESULT(GPR[RT]);
}

001000,5.RT,5.RS,5.RD,2.U,000,001,111:R7POOL32A7:32::LSA
"lsa r<RD>, r<RS>, r<RT>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_lsa (SD_, RD, RS, RT, U);
}

111000,5.RT,9.S1,10.S2,0,1.S3:R7PLUI:32::LUI
"lui r<RT>, <AXUIPC_S_HI>, <AXUIPC_S_LO>":AXUIPC_S_LO != 0
"lui r<RT>, <AXUIPC_S_HI>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2 (GPR[RT], AXUIPC_S);
  GPR[RT] = AXUIPC_S;
  TRACE_ALU_RESULT (GPR[RT]);
}

100001,5.RT,5.RS,1000,12.U:R7PLSU12:32::LW
"lw r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RT, U, RS);
}

101001,5.RT,5.RS,1.S1,1000000,8.S2:R7SWS9:32::LWS9
"lw r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RT, S_9_BIT, RS);
}

010000,5.RT,19.U,10:R7LWGP:32::LWGP
"lw r<RT>, <U_SHIFT_2BIT>(GP)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RT, U_SHIFT_2BIT, GPIDX);
}

001000,5.RT,5.RS,5.RD,1000,0,000,111:R7PPLSX:32::LWX
"lwx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RD, GPR[RS], RT);
}

001000,5.RT,5.RS,5.RD,1000,1,000,111:R7PPLSXS:32::LWXS
"lwxs r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_lw (SD_, RD, GPR[RS] << 2, RT);
}

001000,5.RT,5.C0S,2.X1,3.SEL,1.X2,0000110,000:R7POOL32A0:32::MFC0
"mfc0 r<RT>, r<C0S>, <SEL>"
*micromips32r7:
*micromips64r7:
{
  DecodeCoproc (instruction_0, 0, cp0_mfc0, RT, C0S, SEL);
}

001000,5.RT,5.RS,5.RD,00101011000:R7POOL32A0:32::MOD
"mod r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_mod (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,00111011000:R7POOL32A0:32::MODU
"modu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_modu (SD_, RD, RS, RT);
}

000010,1.RT1,1.RD,3.RT2,20.S1,1.S2:R7MOVEBALC:32::MOVE.BALC
"move.balc r<RD1>, r<RT_5_BIT>, <ADDRESS22>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT2(GPR[RD1], GPR[RT_5_BIT]);
  GPR[RD1] = GPR[RT_5_BIT];
  RA = NIA | isa_mode;
  NIA = ADDRESS22;
  TRACE_ALU_RESULT(GPR[RD1]);

  // For cycle counting
  COP0_COUNT += 2;
}

001000,5.RT,5.RS,5.RD,11000010000:R7POOL32A0:32::MOVN
"movn r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_movn (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,1000010,000:R7POOL32A0:32::MOVZ
"movz r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_movz (SD_, RD, RS, RT);
}

001000,5.RT,5.C0S,2.X1,3.SEL,1.X2,0001110,000:R7POOL32A0:32::MTC0
"mtc0 r<RT>, r<C0S>, <SEL>"
*micromips32r7:
*micromips64r7:
{
  DecodeCoproc (instruction_0, 0, cp0_mtc0, RT, C0S, SEL);
}

001000,5.RT,5.RS,5.RD,0,0001011,000:R7POOL32A0:32::MUH
"muh r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_muh (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0011011,000:R7POOL32A0:32::MUHU
"muhu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_muhu (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0000011,000:R7POOL32A0:32::MUL
"mul r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_mul (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0010011,000:R7POOL32A0:32::MULU
"mulu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_mulu (SD_, RD, RS, RT);
}

10000000000,5.X1,1100,3.X2,000000000:R7PHB:32::NOP
"nop"
*micromips32r7:
*micromips64r7:
{
}

001000,5.RT,5.RS,5.RD,0,1011010,000:R7POOL32A0:32::NOR
"nor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1010010,000:R7POOL32A0:32::OR
"or r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0000,12.U:R7PU12:32::ORI
"ori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_ori (SD_, RS, RT, U);
}

100000,00000,5.X1,1100,3.X2,0000,00101:R7PHB:32::PAUSE
"pause"
*micromips32r7:
*micromips64r7:
{
  sim_io_printf (SD, "Not implemented");
}

101001,5.HINT!31,5.RS,1.S1,0011,0,00,8.S2:R7PPREFS:32::PREF
"pref <HINT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_pref (SD_, HINT, S_9_BIT, RS);
}

100000,5.RT_SAVE,4.GPR_LIST_SAVE,10011,9.U,0,1.FP_SAVE,1.GP_SAVE:R7PRESTORE:32::RESTORE
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>": GPR_LIST_SAVE == 0
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GPR_LIST_SAVE>": (!FP_SAVE && !GP_SAVE) && GPR_LIST_SAVE != 0
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>": FP_SAVE && !GP_SAVE && GPR_LIST_SAVE < 2
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GPR_LIST_SAVE>" : FP_SAVE && !GP_SAVE && GPR_LIST_SAVE >=2
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>": GP_SAVE && !FP_SAVE && GPR_LIST_SAVE < 2
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>" : !FP_SAVE && GP_SAVE && GPR_LIST_SAVE >=2
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>": (FP_SAVE && GP_SAVE) && GPR_LIST_SAVE < 3
"restore <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  do_restore_gprs_from_stack_and_adjust_sp(SD_, RT_SAVE, GPR_LIST_SAVE, FP_SAVE,
                                           GP_SAVE, U_SHIFT_3BIT);
}

100000,5.RT_SAVE,4.GPR_LIST_SAVE,10011,9.U,1,1.FP_SAVE,1.GP_SAVE:R7PRESTORE:32::RESTORE.JRC
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>": GPR_LIST_SAVE == 0
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GPR_LIST_SAVE>": (!FP_SAVE && !GP_SAVE) && GPR_LIST_SAVE != 0
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>": FP_SAVE && !GP_SAVE && GPR_LIST_SAVE < 2
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GPR_LIST_SAVE>" : FP_SAVE && !GP_SAVE && GPR_LIST_SAVE >=2
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>": GP_SAVE && !FP_SAVE && GPR_LIST_SAVE < 2
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>" : !FP_SAVE && GP_SAVE && GPR_LIST_SAVE >=2
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>": (FP_SAVE && GP_SAVE) && GPR_LIST_SAVE < 3
"restore.jrc <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  do_restore_gprs_from_stack_and_adjust_sp(SD_, RT_SAVE, GPR_LIST_SAVE, FP_SAVE,
                                           GP_SAVE, U_SHIFT_3BIT);

  isa_mode =  GPR[RAIDX] & 0x1;
  NIA = GPR[RAIDX] & ~1;
}

100000,5.RT,5.RS,1100,000,0110,5.SHIFT:R7PSHIFT:32::ROTR
"rotr r<RT>, r<RS>, <SHIFT>"
*micromips32r7:
*micromips64r7:
{
  GPR[RT] = do_ror (SD_, GPR[RS], SHIFT);
}

001000,5.RT,5.RS,5.RD,0,0011010,000:R7POOL32A0:32::ROTRV
"rotrv r<RD>, r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  unsigned32 shift = GPR[RT] & 0x1f;
  GPR[RD] = do_ror (SD_, GPR[RS], shift);
}

001000,5.RT,5.RS,5.RD,0,1100010,000:R7POOL32A0:32::XOR
"xor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0001,12.U:R7PU12:32::XORI
"xori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_xori (SD_, RS, RT, U);
}

100000,5.RT_SAVE,4.GPR_LIST_SAVE,0,0011,9.U,1.X,1.FP_SAVE,1.GP_SAVE:R7PSR:32::SAVE
"save <U_SHIFT_3BIT>, %s<RT_SAVE>": GPR_LIST_SAVE == 0
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GPR_LIST_SAVE>": (!FP_SAVE && !GP_SAVE) && GPR_LIST_SAVE != 0
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>": FP_SAVE && !GP_SAVE && GPR_LIST_SAVE < 2
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GPR_LIST_SAVE>" : FP_SAVE && !GP_SAVE && GPR_LIST_SAVE >=2
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>": GP_SAVE && !FP_SAVE && GPR_LIST_SAVE < 2
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>" : !FP_SAVE && GP_SAVE && GPR_LIST_SAVE >=2
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>": (FP_SAVE && GP_SAVE) && GPR_LIST_SAVE < 3
"save <U_SHIFT_3BIT>, %s<RT_SAVE>, %s<FP_SAVE>, %s<GP_SAVE>, %s<GPR_LIST_SAVE>"
*micromips32r7:
*micromips64r7:
{
  do_save_gprs_to_stack_and_adjust_sp(SD_, RT_SAVE, GPR_LIST_SAVE, FP_SAVE,
                                      GP_SAVE, U_SHIFT_3BIT);
}

100001,5.RT,5.RS,0001,12.U:R7PLSU12:32::SB
"sb r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GPR[RS], U, GPR[RT]);
}

010001,5.RT,001,18.U:R7PLSGP:32::SBGP
"sb r<RT>, <U>(gp)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GP, U, GPR[RT]);
}

101001,5.RT,5.RS,1.S1,0001,0,00,8.S2:R7PLSS0:32::SBS9
"sb r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GPR[RS], S_9_BIT, GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0001,0,000,111:R7PPLSX:32::SBX
"sbx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_BYTE, GPR[RT], GPR[RS], GPR[RD]);
}

101001,5.RT,5.RS,1.S1,1001,0,01,6.S2,00:R7PSC:32::SC
"sc r<RT>, <S_9_BIT_LLSC>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_sc (SD_, RT, S_9_BIT_LLSC, RS, instruction_0);
}

001000,5.RT,5.RS,0010101100111111:R7POOL32A0:32::SEB
"seb r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_seb (SD_, RT, RS);
}

001000,5.RT,5.RS,0011101,100,111,111:R7POOL32A0:32::SEH
"seh r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_seh (SD_, RT, RS);
}

100000,5.RT,5.RS,0110,12.IMMEDIATE:R7PU12:32::SEQI
"seqi r<RT>, r<RS>, <IMMEDIATE>"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[RT], GPR[RS], IMMEDIATE);
  GPR[RT] = (GPR[RS] == IMMEDIATE) ? 1 : 0;
  TRACE_ALU_RESULT(GPR[RT]);
}

100001,5.RT,5.RS,0101,12.U:R7PLSU12:32::SH
"sh r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[RS], U, GPR[RT]);
}

010001,5.RT,101,18.U:R7PLSGP:32::SHGP
"sh r<RT>, <U>(GP)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GP, U, GPR[RT]);
}

101001,5.RT,5.RS,1.S1,0101,0,00,8.S2:R7PLSS0:32::SHS9
"sh r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[RS], S_9_BIT, GPR[RT]);
}

001000,5.RT,5.RS,5.RD,0101,0,000,111:R7PPLSX:32::SHX
"shx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[RT], GPR[RS], GPR[RD]);
}

001000,5.RT,5.RS,5.RD,0101,1,000,111:R7PPLSXS:32::SHXS
"shxs r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[RT], GPR[RS] << 1, GPR[RD]);
}

000000,00000,00,19.CODE:R7PRI:32::SIGRIE
"sigrie %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (ReservedInstruction, instruction_0);
}


100000,5.RT!0,5.RS,1100,3.X,0000,5.SHIFT:R7PSHIFT:32::SLL
"sll r<RT>, r<RS>, <SHIFT>"
*micromips32r7:
*micromips64r7:
{
  do_sll (SD_, RS, RT, SHIFT);
}

001000,5.RT,5.RS,5.RD,0,0000010,000:R7POOL32A0:32::SLLV
"sllv r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_sllv (SD_, RT, RS, RD);
}

001000,5.RT,5.RS,5.RD,0,1101010,000:R7POOL32A0:32::SLT
"slt r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_slt (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0100,12.IMMEDIATE:R7PU12:32::SLTI
"slti r<RT>, r<RS>, <IMMEDIATE>"
*micromips32r7:
*micromips64r7:
{
  do_slti (SD_, RS, RT, EXTEND12(IMMEDIATE));
}

100000,5.RT,5.RS,0101,12.U:R7PU12:32::SLTIU
"sltiu r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_sltiu (SD_, RS, RT, EXTEND12(U));
}

001000,5.RT,5.RS,5.RD!0,0,1110010,000:R7POOL32A0:32::SLTU
"sltu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_sltu (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,1100,3.X,0100,5.SHIFT:R7PSHIFT:32::SRA
"sra r<RT>, r<RS>, <SHIFT>"
*micromips32r7:
*micromips64r7:
{
  do_sra (SD_, RS, RT, SHIFT);
}

001000,5.RT,5.RS,5.RD,0,0010010,000:R7POOL32A0:32::SRAV
"srav r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_srav (SD_, RT, RS, RD);
}

100000,5.RT,5.RS,11000000010,5.SHIFT:R7PSHIFT:32::SRL
"srl r<RT>, r<RS>, <SHIFT>"
*micromips32r7:
*micromips64r7:
{
  do_srl (SD_, RS, RT, SHIFT);
}

001000,5.RT,5.RS,5.RD,0,0001010,000:R7POOL32A0:32::SRLV
"srlv r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_srlv (SD_, RT, RS, RD);
}

001000,5.RT,5.RS,5.RD,1.X,0110010,000:R7POOL32A0:32::SUB
"sub r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_sub (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,1.X,0111010,000:R7POOL32A0:32::SUBU
"subu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_subu (SD_, RS, RT, RD);
}

100001,5.RT,5.RS,1001,12.U:R7SW:32::SW
"sw r<RT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[RS], U, GPR[RT]);
}

101001,5.RT,5.RS,1.S1,1001000,8.S2:R7SWS9:32::SWS9
"sw r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[RS], S_9_BIT, GPR[RT]);
}

010000,5.RT,19.U,11:R7SWGP:32::SWGP
"sw r<RT>, <U_SHIFT_2BIT>(GP)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GP, U_SHIFT_2BIT, GPR[RT]);
}

001000,5.RT,5.RS,5.RD,1001,0,000,111:R7PPLSX:32::SWX
"swx r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[RT], GPR[RS], GPR[RD]);
}

001000,5.RT,5.RS,5.RD,1001,1,000,111:R7PPLSXS:32::SWXS
"swxs r<RD>, r<RS>(r<RT>)"
*micromips32r7:
*micromips64r7:
{
  do_store (SD_, AccessLength_WORD, GPR[RT], GPR[RS] << 2, GPR[RD]);
}

100111,1.RT1,1.U2,3.RT2,1.RS1,1.U3,3.RS2:R7SW4X4:16::SW4X4
"sw r<RT_5_BIT>, <U_LW4X4>(r<RS_5_BIT>)"
*micromips32r7:
*micromips64r7:
{
  do_sw (SD_, RT_5_BIT, U_LW4X4, RS_5_BIT);
}

100000,00000,5.STYPE,1100,3.X,0000,00110:R7PHB:32::SYNC
"sync":STYPE==0
"sync <STYPE>"
*micromips32r7:
*micromips64r7:
{
  SyncOperation (STYPE);
}

101001,11111,5.RS,1.S1,0011,0,00,8.S2:R7PPREFS:32::SYNCI
"synci <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  // sync i-cache - nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

000000,00000,11,19.CODE:R7PRI:32::SDBBP
"sdbbp %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (DebugBreakPoint, instruction_0);
}

001000,5.RT,5.RS,0111101,100,111,111:R7POOL32A0:32::WSBH
"wsbh r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_wsbh (SD_, RT, RS);
}

001000,10.X,00,00001,101,111,111:R7POOL32AXF5GROUP0:32::TLBP
"tlbp"
*micromips32r7:
*micromips64r7:
{
  // nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

001000,10.X,00,10001,101,111,111:R7POOL32AXF5GROUP0:32::TLBWI
"tlbwi"
*micromips32r7:
*micromips64r7:
{
  // nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

001000,10.X,00,11001,101,111,111:R7POOL32AXF5GROUP0:32::TLBWR
"tlbwr"
*micromips32r7:
*micromips64r7:
{
  // nothing to do currently
  sim_io_printf (SD, "Not implemented");
}


001000,0000000000,01,00001,101,111,111:R7POOL32AXF5GROUP1:32::TLBINV
"tlbinv"
*micromips32r7:
*micromips64r7:
{
  // invalidate a set of TLB entries based on ASID and Index match - nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

001000,0000000000,01,01001,101,111,111:R7POOL32AXF5GROUP1:32::TLBINVF
"tlbinvf"
*micromips32r7:
*micromips64r7:
{
  // invalidate a set of TLB entries based on Index match - nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

001000,10.CODE,10,00101,101,111,111:R7PSYSCALL:32::SYSCALL
"syscall %#lx<CODE>"
*micromips32r7:
*micromips64r7:
{
  SignalException (SystemCall, instruction_0);
}

100000,00000,5.X1,1100,3.X2,0000,00011:R7PHB:32::EHB
"ehb"
*micromips32r7:
*micromips64r7:
{
  sim_io_printf (SD, "Not implemented");
}

101001,5.RT,5.RS,1.S1,0000001,8.S2:R7PLSS1:32::UALW
"ualw r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  address_word base = GPR[RS];

  TRACE_ALU_INPUT3(GPR[RT], S_9_BIT, GPR[RS]);
  GPR[RT] = do_load_right (SD_, AccessLength_WORD, base, EXTEND16 (S_9_BIT),
                           GPR[RT]);
  GPR[RT] = do_load_left (SD_, AccessLength_WORD, base,
                          EXTEND16 (S_9_BIT + AccessLength_WORD), GPR[RT]);
  TRACE_ALU_RESULT(GPR[RT]);
}

101001,5.RT,5.RS,1.S1,0001001,8.S2:R7PLSS1:32::UASW
"uasw r<RT>, <S_9_BIT>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  do_store_right (SD_, AccessLength_WORD, GPR[RS], EXTEND16 (S_9_BIT), GPR[RT]);
  do_store_left (SD_, AccessLength_WORD, GPR[RS],
                 EXTEND16 (S_9_BIT + AccessLength_WORD), GPR[RT]);
}

001000,5.RT,5.X,00000,0,1110010,000:R7PDVP:32::DVP
"dvp r<RT>"
*micromips32r7:
*micromips64r7:
{
  // nothing to do currently
  sim_io_printf (SD, "Not implemented");
}


001000,5.RT,5.HS,2.X1,3.SEL,1.X2,0111000,000:R7POOL32A0:32::RDHWR
"rdhwr r<HS>, r<RT>, <SEL>"
*micromips32r7:
*micromips64r7:
{
  do_rdhwr (SD_, RT, HS);
}

001000,5.RT,5.RS,11,10000,101,111,111:R7POOL32A0:32::RDPGPR
"rdpgpr r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  // nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

001000,5.RT,5.RS,5.RD,1.X,1111010,000:R7POOL32A0:32::SOV
"SOV r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  // nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

001000,10.X,11,10001,101,111,111:R7POOL32A0:32::DERET
"deret"
*micromips32r7:
*micromips64r7:
{
  // nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

001000,5.RT,5.X,00000,1,1110010,000:R7PDVP:32::EVP
"evp r<RT>" : RT!=0
"evp"
*micromips32r7:
*micromips64r7:
{
  // nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

001000,10.CODE,110000110,1111111:R7POOL32AXF5GROUP2:32::WAIT
"wait"
*micromips32r7:
*micromips64r7:
{
  // nothing to do currently
  sim_io_printf (SD, "Not implemented");
}

// FIXME: there should be a better way to implement 48-bit instructions
011000,5.RT,00000,16.IMM48:R7POOL48I:32::LI48
"li r<RT>, %s<IMM48>"
*micromips32r7:
*micromips64r7:
{
  unsigned16 U2 = do_load (SD_, AccessLength_HALFWORD, CIA + 4, 0);
  unsigned32 total = IMM48 << 16 | U2;
  TRACE_ALU_INPUT2(GPR[RT], total);
  GPR[RT] = EXTEND32(total);
  TRACE_ALU_RESULT(GPR[RT]);
  NIA = CIA + 6;
}

011000,5.RT,00001,16.IMM48:R7POOL48I:32::ADDIU48
"addiu r<RT>, %s<IMM48>"
*micromips32r7:
*micromips64r7:
{
  unsigned16 S2 = do_load(SD_, AccessLength_HALFWORD, CIA + 4, 0);
  unsigned32 total = IMM48 << 16 | S2;
  do_addiu(SD_, RT, RT, total);
  NIA = CIA + 6;
}

011000,5.RT,00010,16.IMM48:R7POOL48I:32::ADDIUGP48
"addiu r<RT>, GP, %s<IMM48>"
*micromips32r7:
*micromips64r7:
{
  unsigned16 S2 = do_load(SD_, AccessLength_HALFWORD, CIA + 4, 0);
  unsigned32 total = IMM48 << 16 | S2;
  do_addiu (SD_, GPIDX, RT, total);
  NIA = CIA + 6;
}

010010,5.RT!0,5.RS,1000,2.X1,0,9.X2:R7PBALRC:32::BALRC
"balrc r<RT> r<RS>"
*micromips32r7:
*micromips64r7:
{
  unsigned_word address = NIA + GPR[RS];

  GPR[RT] = NIA | isa_mode;
  isa_mode = address & 1;
  NIA = address & ~1;
}


010010,5.RT!0,5.RS,1000,2.X1,1,9.X2:R7PBALRSC:32::BALRSC
"balrsc r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  unsigned_word address = NIA + (GPR[RS] << 1);

  GPR[RT] = NIA | isa_mode;
  isa_mode = address & 1;
  NIA = address & ~1;
}

//////////////////////////////////////////////////////////////////////
// Not yet in the specification.
//////////////////////////////////////////////////////////////////////

100001,5.FT,5.RS,1111,12.U:R7PLSU12:32::SDC1
"sdc1 r<FT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[FT], U, GPR[RS]);
  do_store (SD_, AccessLength_DOUBLEWORD, GPR[RS], EXTEND16 (U), COP_SD (1, FT));
  unsigned64 temp;
  COP_LD (1, temp, do_load (SD_, AccessLength_DOUBLEWORD, GPR[RS], EXTEND16 (U)));
  TRACE_ALU_RESULT(temp);
}

100001,5.FT,5.RS,1110,12.U:R7PLSU12:32::LDC1
"ldc1 r<FT>, <U>(r<RS>)"
*micromips32r7:
*micromips64r7:
{
  TRACE_ALU_INPUT3(GPR[FT], U, GPR[RS]);
  COP_LD (1, FT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[RS], EXTEND16 (U)));
  TRACE_ALU_RESULT(GPR[FT]);
}

100001,5.FT,5.BASE,1010,12.OFFSET:R7PLSU12:32::LWC1
"lwc1 f<FT>, <OFFSET>(r<BASE>)"
*micromips32r7:
*micromips64r7:
{
  do_lwc1 (SD_, FT, OFFSET, BASE);
}

111001,5.BASE,5.FT,16.OFFSET:R7PLSU12:32::SWC1
"swc1 f<FT>, <OFFSET>(r<BASE>)"
*micromips32r7:
*micromips64r7:
{
  do_swc1 (SD_, FT, OFFSET, BASE, instruction_0);
}

