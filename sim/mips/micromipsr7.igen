// Simulator definition for the micromips ASE.
// Copyright (C) 2005-2014 Free Software Foundation, Inc.
// Contributed by Imagination Technologies, Ltd.
// Written by Ali Lown <ali.lown@imgtec.com>
//
// This file is part of GDB, the GNU debugger.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

:compute:::int:ADDRESS:S1,S2:((S1 << 1) + S2)
:compute:::int:U_SHIFT_1BIT:U:(U << 1)
:compute:::int:U_DEC127:U:((U < 127) ? U \: -1)

00000000000000000000000000000000:R7DUMMY:32,f::DUMMY0.fmt
"dummy 0"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds */
}

00000000000000000000000000000001:R7DUMMY:32,f::DUMMY1.fmt
"dummy 1"
*mips32r7:
*mips64r7:
{
  /* Just needed so GNUSIM builds (needs at least 2 instructions) */
}

001000,5.RT,5.RS,5.RD,0,1001010,000:R7POOL32A0:32::AND
"and r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1010010,000:R7POOL32A0:32::OR
"or r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1100010,000:R7POOL32A0:32::XOR
"xor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, RS, RT, RD);
}

001000,5.RT,5.RS,5.RD,0,1011010,000:R7POOL32A0:32::NOR
"nor r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, RS, RT, RD);
}

100000,5.RT,5.RS,0010,12.U:R7PU12:32::ANDI
"andi r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, RS, RT, U);
}

100000,5.RT,5.RS,0000,12.U:R7PU12:32::ORI
"ori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_ori (SD_, RS, RT, U);
}

100000,5.RT,5.RS,0001,12.U:R7PU12:32::XORI
"xori r<RT>, r<RS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_xori (SD_, RS, RT, U);
}

010100,3.RD,3.RS,10,0,0:R7POOL16C00:16::AND16
"and16 r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_and (SD_, TRS, TRD, TRD);
}

010100,3.RD,3.RS,11,0,0:R7POOL16C00:16::OR16
"or16 r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_or (SD_, TRS, TRD, TRD);
}

000100,3.RD,3.RS,3.RT,0:R7P16ADDU:16::ADDU16
"addu16 r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, TRS, TRT, TRD);
}

001000,5.RT,5.RS,5.RD,0,0101010,000:R7POOL32A0:32::ADDU
"addu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_addu (SD_, RS, RT, RD);
}

000100,3.RD,3.RS,3.RT,1:R7P16ADDU:16::SUBU16
"subu16 r<TRD>, r<TRS>, r<TRT>"
*micromips32r7:
*micromips64r7:
{
  do_subu (SD_, TRS, TRT, TRD);
}

001000,5.RT,5.RS,5.RD,0,0110011,000:R7POOL32A0:32::DIVU
"divu r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_divu (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,5.RD,0,0100011,000:R7POOL32A0:32::DIV
"div r<RD>, r<RS>, r<RT>"
*micromips32r7:
*micromips64r7:
{
  do_div (SD_, RD, RS, RT);
}

001000,5.RT,5.RS,0000101,100,111,111:R7POOL32A0:32::BITSWAP
"bitswap r<RT>, r<RS>"
*micromips32r7:
*micromips64r7:
{
  do_bitswap (SD_, RT, RS);
}

001000,5.RT,5.RS,5.RD,2.IMMEDIATE,000,011,111:R7POOL32A0:32::ALIGN
"align r<RD>, r<RS>, r<RT>, <IMMEDIATE>"
*micromips32r7:
*micromips64r7:
{
  do_align (SD_, RD, RS, RT, IMMEDIATE);
}

010110,5.RS,0,0000:R7P16JRC:16::JRC16
"jrc16 r<TRS>"
*micromips32r7:
*micromips64r7:
{
  NIA = process_isa_mode (SD_, GPR[TRS]);
}

010110,5.RS,1,0000:R7P16JRC:16::JALRC16
"jalrc16 r<TRS>"
*micromips32r7:
*micromips64r7:
{
  RA = NIA | ISA_MODE_MICROMIPS;
  NIA = process_isa_mode (SD_, GPR[TRS]);
}

010100,3.RD,3.RS,01,0,0:R7POOL16C00:16::XOR16
"xor16 r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_xor (SD_, TRS, TRD, TRD);
}

010100,3.RD,3.RS,00,0,0:R7POOL16C00:16::NOT16
"not16 r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  do_nor (SD_, 0, TRS, TRD);
}

111100,3.RD,3.RS,4.U:R7ANDI16:16::ANDI16
"andi16 r<TRD>, r<TRS>, <U>"
*micromips32r7:
*micromips64r7:
{
  do_andi (SD_, TRS, TRD, U);
}

001100,3.RD,3.RS,0,3.SHIFT:P16SHIFT:16::SLL16
"sll16 r<TRD>, r<TRS>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  do_sll (SD_, TRS, TRD, SHIFT_DEC);
}

001100,3.RD,3.RS,1,3.SHIFT:P16SHIFT:16::SRL16
"srl16 r<TRD>, r<TRS>, <SHIFT_DEC>"
*micromips32r7:
*micromips64r7:
{
  do_srl (SD_, TRS, TRD, SHIFT_DEC);
}

101100,5.RD,5.RS:P16MOVE:16::MOVE16
"nop":RD==0&&RS==0
"move16 r<TRD>, r<TRS>"
*micromips32r7:
*micromips64r7:
{
  GPR[TRD] = GPR[TRS];
}

100110,3.RS,6.S1,1.S2:R7BEQZC16:16::BEQZC16
"beqzc16 r<TRS>, <ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_beqzc (SD_, TRS, EXTEND7 (ADDRESS), NIA);
}

101110,3.RS,6.S1,1.S2:R7BNEZC16:16::BNEZC16
"bnezc16 r<TRS>, <ADDRESS>"
*micromips32r7:
*micromips64r7:
{
  NIA = do_bnezc (SD_, TRS, EXTEND7 (ADDRESS), NIA);
}

000101,3.RT,3.BASE,00,2.U:R7P16LB:16::LB16
"lb16 r<TRT>, <U>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[TBASE], U));
}

000101,3.RT,3.BASE,10,2.U:R7P16LB:16::LBU16
"lbu16 r<TRT>, <U>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = do_load (SD_, AccessLength_BYTE, GPR[TBASE], U);
}

001101,3.RT,3.BASE,0,2.U,0:R7P16LH:16::LH16
"lh16 r<TRT>, <U>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[TBASE],
                                U_SHIFT_1BIT));
}

001101,3.RT,3.BASE,1,2.U,0:R7P16LH:16::LHU16
"lhu16 r<TRT>, <U>(r<TBASE>)"
*micromips32r7:
*micromips64r7:
{
  GPR[TRT] = do_load (SD_, AccessLength_HALFWORD, GPR[TBASE], U_SHIFT_1BIT);
}

110100,3.RD,7.U:R7LI16:16::LI16
"li16 r<TRD>, <U_DEC127>"
*micromips32r7:
*micromips64r7:
{
  GPR[TRD] = U_DEC127;
}
