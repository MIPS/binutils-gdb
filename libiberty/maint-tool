#!/usr/bin/perl
# -*- perl -*-

#   Copyright (C) 2001
#   Free Software Foundation
#
# This file is part of the libiberty library.
# Libiberty is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# Libiberty is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with libiberty; see the file COPYING.LIB.  If not,
# write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
# Originally written by DJ Delorie <dj@redhat.com>


# This is a trivial script which checks the lists of C and O files in
# the Makefile for consistency.

$mode = shift;
$srcdir = ".";

if ($mode eq "-s") {
    $srcdir = shift;
    $mode = shift;
}

&missing() if $mode eq "missing";
&undoc() if $mode eq "undoc";

exit 0;

format STDOUT =
^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~
$out
        ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~
$out
.

######################################################################

sub missing {

    opendir(S, $srcdir);
    while ($f = readdir S) {
	$have{$f} = 1;
    }
    closedir(S);
    opendir(S, ".");
    while ($f = readdir S) {
	$have{$f} = 1;
    }
    closedir(S);

    for $a (@ARGV) {
	$listed{$a} = 1;
	$have{$a} = 0;
    }

    for $f (sort keys %have) {
	next unless $have{$f};
	if ($f =~ /\.c$/) {
	    print "S $f\n";
	}
    }
    for $f (sort keys %listed) {
	if ($f =~ /(.*)\.c$/) {
	    $base = $1;
	    if (! $listed{"$base.o"}) {
		print "O $f\n";
	    }
	}
    }
}

######################################################################

sub undoc {

    opendir(S, $srcdir);
    while ($file = readdir S) {
	if ($file =~ /\.texi$/) {
	    open(T, "$srcdir/$file");
	    while (<T>) {
		if (/^\@deftype[^\(]* ([^\s\(]+) *\(/) {
		    $documented{$1} = 1;
		}
	    }
	    close(T);
	}
	if ($file =~ /\.c$/) {
	    open(C, "$srcdir/$file");
	    while (<C>) {
		if (/\@undocumented (\S+)/) {
		    $documented{$1} = 1;
		}
		if (/^static /) {
		    if (! /[\(;]/) {
			s/[\r\n]+$/ /;
			$_ .= <C>;
		    }
		    while ($_ =~ /\([^\)]*$/) {
			s/[\r\n]+$/ /;
			$_ .= <C>;
		    }
		}
		s/ VPARAMS([ \(])/$1/;
		s/PREFIX\(([^\)]*)\)/byte_$1/;
		if (/^static [^\(]* ([^\s\(]+) *\(.*\)$/) {
		    $documented{$1} = 1;
		}
	    }
	}
    }
    closedir(D);

    # $out = join(' ', sort keys %documented);
    # write;
    # print "\n";

    system "etags $srcdir/*.c $srcdir/../include/*.h";
    open(TAGS, "TAGS");
    while (<TAGS>) {
	s/[\r\n]+$//;
	if (/^\014$/) {
	    $filename = <TAGS>;
	    $filename =~ s/[\r\n]+$//;
	    $filename =~ s/,\d+$//;
	    $filename =~ s@.*[/\\]@@;
	    next;
	}
	if ($filename =~ /\.c$/ ) {
	    next unless /^[_a-zA-Z]/;
	} else {
	    next unless /^\# *define/;
	    s/\# *define *//;
	}
	next if $filename =~ /mpw\.c/;

	s/ VPARAMS//;
	s/ *\177.*//;
	s/,$//;
	s/DEFUN\(//;
	s/\(//;

	next if /^static /;
	next if /\s/;
	next if /^_/;
	next if $documented{$_};
	next if /_H_?$/;

	if ($seen_in{$_} ne $filename) {
	    $saw{$_} ++;
	}
	$seen_in{$_} = $filename;
    }

    for $k (keys %saw) {
	delete $saw{$k} if $saw{$k} > 1;
    }

    for $k (sort keys %saw) {
	$fromfile{$seen_in{$k}} .= " " if $fromfile{$seen_in{$k}};
	$fromfile{$seen_in{$k}} .= $k;
    }

    for $f (sort keys %fromfile) {
	$out = "$f: $fromfile{$f}";
	write;
    }
}
