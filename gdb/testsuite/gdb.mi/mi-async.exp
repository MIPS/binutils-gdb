# Copyright 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

#
# Test asynchronous Machine Interface (MI) operations
#

load_lib mi-support.exp
set saved_gdbflags $GDBFLAGS
set GDBFLAGS "-nw --async"
set MIFLAGS "-i=mi"
#set verbose 3

gdb_exit
if [mi_gdb_start] {
    continue
}

set testfile "basics"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug additional_flags=-DFAKEARGV}] != "" } {
     untested mi-async.exp
     return -1
}

mi_delete_breakpoints
mi_gdb_reinitialize_dir $srcdir/$subdir
mi_gdb_load ${binfile}

# mi_gdb_test cannot be used for asynchronous commands because there are
# two prompts involved and this can lead to a race condition.

proc linux_async_tests {} {
    global mi_gdb_prompt
    global hex

    set line_main_head     [gdb_get_line_number "main ("]
    set line_main_body     [expr $line_main_head + 2]
    set line_main_next     [expr $line_main_head + 3]

    send_gdb "start\n"
    gdb_expect {
	-re ".*\\^running\r\n\\^done\r\n$mi_gdb_prompt" {
	    gdb_expect {
		-re "\\*stopped,thread-id=\"0\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",line=\"$line_main_body\"\}\r\n$mi_gdb_prompt$" {
		    pass "Asynchronous response after start command"
		}
		-re ".*$mi_gdb_prompt$" {
		    fail "Asynchronous response after start command (2)"
		}
		timeout	{
		    fail "Asynchronous response after start command (timeout 2)"
		}
	    }
	}
	-re ".*$mi_gdb_prompt$" {
	    fail "Asynchronous response after start command (1)"
	}
	timeout {fail "Asynchronous response after start command (timeout 1)"}
    }

    send_gdb "next\n"
    gdb_expect {
	-re "\\^running\r\n\\^done\r\n$mi_gdb_prompt" {
	    gdb_expect {
		-re "\\*stopped,reason=\"end-stepping-range\",thread-id=\"0\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",line=\"$line_main_next\"\}\r\n$mi_gdb_prompt$" {
		    pass "Asynchronous response after next command"
		}
		-re ".*$mi_gdb_prompt$" {
		    fail "Asynchronous response after next command (2)"
		}
		timeout {
		    fail "Asynchronous response after next command (timeout 2)"
		}
	    }
	}
	-re ".*$mi_gdb_prompt$" {
	    fail "Asynchronous response after next command (1)"
	}
	timeout {fail "Asynchronous response after next command (timeout 1)"}
    }

    send_gdb "start\n"
    gdb_expect {
	-re ".*\\^running\r\n\\^done\r\n$mi_gdb_prompt" {
	    gdb_expect {
		-re "\\*stopped,thread-id=\"0\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",line=\"$line_main_body\"\}\r\n$mi_gdb_prompt$" {
		    pass "Asynchronous response after (re) start"
		}
		-re ".*$mi_gdb_prompt$" {
		    fail "Asynchronous response after (re) start (2)"
		}
		timeout	{
		    fail "Asynchronous response after (re) start (timeout 2)"
		}
	    }
	}
	-re ".*$mi_gdb_prompt$" {
	    fail "Asynchronous response after (re) start (1)"
	}
	timeout {fail "Asynchronous response after (re) start (timeout 1)"}
    }
}


#if [istarget "i386-*-linux-gnu"] then {
    linux_async_tests
#}

mi_gdb_exit

set GDBFLAGS $saved_gdbflags

return 0
