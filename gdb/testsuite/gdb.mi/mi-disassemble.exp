#   Copyright (C) 1999, 2000 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

#
# Test Machine interface (MI) operations for disassembly.
#
# The goal is not to test gdb functionality, which is done by other tests,
# but to verify the correct output response to MI operations.
#

load_lib mi-support.exp

gdb_exit
if [mi_gdb_start] {
    continue
}

set testfile "basics"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug additional_flags=-DFAKEARGV}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

mi_delete_breakpoints
mi_gdb_reinitialize_dir $srcdir/$subdir
mi_gdb_load ${binfile}

proc test_breakpoints_creation_and_listing {} {
    global mi_gdb_prompt
    global srcfile
    global hex

    # Insert some breakpoints and list them
    # Also, disable some so they do not interfere with other tests
    # Tests:
    # -break-insert
    # -break-list
    # -break-disable
    # -break-info

    mi_gdb_test "200-break-insert main" \
             "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",line=\"32\",times=\"0\"\}" \
             "break-insert operation"

    mi_gdb_test "204-break-list" \
                "204\\^done,BreakpointTable=\{hdr=\{.*\},bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",line=\"32\",times=\"0\"\}\}" \
                "list of breakpoints"
}

proc test_running_the_program {} {
    global mi_gdb_prompt
    global hex

    # Run the program without args
    # Tests:
    # -exec-run

    # mi_gdb_test cannot be used for asynchronous commands because there are
    # two prompts involved and this can lead to a race condition.
    # FIXME: We are accepting a duplicate file and line info temporarely.
    # The following is equivalent to a send_gdb "000-exec-run\n"
    mi_run_cmd
    # The running part has been checked already by mi_run_cmd
        gdb_expect {
	    -re "\[\r\n\]*000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"0\",frame=\{addr=\"$hex\",func=\"main\",args=\{\},file=\".*basics.c\",line=\"32\"\}\r\n$mi_gdb_prompt$" {
            pass "run to main"
          }
          -re ".*$mi_gdb_prompt$" {fail "run to main (2)"}
          timeout {fail "run to main (timeout 2)"}
        }
}

proc test_disassembly_only {} {
    global mi_gdb_prompt
    global hex

    # Test disassembly more only for the current function.
    # Tests:
    # -data-disassembly $pc 0 0 -1
    # -data-disassembly main 0 0 -1
    # -data-disassembly $pc $pc+8 0 -1
    # -data-disassembly callee2 0 0 -1

    mi_gdb_test "print/x \$pc" "" ""
    mi_gdb_test "111-data-disassemble \$pc 0 0 -1" \
	    "111\\^done,asm_insns=\{\{address=\"$hex <main>\",inst=\".*\"\},\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\},\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\},.*\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}" \
             "data-disassemble from pc assembly only"

    mi_gdb_test "222-data-disassemble main 0 0 -1" \
	    "222\\^done,asm_insns=\{\{address=\"$hex <main>\",inst=\".*\"\},\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}" \
              "data-disassemble main assembly only"

    mi_gdb_test "333-data-disassemble \$pc \$pc+8 0 -1" \
	    "333\\^done,asm_insns=\{\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\},\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}" \
             "data-disassemble range assembly only"

    mi_gdb_test "444-data-disassemble callee2 0 0 -1" \
	    "444\\^done,asm_insns=\{\{address=\"$hex <callee2\[0-9\]*>\",inst=\".*\"\},.*\{address=\"$hex <callee2\\+\[0-9\]*>\",inst=\".*\"\}\}" \
             "data-disassemble callee2 assembly only"

}

proc test_disassembly_lines_limit {} {
    global mi_gdb_prompt
    global hex

    # Test disassembly more only for the current function.
    # Tests:
    # -data-disassembly $pc 0 0 2
    # -data-disassembly main 0 0 1
    # -data-disassembly main 0 0 0
    # -data-disassembly $pc $pc+8 0 99
    # -data-disassembly $pc $pc+12 0 2

    mi_gdb_test "print/x \$pc" "" ""
    mi_gdb_test "100-data-disassemble \$pc 0 0 2" \
	    "100\\^done,asm_insns=\{\{address=\"$hex <main\[0-9\]*>\",inst=\".*\"\},\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}" \
             "data-disassemble from pc two lines - assembly only"

    mi_gdb_test "200-data-disassemble main 0 0 1" \
	    "200\\^done,asm_insns=\{\{address=\"$hex <main\[0-9\]*>\",inst=\".*\"\}\}" \
	    "data-disassemble main 1 line - assembly only"

    mi_gdb_test "300-data-disassemble main 0 0 0" \
             "300\\^done,asm_insns=\{\}" \
             "data-disassemble main zero lines - assembly only"

    mi_gdb_test "400-data-disassemble \$pc \$pc+8 0 99" \
	    "400\\^done,asm_insns=\{\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\},\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}" \
             "data-disassemble lines bigger than range - assembly only"

    mi_gdb_test "500-data-disassemble \$pc \$pc+12 0 2" \
	    "500\\^done,asm_insns=\{\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\},\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}" \
             "data-disassemble lines less than range - assembly only"
}

proc test_disassembly_mixed {} {
    global mi_gdb_prompt
    global hex
    global decimal

    # Test disassembly more only for the current function.
    # Tests:
    # -data-disassembly main 0 1 -1
    # -data-disassembly $pc $pc+8 1 -1
    # -data-disassembly callee2 0 1 -1

    mi_gdb_test "002-data-disassemble callee2 0 1 -1" \
	    "002\\^done,asm_insns=\{src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\{address=\"$hex <callee2\[0-9\]*>\",inst=\".*\"\}\}\},src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{.*\{address=\"$hex <callee2\\+\[0-9\]*>\",inst=\".*\"\}\}\}\}" \
             "data-disassemble callee2 assembly mixed"

    #
    # In mixed mode, the lowest level of granularity is the source line.
    # So we are going to get the disassembly for the source line at
    # which we are now.
    #
    mi_gdb_test "003-data-disassemble \$pc \$pc+8 1 -1" \
	    "003\\^done,asm_insns=\{src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}.*\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}\}\}" \
             "data-disassemble range assembly mixed"

    mi_gdb_test "004-data-disassemble callee2 0 1 -1" \
	    "004\\^done,asm_insns=\{src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\{address=\"$hex <callee2\[0-9\]*>\",inst=\".*\"\}\}\},.*src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{.*\{address=\"$hex <callee2\\+\[0-9\]*>\",inst=\".*\"\}\}\}\}" \
             "data-disassemble callee2 assembly mixed"
}

proc test_disassembly_mixed_lines_limit {} {
    global mi_gdb_prompt
    global hex
    global decimal

    # Test disassembly more only for the current function.
    # Tests:
    # -data-disassembly $pc 0 1 2
    # -data-disassembly main 0 1 1
    # -data-disassembly main 0 1 0
    # -data-disassembly $pc $pc+4 1 99
    # -data-disassembly $pc $pc+12 1 2

    mi_gdb_test "print/x \$pc" "" ""
    mi_gdb_test "100-data-disassemble \$pc 0 1 2" \
	    "100\\^done,asm_insns=\{src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\{address=\"$hex <main\[0-9\]*>\",inst=\".*\"\}\}\},src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}\}\}" \
             "data-disassemble from pc two lines - assembly mixed"

    mi_gdb_test "200-data-disassemble main 0 1 1" \
	    "200\\^done,asm_insns=\{src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\{address=\"$hex <main\[0-9\]*>\",inst=\".*\"\}\}\}\}" \
	    "data-disassemble main 1 line - assembly mixed"

    mi_gdb_test "300-data-disassemble main 0 1 0" \
	    "300\\^done,asm_insns=\{src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\}\}\}" \
             "data-disassemble main zero lines - assembly mixed"

    mi_gdb_test "400-data-disassemble \$pc \$pc+4 1 99" \
	    "400\\^done,asm_insns=\{src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}.*\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}\}\}" \
             "data-disassemble lines bigger than range - assembly mixed"

    mi_gdb_test "500-data-disassemble \$pc \$pc+12 1 2" \
	    "500\\^done,asm_insns=\{src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\},\{address=\"$hex <main\\+\[0-9\]*>\",inst=\".*\"\}\}\}\}" \
             "data-disassemble lines less than range - assembly mixed"
}

proc test_disassembly_bogus_args {} {
    global mi_gdb_prompt
    global hex

    # Test that bogus input to disassembly command is rejected.
    # Tests:
    # -data-disassembly 0 0 0 0
    # -data-disassembly 0 0 0
    # -data-disassembly 0 0 
    # -data-disassembly 0

    mi_gdb_test "123-data-disassemble 0 0 0 0" \
             ".*123\\^error,msg=\"No function contains specified address\"" \
             "data-disassemble bogus arguments"

    mi_gdb_test "321-data-disassemble 0 0 0" \
             "321\\^error,msg=\"mi_cmd_disassemble: Usage: start_address end_address mixed_mode num_of_lines.\"" \
             "data-disassemble wrong num of args (3)"

    mi_gdb_test "456-data-disassemble 0 0" \
             "456\\^error,msg=\"mi_cmd_disassemble: Usage: start_address end_address mixed_mode num_of_lines.\"" \
             "data-disassemble wrong num of args (2)"

    mi_gdb_test "789-data-disassemble 0" \
             "789\\^error,msg=\"mi_cmd_disassemble: Usage: start_address end_address mixed_mode num_of_lines.\"" \
             "data-disassemble wrong num of args (1)"

}

proc test_disassembly_mixed_from_pc {} {
    global mi_gdb_prompt
    global hex
    global decimal

    # Test disassembly more only for the current function.
    # Tests:
    # -data-disassembly $pc 0 1 -1

    mi_gdb_test "200-break-insert callee2" \
             "200\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"callee2\",file=\".*basics.c\",line=\"22\",times=\"0\"\}" \
             "break-insert operation for mixed"

    send_gdb "123-exec-continue\n"
    gdb_expect {
      -re "123\\^running\r\n$mi_gdb_prompt" {
	  gdb_expect {
	      -re "\[\r\n\]*123\\*stopped,reason=\"breakpoint-hit\",bkptno=\"2\",thread-id=\"0\",frame=\{addr=\"$hex\",func=\"callee2\",args=\{.*\},file=\".*basics.c\",line=\"22\"\}\r\n$mi_gdb_prompt$" {
		  pass "run to callee2"
	      }
	      -re ".*$mi_gdb_prompt$" {fail "run to callee2 (2)"}
	      timeout {fail "run to callee2 (timeout 2)"}
	  }
      }
      -re ".*$mi_gdb_prompt$" {fail "continue to callee2 (1)"}
      timeout {fail "continue to callee2 (timeout 1)"}
    }

    mi_gdb_test "001-data-disassemble \$pc 0 1 -1" \
	    "001\\^done,asm_insns=\{src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{\{address=\"$hex <callee2\[0-9\]*>\",inst=\".*\"\}\}\},src_and_asm_line=\{line=\"$decimal\",file=\".*basics.c\",line_asm_insn=\{.*\{address=\"$hex <callee2\\+\[0-9\]*>\",inst=\".*\"\}\}\}\}" \
             "data-disassemble from pc assembly mixed"

}

test_breakpoints_creation_and_listing
test_running_the_program
test_disassembly_only
test_disassembly_mixed
test_disassembly_bogus_args
test_disassembly_lines_limit
test_disassembly_mixed_lines_limit
test_disassembly_mixed_from_pc

mi_gdb_exit
return 0

# Local variables: 
# change-log-default-name: "ChangeLog-mi"
# End: 
