# Copyright (C) 2011 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

set testfile amd64-entry-value
set srcfile ${testfile}.s
set opts {}

if [info exists COMPILE] {
    # make check RUNTESTFLAGS="gdb.arch/amd64-entry-value.exp COMPILE=1"
    set srcfile ${testfile}.cc
    lappend opts debug optimize=-O2
} elseif { ![istarget x86_64-*-* ] || ![is_lp64_target] } {
    verbose "Skipping amd64-entry-value."
    return
}

if { [prepare_for_testing ${testfile}.exp ${testfile} ${srcfile} $opts] } {
    return -1
}

if ![runto_main] {
    return -1
}

gdb_breakpoint "breakhere"


# Test @entry values for register passed parameters.

gdb_continue_to_breakpoint "entry: breakhere"

gdb_test "bt" "^bt\r\n#0 +d *\\(i=31, j=31\\.5\\) \[^\r\n\]*\r\n#1 +0x\[0-9a-f\]+ in main .*" \
	 "entry: bt"
gdb_test "p i" " = 31" "entry: p i"
gdb_test "p j" { = 31\.5} "entry: p j"


# Test virtual tail call frames.

gdb_continue_to_breakpoint "tailcall: breakhere"

gdb_test "bt" "^bt\r\n#0 +d *\\(i=71, j=73\\.5\\) \[^\r\n\]*\r\n#1 +0x\[0-9a-f\]+ in c \\(i=7, j=7\\.25\\) \[^\r\n\]*\r\n#2 +0x\[0-9a-f\]+ in b \\(i=5, j=5\\.25\\) \[^\r\n\]*\r\n#3 +0x\[0-9a-f\]+ in main \[^\r\n\]*" \
	 "tailcall: bt"
gdb_test "p i" " = 71" "tailcall: p i"
gdb_test "p j" " = 73\\.5" "tailcall: p j"

# Test $sp simulation for tail call frames.
#gdb_test {p/x $sp} " = 0x.*"
#gdb_test {p/x $pc} " = 0x.*"
gdb_test_no_output {set $sp0=$sp}
gdb_test "up" "\r\n#1 .*"
#gdb_test {p/x $sp} " = 0x.*"
gdb_test {p $sp0 == $sp} " = true"
gdb_test "frame 3" "\r\n#3 .*"
gdb_test {p $sp0 + sizeof (void *) == $sp} " = true"


# Test partial-ambiguous virtual tail call frames chain.

gdb_continue_to_breakpoint "ambiguous: breakhere"

gdb_test "bt" "^bt\r\n#0 +d \\(i=<optimized out>, j=<optimized out>\\)\[^\r\n\]*\r\n#1 +0x\[0-9a-f\]+ in amb_z \\(i=<optimized out>\\)\[^\r\n\]*\r\n#2 +0x\[0-9a-f\]+ in amb_y \\(i=<optimized out>\\)\[^\r\n\]*\r\n#3 +0x\[0-9a-f\]+ in amb_x \\(i=<optimized out>\\)\[^\r\n\]*\r\n#4 +0x\[0-9a-f\]+ in amb_b \\(i=101\\)\[^\r\n\]*\r\n#5 +0x\[0-9a-f\]+ in amb_a \\(i=100\\)\[^\r\n\]*\r\n#6 +0x\[0-9a-f\]+ in main \\(\\)\[^\r\n\]*" \
	 "ambiguous: bt"


# Test self tail calls verification.
# GDB should not print the real value as it is ambiguous.

gdb_continue_to_breakpoint "self: breakhere"

gdb_test "bt" "^bt\r\n#0 +d \\(i=<optimized out>, j=<optimized out>\\)\[^\r\n\]*\r\n#1 +0x\[0-9a-f\]+ in self \\(i=<optimized out>\\)\[^\r\n\]*\r\n#2 +0x\[0-9a-f\]+ in main \\(\\)\[^\r\n\]*" \
	 "self: bt"

gdb_test_no_output "set debug entry-values 1"
gdb_test "bt" "DW_OP_GNU_entry_value resolving has found function \"self\\(int\\)\" at 0x\[0-9a-f\]+ can call itself via tail calls\r\n.*" \
	 "self: bt debug entry-values"
