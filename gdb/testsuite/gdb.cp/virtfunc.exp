# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004
# Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@cygnus.com)
# And rewritten by Michael Chastain <mec.gnu@mindspring.com>.

set ws "\[\r\n\t \]+"
set nl "\[\r\n\]+"

if $tracelevel then {
    strace $tracelevel
}

if { [skip_cplus_tests] } { continue }

set testfile "virtfunc"
set srcfile ${testfile}.cc
set binfile ${objdir}/${subdir}/${testfile}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {c++ debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Test ptype of class objects.
#
# Different C++ compilers produce different output.  I build up regular
# expressions piece by piece to accommodate all the compilers that I
# have seen: gcc 2.95.3, gcc 3.3.2 (ABI 1), gcc 3.4 prerelease (ABI 2);
# and all the debug formats I have seen: dwarf-2 and stabs+.
#
# A complicated class declaration looks like this:
#
#   class A : public virtual V {	// re_class
#     private:
#       V * _vb$V;			// re_vbptr
#       int a;				// re_fields
#
#     public:
#       A & operator=(A const &);	// re_synth_gcc_2
#       A(int, A const &);		// ...
#       A(int);				// ...
#       virtual int f(void);		// re_methods
#   }
#
# RE_CLASS matches the class declaration.  C++ allows multiple ways of
# expressing this.
#
#   struct ... { private: ... };
#   class ... { private: ... };
#   class ... { ... };
#
# RE_VBPTR matches the virtual base declarations.  gcc 2.95.3 emits
# these, but gcc 3.X.Y does not.  The name depends on the debug format.
#
# RE_FIELDS matches the data fields of the class.
# RE_METHODS matches the methods explicitly declared for the class.
#
# RE_SYNTH_GCC_2 and RE_SYNTH_GCC_3 match the optional synthetic methods
# of the class.  gcc -gstabs+ emits these methods, and gcc -gdwarf-2
# does not.
#
# RE_ALL_METHODS combines RE_METHODS and the optional synthetic methods.
# Up to gcc 3.3.X, gcc defaults to gcc ABI 1, with synthetic methods at
# the beginning.  Starting with gcc 3.4.X, gcc defaults to gcc ABI 2,
# with synthetic methods at the end.
#
# So the possible choices for RE_ALL_METHODS are:
#
#   RE_METHODS			// any gcc with dwarf-2
#   RE_SYNTH_GCC_2|RE_METHODS	// gcc 2.95.3, stabs+
#   RE_SYNTH_GCC_3|RE_METHODS	// gcc 3.3.2, stabs+
#   RE_METHODS|RE_SYNTH_GCC_3	// gcc 3.4.0, stabs+
#
# When I get HP-UX aCC, I hope that I can just add RE_SYNTH_ACC_FOO
# and enlarge RE_ALL_METHODS.
#
# Yet another twist: with gcc v2, ctor and dtor methods have a hidden
# argument in front, the "in-charge" flag.  With gcc v3, there is no
# hidden argument; instead, there are multiple object functions for
# each ctor and dtor.
#
# I use gdb_test_multiple with only one arm.  I could use gdb_test,
# but gdb_test_multiple makes it easier to add KFAIL arms as needed.
#
# -- chastain 2003-12-31

proc test_ptype_of_classes {} {
    global gdb_prompt
    global ws
    global nl

    # class VA

    set re_class	"((struct|class) VA \{${ws}public:|struct VA \{)"
    set re_fields	"int va;"
    set re_synth_gcc_23	"VA & operator=\\(VA const ?&\\);${ws}VA\\(VA const ?&\\);${ws}VA\\((void|)\\);"
    set re_all_methods	"(|$re_synth_gcc_23)"

    gdb_test_multiple "ptype VA" "ptype VA" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype VA"
	}
    }

    # class VB

    set re_class	"((struct|class) VB \{${ws}public:|struct VB \{)"
    set re_fields	"int vb;"
    set re_methods	"int fvb\\((void|)\\);${ws}virtual int vvb\\((void|)\\);"
    set re_synth_gcc_23	"VB & operator=\\(VB const ?&\\);${ws}VB\\(VB const ?&\\);${ws}VB\\((void|)\\);"
    set re_all_methods	"($re_methods|$re_methods${ws}$re_synth_gcc_23|$re_synth_gcc_23${ws}$re_methods)"

    gdb_test_multiple "ptype VB" "ptype VB" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype VB"
	}
    }

    # An instance of VB

    gdb_test_multiple "ptype vb" "ptype vb" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype vb"
	}
    }

    # An instance of VB *

    gdb_test_multiple "ptype pVB" "ptype pVB" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVB"
	}
    }

    # class V

    set re_class	"class V : public VA, public VB \{${ws}public:"
    set re_fields	"int w;"
    set re_methods	"int f\\((void|)\\);${ws}virtual int vv\\((void|)\\);"
    set re_synth_gcc_23	"V & operator=\\(V const ?&\\);${ws}V\\(V const ?&\\);${ws}V\\((void|)\\);"
    set re_all_methods	"($re_methods|$re_methods${ws}$re_synth_gcc_23|$re_synth_gcc_23${ws}$re_methods)"

    gdb_test_multiple "ptype V" "ptype V" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype V"
	}
    }

    # An instance of V

    gdb_test_multiple "ptype v" "ptype v" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype v"
	}
    }

    # An instance of V *

    gdb_test_multiple "ptype pVa" "ptype pVa" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVa"
	}
    }

    # An instance of V *

    gdb_test_multiple "ptype pVv" "ptype pVv" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVv"
	}
    }

    # An instance of V *

    gdb_test_multiple "ptype pVe" "ptype pVe" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVe"
	}
    }

    # An instance of V *

    gdb_test_multiple "ptype pVd" "ptype pVd" {
	-re "type = $re_class${ws}$re_fields${ws}(public:${ws}|)$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pVd"
	}
    }

    # class A

    set re_class	"class A : public virtual V \{(${ws}private:|)"
    set re_vbptr 	"V \\*(_vb.1V|_vb.V);"
    set re_fields	"int a;"
    set re_methods	"virtual int f\\((void|)\\);"
    # gcc 2 adds an "in-charge" arg to the ctor.
    set re_synth_gcc_2	"A & operator=\\(A const ?&\\);${ws}A\\(int, A const ?&\\);${ws}A\\(int\\);"
    set re_synth_gcc_3	"A & operator=\\(A const ?&\\);${ws}A\\(A const ?&\\);${ws}A\\(\\);"
    set re_all_methods	"($re_methods|$re_synth_gcc_2${ws}$re_methods|$re_synth_gcc_3${ws}$re_methods|$re_methods${ws}$re_synth_gcc_3)"

    gdb_test_multiple "ptype A" "ptype A" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype A"
	}
    }

    # An instance of A

    gdb_test_multiple "ptype a" "ptype a" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype a"
	}
    }

    # An instance of A *

    gdb_test_multiple "ptype pAa" "ptype pAa" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pAa"
	}
    }

    # An instance of A *

    gdb_test_multiple "ptype pAe" "ptype pAe" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pAe"
	}
    }

    # class B

    set re_class	"class B : public A \{(${ws}private:|)"
    set re_vbptr	"V \\*(_vb.1V|_vb.V);"
    set re_fields	"int b;"
    set re_methods	"virtual int f\\((void|)\\);"
    set re_synth_gcc_2	"B & operator=\\(B const ?&\\);${ws}B\\(int, B const ?&\\);${ws}B\\(int\\);"
    set re_synth_gcc_3	"B & operator=\\(B const ?&\\);${ws}B\\(B const ?&\\);${ws}B\\(\\);"
    set re_all_methods	"($re_methods|$re_synth_gcc_2${ws}$re_methods|$re_synth_gcc_3${ws}$re_methods|$re_methods${ws}$re_synth_gcc_3)"

    gdb_test_multiple "ptype B" "ptype B" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype B"
	}
    }

    # An instance of B

    gdb_test_multiple "ptype b" "ptype b" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype b"
	}
    }

    # An instance of B *

    gdb_test_multiple "ptype pBe" "ptype pBe" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)${re_fields}${ws}public:${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pBe"
	}
    }

    # class C

    set re_class	"class C : public virtual V \{(${ws}private:|)"
    set re_vbptr	"V \\*(_vb.1V|_vb.V);"
    set re_fields	"int c;"
    set re_synth_gcc_2	"C & operator=\\(C const ?&\\);${ws}C\\(int, C const ?&\\);${ws}C\\(int\\);"
    set re_synth_gcc_3	"C & operator=\\(C const ?&\\);${ws}C\\(C const ?&\\);${ws}C\\(\\);"
    set re_all_methods	"(|$re_synth_gcc_2|$re_synth_gcc_3)"

    gdb_test_multiple "ptype C" "ptype C" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}(public:${ws}|)${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype C"
	}
    }

    # An instance of C

    gdb_test_multiple "ptype c" "ptype c" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}(public:${ws}|)${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype c"
	}
    }

    # class AD

    set re_class	"((struct|class) AD \{${ws}public:|struct AD \{)"
    set re_methods	"virtual int vg\\((void|)\\);"
    set re_synth_gcc_23	"AD & operator=\\(AD const ?&\\);${ws}AD\\(AD const ?&\\);${ws}AD\\((void|)\\);"
    set re_all_methods	"($re_methods|$re_methods${ws}$re_synth_gcc_23|$re_synth_gcc_23${ws}$re_methods)"

    gdb_test_multiple "ptype AD" "ptype AD" {
	-re "type = $re_class${ws}$re_all_methods$nl\}$nl$gdb_prompt $" {
	    pass "ptype AD"
	}
    }

    # An instance of AD *
    # TODO: this should be named pADd, not pAd.

    gdb_test_multiple "ptype pAd" "ptype pAd" {
	-re "type = $re_class${ws}$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pAd"
	}
    }

    # An instance of a AD *

    gdb_test_multiple "ptype pADe" "ptype pADe" {
	-re "type = $re_class${ws}$re_all_methods$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pADe"
	}
    }

    # class D
    #
    # I wrote this differently from the others to avoid a problem with
    # the sourceware version of expect, which dates from 1998.
    # The bug manifests as ERROR/UNRESOLVED results after an "eof"
    # in gdb_test_multiple.
    #
    # -- chastain 2004-01-01

    set re_class	"class D : public AD, public virtual V \{(${ws}private:|)"
    set re_vbptr	"V \\*(_vb.1V|_vb.V);"
    set re_fields	"int d;"
    set re_methods_2	"static void s\\(void\\);${ws}virtual int vg\\(void\\);${ws}virtual int vd\\(void\\);${ws}int fd\\(void\\);"
    set re_methods_3	"static void s\\(\\);${ws}virtual int vg\\(\\);${ws}virtual int vd\\(\\);${ws}int fd\\(\\);"
    set re_synth_gcc_2	"D & operator=\\(D const ?&\\);${ws}D\\(int, D const ?&\\);${ws}D\\(int\\);"
    set re_synth_gcc_3	"D & operator=\\(D const ?&\\);${ws}D\\(D const ?&\\);${ws}D\\(\\);"
    set re_all_methods	"($re_methods_2|$re_methods_3|$re_synth_gcc_2${ws}$re_methods_2|$re_synth_gcc_3${ws}$re_methods_3|$re_methods${ws}$re_synth_gcc_3)"

    gdb_test_multiple "ptype D" "ptype D" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype D"
	}
    }

    # An instance of D

    gdb_test_multiple "ptype d" "ptype d" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype d"
	}
    }

    # An instance of D

    gdb_test_multiple "ptype dd" "ptype dd" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype dd"
	}
    }

    # An instance of D *

    gdb_test_multiple "ptype ppd" "ptype ppd" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype ppd"
	}
    }

    # An instance of D *

    gdb_test_multiple "ptype pDd" "ptype pDd" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pDd"
	}
    }

    # An instance of D *

    gdb_test_multiple "ptype pDe" "ptype pDe" {
	-re "type = ${re_class}${ws}(${re_vbptr}${ws}|)public:${ws}${re_fields}${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pDe"
	}
    }

    # class E
    # TODO: E does not show a vbptr for V.  That seems strange.

    set re_class	"class E : public B, public virtual V, public D, public C \{(${ws}private:|)"
    set re_fields	"int e;"
    set re_methods	"virtual int f\\((void|)\\);${ws}virtual int vg\\((void|)\\);${ws}virtual int vv\\((void|)\\);"
    set re_synth_gcc_2	"E & operator=\\(E const ?&\\);${ws}E\\(int, E const ?&\\);${ws}E\\(int\\);"
    set re_synth_gcc_3	"E & operator=\\(E const ?&\\);${ws}E\\(E const ?&\\);${ws}E\\(\\);"
    set re_all_methods	"($re_methods|$re_synth_gcc_2${ws}$re_methods|$re_synth_gcc_3${ws}$re_methods|$re_methods${ws}$re_synth_gcc_3)"

    gdb_test_multiple "ptype E" "ptype E" {
	-re "type = ${re_class}${ws}public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype E"
	}
    }

    # An instance of E

    gdb_test_multiple "ptype e" "ptype e" {
	-re "type = ${re_class}${ws}public:${ws}${re_fields}${ws}${re_all_methods}$nl\}$nl$gdb_prompt $" {
	    pass "ptype e"
	}
    }

    # An instance of E *

    gdb_test_multiple "ptype pEe" "ptype pEe" {
	-re "type = ${re_class}${ws}public:${ws}${re_fields}${ws}${re_all_methods}$nl\} \\*$nl$gdb_prompt $" {
	    pass "ptype pEe"
	}
    }
}

# Call virtual functions.

proc test_virtual_calls {} {
    global gdb_prompt
    global nl

    if [target_info exists gdb,cannot_call_functions] {
	setup_xfail "*-*-*" 2416
	fail "This target can not call functions"
	return 0
    }

    gdb_test "print pAe->f()"   "\\$\[0-9\]+ = 20"
    gdb_test "print pAa->f()"   "\\$\[0-9\]+ = 1"
    gdb_test "print pDe->vg()"  "\\$\[0-9\]+ = 202"
    gdb_test "print pADe->vg()" "\\$\[0-9\]+ = 202"
    gdb_test "print pDd->vg()"  "\\$\[0-9\]+ = 101"
    gdb_test "print pEe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pVB->vvb()" "\\$\[0-9\]+ = 407"
    gdb_test "print pBe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pDe->vvb()" "\\$\[0-9\]+ = 411"
    gdb_test "print pEe->vd()"  "\\$\[0-9\]+ = 282"
    gdb_test "print pEe->fvb()" "\\$\[0-9\]+ = 311"

    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=2.95.3, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=2.95.3, goption=-gstabs+.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=3.0.3, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=3.0.3, goption=-gstabs+.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=3.0.4-20020215, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=3.0.4-20020215, goption=-gstabs+.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=gcc-3_0-branch%2002-02-16, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=gcc-3_0-branch%2002-02-16, goption=-gstabs+.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=HEAD%2002-02-16, goption=-gdwarf-2.
    #
    # fails on target=native, host=i686-pc-linux-gnu%rh-7.2,
    # gdb=HEAD%2002-02-16, gcc=HEAD%2002-02-16, goption=-gstabs+.
    #
    # -- chastain 2002-02-20

    # more recent results:
    # wrong value "202"
    #   gcc 2.95.3 -gdwarf-2
    #   gcc 2.95.3 -gstabs+
    # attempt to take addres of value not located in memory
    #   gcc 3.3.2 -gdwarf-2
    #   gcc 3.3.2 -gstabs+
    #
    # -- chastain 2003-12-31

    gdb_test_multiple "print pEe->D::vg()" "print pEe->D::vg()" {
	-re "\\$\[0-9]+ = 102$nl$gdb_prompt $" {
	    pass "print pEe->D::vg()"
	}
	-re "Attempt to take address of value not located in memory.$nl$gdb_prompt $" {
	    kfail "gdb/1064" "print pEe->D::vg()"
	}
    }
}

proc do_tests {} {
    global prms_id
    global bug_id
    global srcdir subdir binfile
    global gdb_prompt

    set prms_id 0
    set bug_id 0

    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $binfile

    gdb_test "set language c++" "" ""
    gdb_test "set width 0" "" ""

    runto_main
    test_ptype_of_classes

    gdb_breakpoint test_calls
    gdb_test "continue" ".*Breakpoint .* test_calls.*" ""
    test_virtual_calls
}

do_tests
