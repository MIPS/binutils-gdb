# Copyright (C) 2015 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This test verifies that several threads forking while another thread
# is constantly stepping over a breakpoint is properly handled.

standard_testfile

set linenum [gdb_get_line_number "set break here"]

set saved_gdbflags $GDBFLAGS
set GDBFLAGS [concat $GDBFLAGS " -ex \"set non-stop on\""]

if {[build_executable "failed to prepare" $testfile $srcfile {debug pthreads}] == -1} {
    set GDBFLAGS $saved_gdbflags
    return -1
}

set GDBFLAGS $saved_gdbflags

# The test proper.  If JOIN_BP_THREAD is true, then we'll ask the
# thread_breakpoint thread to exit, and join it.  If JOIN_BP_THREAD is
# false, the main process exits as soon as all fork threads exit,
# which frequently happens while GDB is handling a breakpoint event
# for the thread_breakpoint thread (that is, while that thread is
# stopped).  GDB should be able to handle that too.  If COND_BP_TARGET
# is true, then test with conditional breakpoints evaluated on the
# target side, if possible.
proc do_test { join_bp_thread cond_bp_target detach_on_fork } {
    global GDBFLAGS
    global srcfile testfile binfile
    global decimal gdb_prompt
    global linenum
    global is_remote_target

    clean_restart $binfile

    if ![runto_main] then {
	fail "Can't run to main"
	return 0
    }

    # Whether it's known that the !$join_bp_thread variant of the test
    # fails.
    set should_kfail 0

    if {![gdb_is_target_remote]} {
	set should_kfail 1
    } else {
	if {!$cond_bp_target} {
	    # Leaving breakpoint evaluation to GDB exposes failures
	    # similar to native debugging.
	    gdb_test_no_output "set remote conditional-breakpoints-packet off"
	    set should_kfail 1
	} else {
	    # With GDBserver testing and breakpoint evaluation on the
	    # target, the test seems to always pass.
	    set test "show remote conditional-breakpoints-packet"
	    gdb_test_multiple $test $test {
		-re "currently enabled\.\r\n$gdb_prompt $" {
		    pass $test
		}
		-re "currently disabled\.\r\n$gdb_prompt $" {
		    unsupported "no support for target-side conditional breakpoints"
		    return
		}
	    }
	}
    }

    gdb_test "print should_break_out = $join_bp_thread" " = $join_bp_thread"

    gdb_test_no_output "set detach-on-fork $detach_on_fork"

    gdb_test "break $linenum if zero == 1" \
	"Breakpoint .*" \
	"set breakpoint that evals false"

    set test "continue &"
    gdb_test_multiple $test $test {
	-re "$gdb_prompt " {
	    pass $test
	}
    }

    set fork_count 0
    set ok 0

    # Setup the kfail upfront in order to also catch GDB internal
    # errors.
    if {!$join_bp_thread && $should_kfail} {
	setup_kfail "gdb/18749" "*-*-linux*"
    }

    set test "inferior 1 exited"
    gdb_test_multiple "" $test {
	-re "Inferior 1 \(\[^\r\n\]+\) exited normally" {
	    set ok 1

	    # Clear the kfail to avoid a PASS -> KPASS dance across
	    # runs.
	    clear_kfail "*-*-linux*"

	    pass $test
	}
	-re "Inferior $decimal \(\[^\r\n\]+\) exited normally" {
	    incr fork_count
	    if {$fork_count <= 100} {
		exp_continue
	    } else {
		fail "$test (too many forks)"
	    }
	}
	-re "$gdb_prompt " {
	    # Several errors end up at the top level, and printing the
	    # prompt.
	    fail "$test (prompt)"
	}
	-re "Cannot access memory" {
	    fail "$test (memory error)"
	}
	eof {
	    fail "$test (GDB died)"
	}
    }

    if {!$ok} {
	# No use testing further.
	return
    }

    gdb_test "info threads" "No threads\." \
	"no threads left"

    gdb_test "info inferiors" \
	"Num\[ \t\]+Description\[ \t\]+Executable\[ \t\]+\r\n\\* 1 \[^\r\n\]+" \
	"only inferior 1 left"
}

# Wrapper for foreach that calls with_test_prefix on each iteration,
# including the iterator's current value in the prefix.

proc foreach_with_prefix {var list body} {
    upvar 1 $var myvar
    foreach myvar $list {
	with_test_prefix "$var=$myvar" {
	    uplevel 1 $body
	}
    }
}

foreach_with_prefix join_bp_thread {1 0} {
    foreach_with_prefix cond_bp_target {1 0} {
	foreach_with_prefix detach_on_fork {"on" "off"} {
	    do_test $join_bp_thread $cond_bp_target $detach_on_fork

	    # Disable "off" for now.  The test does pass with
	    # detach-on-fork off (at the time of writing), but gdb seems
	    # to slow down quadratically as inferiors are created, and
	    # then the test takes annoyingly long to complete...
	    break
	}
    }
}
